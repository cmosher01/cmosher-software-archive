;DAZZLE DRAW BOOT PROCESS
;------------------------
;Use "DOS 3.3 PATCHED" in COPY ][ PLUS 5.5 to read
;Track $00, Sector $0
;
;BOOT 0: load T$00 S$0 at $0800.$08FF
;        JMP $0801
;
;[FROM TRACK 0 SECTOR 0]
                                   ; BEGIN BOOT PART 1
0800-   01
0801-   86 43       STX   $43
0803-   A9 FF       LDA   #$FF
0805-   8D FB 04    STA   $04FB
0808-   8D 08 C0    STA   $C008    ; ALTZP off
080B-   8D 04 C0    STA   $C004    ; RAMWRT off
080E-   8D 02 C0    STA   $C002    ; RAMRD off
0811-   8D 0C C0    STA   $C00C    ; 80COL off
0814-   8D 00 C0    STA   $C000    ; 80STORE off
0817-   8D 81 C0    STA   $C081    ; ?
081A-   8D F3 03    STA   $03F3    ; make DOS 3.3 reset vector invalid
081D-   8D F4 03    STA   $03F4    ; (so reset causes a reboot)
0820-   20 2F FB    JSR   $FB2F    ; INIT (text, normal, line 23, etc.)
0823-   20 89 FE    JSR   $FE89    ; IN#0
0826-   20 93 FE    JSR   $FE93    ; PR#0
0829-   20 58 FC    JSR   $FC58    ; HOME

;------------begin-not-needed------------------------------------------------------------
                                   ; A0.A3: F5 F4 F3 F2
082C-   A2 03       LDX   #$03
082E-   BD 45 08    LDA   $0845,X
0831-   95 A0       STA   $A0,X
0833-   CA          DEX
0834-   10 F8       BPL   $082E

0836-   A9 00       LDA   #$00
0838-   85 FF       STA   $FF       ; current phase (we know we're at track $00)
083A-   A9 3E       LDA   #$3E      ; destination halftrack (= track $1F)

083C-   20 99 08    JSR   $0899     ; move disk arm to track $1F
083F-   20 49 08    JSR   $0849     ; read track $1F ($C sectors) to $6000.$6BFF
;------------end-not-needed------------------------------------------------------------





0842-   4C 00 60    JMP   $6000     ; go to beginning of program





;------------begin-not-needed------------------------------------------------------------
0845-   F5 F4 F3 F2




0849-   A9 0C       LDA   #$0C
084B-   85 A5       STA   $A5      ; A5 <-- C (counts down to 1) (# of sectors)

084D-   A0 00       LDY   #$00     ; A6.A7: $6000 (start of read buffer)
084F-   A9 60       LDA   #$60
0851-   84 A6       STY   $A6
0853-   85 A7       STA   $A7

0855-   A6 2B       LDX   $2B      ; X <-- SLOT0000

0857-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
085A-   10 FB       BPL   $0857
085C-   C5 A0       CMP   $A0      ; is F5?
085E-   D0 F7       BNE   $0857    ; branch if not

0860-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
0863-   10 FB       BPL   $0860
0865-   C5 A1       CMP   $A1      ; is F4?
0867-   D0 F3       BNE   $085C    ; branch if not

0869-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
086C-   10 FB       BPL   $0869
086E-   C5 A2       CMP   $A2      ; is F3?
0870-   D0 F3       BNE   $0865    ; branch if not

                                   ; found "F5 F4 F3" on track
                                   ; read $200 bytes (decode to $100 bytes)
                                   ; and store in buffer
0872-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
0875-   10 FB       BPL   $0872
0877-   2A          ROL            ; rotate this byte left
0878-   85 A4       STA   $A4

087A-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
087D-   10 FB       BPL   $087A
087F-   25 A4       AND   $A4      ; 4&4 decode
0881-   91 A6       STA   ($A6),Y  ; store the result (one byte) in buffer
0883-   C8          INY
0884-   D0 EC       BNE   $0872

0886-   0E FF FF    ASL   $FFFF    ; delay
0889-   BD 8C C0    LDA   $C08C,X  ; wait for next byte
088C-   10 FB       BPL   $0889
088E-   C5 A3       CMP   $A3      ; is F2?
0890-   D0 B7       BNE   $0849    ; if not then branch to start over

0892-   E6 A7       INC   $A7      ; incr buffer address
0894-   C6 A5       DEC   $A5      ; decr count of sectors
0896-   D0 DA       BNE   $0872
0898-   60          RTS


                                   ; move disk arm
                                   ; input:
                                   ;   A   destination halftrack
                                   ;   FF  current phase (0-3)
0899-   85 A8       STA   $A8      ; A8 = destination halftrack (constant)

089B-   A5 FF       LDA   $FF
089D-   85 A9       STA   $A9      ; phase, input to "turn phase off" fn
089F-   38          SEC
08A0-   E5 A8       SBC   $A8      ; (FF - destination halftrack)
08A2-   F0 2C       BEQ   $08D0    ; RTS if FF==halftracks (all done)
08A4-   B0 04       BCS   $08AA    ; if FF < halftracks then
08A6-   E6 FF       INC   $FF      ;     FF++ (moving arm upwards?)
08A8-   90 02       BCC   $08AC    ; else
08AA-   C6 FF       DEC   $FF      ;     --FF (moving arm downwards?)
                                   ; end if
08AC-   20 C5 08    JSR   $08C5    ; phase FF on
08AF-   20 D1 08    JSR   $08D1    ; wait 10 ms

                                   ; turn phase off
                                   ; input: A9 = phase (0-3)
08B2-   A5 A9       LDA   $A9      ; A <-- ......ab (0,1,2,3)
08B4-   29 03       AND   #$03     ; A <-- 000000ab
08B6-   0A          ASL            ; A <-- 00000ab0 (0,2,4,6)
08B7-   05 2B       ORA   $2B      ; A <-- SLOT0ab0
08B9-   A8          TAY            ; Y <-- SLOT0ab0
08BA-   B9 80 C0    LDA   $C080,Y  ; phase ab off
08BD-   20 D1 08    JSR   $08D1    ; wait 10 ms
08C0-   F0 D9       BEQ   $089B    ; branch always



08C2-   20 D1 08    JSR   $08D1    ; (dead code???)



                                   ; turn phase on
                                   ; input: FF = phase (0-3)
08C5-   A5 FF       LDA   $FF      ; A <-- ......ab (0,1,2,3)
08C7-   29 03       AND   #$03     ; A <-- 000000ab
08C9-   0A          ASL            ; A <-- 00000ab0 (0,2,4,6)
08CA-   05 2B       ORA   $2B      ; A <-- SLOT0ab0
08CC-   A8          TAY            ; Y <-- SLOT0ab0
08CD-   B9 81 C0    LDA   $C081,Y  ; phase ab on
08D0-   60          RTS



08D1-   A9 28       LDA   #$28     ; wait 10 ms
08D3-   4C A8 FC    JMP   $FCA8
08D6.08FF- 00
;------------end-not-needed------------------------------------------------------------














;[FROM TRACK: 1F]

                                   ; BEGIN BOOT PART 2
6000-   4C 1A 60    JMP   $601A    ; entry point
6003-   4C 2C 60    JMP   $602C    ; load into $7000.$7FFF and check checksum



;------------begin-not-needed------------------------------------------------------------
                                   ; 90.93: F5 F4 F3 F2
6006-   A2 F5       LDX   #$F5
6008-   86 90       STX   $90
600A-   CA          DEX
600B-   86 91       STX   $91
600D-   CA          DEX
600E-   86 92       STX   $92
6010-   CA          DEX
6011-   86 93       STX   $93

6013-   A9 0A       LDA   #$0A     ; read buffer = $0A00
6015-   A2 03       LDX   #$03     ; # of sectors to read
6017-   4C B5 60    JMP   $60B5    ; jmp and return
;------------end-not-needed------------------------------------------------------------


                                   ; (BOOT2 entry)
601A-   A2 FF       LDX   #$FF
601C-   9A          TXS            ; clear the stack
601D-   A6 2B       LDX   $2B      ; slot
601F-   86 08       STX   $08      ; why?
6021-   20 9A 61    JSR   $619A    ; check system
;------------begin-not-needed------------------------------------------------------------
6024-   20 2C 60    JSR   $602C    ; read from T$20, T$20.5, T$21, T$21.5
                                   ; into $7000.$7FFF
                                   ; and check checksum
6027-   B0 FB       BCS   $6024    ; retry if checksum was bad
;------------end-not-needed------------------------------------------------------------
6029-   4C 00 64    JMP   $6400    ; go to BOOT PART 3





;------------begin-not-needed------------------------------------------------------------
602C-   A9 40       LDA   #$40
602E-   20 19 61    JSR   $6119    ; move arm to track $20

6031-   A0 00       LDY   #$00
6033-   84 80       STY   $80

                                   ; read into $7000.$7FFF
                                   ; from T$20, T$20.5, T$20, T$20.5
                                   ;      T$21, T$21.5, T$21, T$21.5
6035-   84 81       STY   $81
6037-   B9 90 60    LDA   $6090,Y  ; $70, $78
603A-   F0 0A       BEQ   $6046
603C-   20 6B 60    JSR   $606B
603F-   B0 22       BCS   $6063
6041-   A4 81       LDY   $81
6043-   C8          INY
6044-   D0 EF       BNE   $6035
                                   ; calc checksum of $7000.$7FFF
6046-   A0 00       LDY   #$00
6048-   A9 70       LDA   #$70
604A-   84 90       STY   $90
604C-   85 91       STA   $91
604E-   A2 10       LDX   #$10
6050-   98          TYA
6051-   51 90       EOR   ($90),Y
6053-   C8          INY
6054-   D0 FB       BNE   $6051
6056-   E6 91       INC   $91
6058-   CA          DEX
6059-   D0 F6       BNE   $6051

605B-   CD FF 61    CMP   $61FF
605E-   D0 02       BNE   $6062    ; br if checksum doesn't match
6060-   18          CLC
6061-   24 38       BIT   $38      ; doubled-up code with:
;6062-  38          SEC
6063-   08          PHP
6064-   A9 36       LDA   #$36     ; move arm to track $1B
6066-   20 19 61    JSR   $6119
6069-   28          PLP
606A-   60          RTS

                                   ;start at track H     read 2 sectors
                                   ; move to track H+.5  read 2 sectors
                                   ; move to track H     read 2 sectors
                                   ; move to track H+.5  read 2 sectors
                                   ; move to track H+1
                                   ; input:
                                   ;   A   page # of read buffer ($70, $78)
                                   ;   $80 ? (counts from 0 up)
                                   ;   $FF current halftrack H
606B-   A0 00       LDY   #$00
606D-   84 82       STY   $82      ; index into 61EA table

606F-   48          PHA            ; save
6070-   20 93 60    JSR   $6093    ; read 2 sectors
6073-   B0 18       BCS   $608D    ; error exit

                                   ; add/subtract one half track
6075-   A4 82       LDY   $82
6077-   18          CLC
6078-   A5 FF       LDA   $FF
607A-   79 EA 61    ADC   $61EA,Y  ; [61EA- 01 FF 01 01]

607D-   20 1C 61    JSR   $611C    ; move arm to A halftrack (changes $FF)

6080-   68          PLA            ; restore A as given to us
6081-   18          CLC
6082-   69 02       ADC   #$02     ; incr read buffer address (by $0200, because 2 sectors read)

6084-   A4 82       LDY   $82
6086-   C8          INY
6087-   C0 04       CPY   #$04
6089-   90 E2       BCC   $606D    ; repeat 4 times (Y = 0,1,2,3)

608B-   18          CLC
608C-   60          RTS            ; OK exit
608D-   68          PLA            ; restore A as given to us
608E-   38          SEC
608F-   60          RTS            ; error exit

6090-   70 78 00



                                   ; read 2 sectors
                                   ; input:
                                   ;   A   page # of read buffer
                                   ;   $80 ? (counts from 0 up)
6093-   48          PHA            ; save

                                   ; use A as index into table
                                   ; read value and store at $90
6094-   A5 80       LDA   $80
6096-   29 07       AND   #$07
6098-   A8          TAY
6099-   B9 EE 61    LDA   $61EE,Y  ; [61EE- D5 B5 B7 BC DF D4 B4 DB]
609C-   85 90       STA   $90

                                   ; $80 --> 4&4 encode --> $91.$92
609E-   A5 80       LDA   $80
60A0-   4A          LSR
60A1-   09 AA       ORA   #$AA
60A3-   85 91       STA   $91
60A5-   A5 80       LDA   $80
60A7-   09 AA       ORA   #$AA
60A9-   85 92       STA   $92

60AB-   AD F6 61    LDA   $61F6    ; $93 <-- #$F5
60AE-   85 93       STA   $93

60B0-   68          PLA            ; restore A as given to us
60B1-   E6 80       INC   $80
60B3-   A2 02       LDX   #$02     ; read 2 sectors and return


                                   ; input:
                                   ;   A page # of read buffer
                                   ;   X number of sectors to read
                                   ;   $99 ?
60B5-   85 94       STA   $94
60B7-   8E BF 60    STX   $60BF    ; number of sectors (self-mod***)
60BA-   A9 68       LDA   #$68     ; ???
60BC-   85 9A       STA   $9A
60BE-   A2 02       LDX   #$02     ; LDX #***number of sectors
60C0-   86 97       STX   $97      ; input to read sectors fn
60C2-   A0 00       LDY   #$00
60C4-   A5 94       LDA   $94
60C6-   84 95       STY   $95
60C8-   85 96       STA   $96      ; $95.$96: $aa00 (aa is Accumulator) (input to read sectors fn)
60CA-   A6 2B       LDX   $2B
60CC-   C6 99       DEC   $99
60CE-   D0 06       BNE   $60D6    ; read sectors and return
60D0-   C6 9A       DEC   $9A
60D2-   D0 02       BNE   $60D6    ; read sectors and return
60D4-   38          SEC            ; error and return
60D5-   60          RTS


                                   ; read sectors
                                   ; track format:
                                   ;     F5 F4 F3 ($200 bytes) F2 ($200 bytes) F2 ...
                                   ; $200 bytes decodes to $100 bytes
                                   ; input: $97 number of sectors
                                   ; i/o:   $95.$96 buffer address
                                   ; out:   carry set if error

                                   ; read header F5 F4 F3
60D6-   BD 8C C0    LDA   $C08C,X
60D9-   10 FB       BPL   $60D6
60DB-   C5 90       CMP   $90      ; #$F5
60DD-   D0 ED       BNE   $60CC
60DF-   BD 8C C0    LDA   $C08C,X
60E2-   10 FB       BPL   $60DF
60E4-   C5 91       CMP   $91      ; #$F4
60E6-   D0 F3       BNE   $60DB
60E8-   BD 8C C0    LDA   $C08C,X
60EB-   10 FB       BPL   $60E8
60ED-   C5 92       CMP   $92      ; #$F3
60EF-   D0 F3       BNE   $60E4
                                   ; found beginning of data
                                   ; read $200 pairs of bytes and 4&4 decode
60F1-   BD 8C C0    LDA   $C08C,X
60F4-   10 FB       BPL   $60F1
60F6-   2A          ROL
60F7-   85 98       STA   $98
60F9-   BD 8C C0    LDA   $C08C,X
60FC-   10 FB       BPL   $60F9
60FE-   25 98       AND   $98
6100-   91 95       STA   ($95),Y  ; store decoded bytes into buffer
6102-   C8          INY
6103-   D0 EC       BNE   $60F1
                                   ; done reading sector
                                   ; check trailer F2
6105-   0E FF FF    ASL   $FFFF    ; short delay
6108-   BD 8C C0    LDA   $C08C,X
610B-   10 FB       BPL   $6108
610D-   C5 93       CMP   $93      ; #$F2
610F-   D0 AD       BNE   $60BE    ; br if bad trailer byte
6111-   E6 96       INC   $96
6113-   C6 97       DEC   $97
6115-   D0 DA       BNE   $60F1    ; go back and read/decode another $200 bytes
6117-   18          CLC
6118-   60          RTS

                                   ; move arm to destination halftrack
                                   ; input: A  destination halftrack
6119-   A2 13       LDX   #$13
611B-   2C A2 0A    BIT   $0AA2    ; doubled-up code with:
;611C-  A2 0A       LDX   #$0A
611E-   8E 78 61    STX   $6178    ; self-mod*** wait factor
6121-   85 9B       STA   $9B      ; constant: destination halftrack
6123-   C5 FF       CMP   $FF
6125-   F0 4D       BEQ   $6174    ; quick check: return if already there

6127-   A9 00       LDA   #$00
6129-   85 9C       STA   $9C      ; ??? (counts to $100)

612B-   A5 FF       LDA   $FF      ; current phase (starts at track $1F = halftrack $3E)
612D-   85 9D       STA   $9D      ; input for "phase off" below
612F-   38          SEC
6130-   E5 9B       SBC   $9B      ; phase minus destination halftrack
6132-   F0 31       BEQ   $6165

6134-   B0 06       BCS   $613C    ; track arith. (up or down)
6136-   49 FF       EOR   #$FF     ; abs value (negate and add one)
6138-   E6 FF       INC   $FF
613A-   90 04       BCC   $6140    ; br always
613C-   69 FE       ADC   #$FE
613E-   C6 FF       DEC   $FF

6140-   C5 9C       CMP   $9C
6142-   90 02       BCC   $6146
6144-   A5 9C       LDA   $9C
6146-   C9 0C       CMP   #$0C
6148-   B0 01       BCS   $614B
614A-   A8          TAY


                                   ; arm move
614B-   38          SEC
614C-   20 69 61    JSR   $6169    ; phase FF on
614F-   B9 82 61    LDA   $6182,Y
6152-   20 77 61    JSR   $6177    ; wait
6155-   A5 9D       LDA   $9D
6157-   18          CLC
6158-   20 6B 61    JSR   $616B    ; phase 9D off
615B-   B9 8E 61    LDA   $618E,Y
615E-   20 77 61    JSR   $6177    ; wait
6161-   E6 9C       INC   $9C
6163-   D0 C6       BNE   $612B

6165-   20 77 61    JSR   $6177    ; wait
6168-   18          CLC            ; phase FF off

                                   ; phase FF (~C=off,C=on)
6169-   A5 FF       LDA   $FF      ; ......ab C
616B-   29 03       AND   #$03     ; 000000ab C
616D-   2A          ROL            ; 00000abC 0
616E-   05 2B       ORA   $2B      ; SLOT0abC
6170-   AA          TAX
6171-   BD 80 C0    LDA   $C080,X
6174-   A6 2B       LDX   $2B
6176-   60          RTS

6177-   A2 13       LDX   #$13     ; wait (***) * A loops
6179-   CA          DEX
617A-   D0 FD       BNE   $6179
617C-   38          SEC
617D-   E9 01       SBC   #$01
617F-   D0 F6       BNE   $6177
6181-   60          RTS


6182-   01 30 28 24 20 1E 1D 1C 1C 1C 1C 1C
        70 2C 26 22 1F 1E 1D 1C 1C 1C 1C 1C
;------------end-not-needed------------------------------------------------------------





                                   ; check system

                                   ; check Monitor version
619A-   AD B3 FB    LDA   $FBB3
619D-   C9 06       CMP   #$06     ; is $06 on IIe and //c machines, not ][ or ][+
619F-   D0 16       BNE   $61B7    ; branch if neither //c nor IIe

                                   ; make sure aux RAM exists
61A1-   8D 09 C0    STA   $C009    ; use aux zero page, stack, and bsr
61A4-   A9 AA       LDA   #$AA
61A6-   85 00       STA   $00
61A8-   C5 00       CMP   $00
61AA-   D0 0B       BNE   $61B7    ; br if doesn't exist
61AC-   4A          LSR
61AD-   85 00       STA   $00
61AF-   C5 00       CMP   $00
61B1-   D0 04       BNE   $61B7    ; br if doesn't exist
61B3-   8D 08 C0    STA   $C008    ; use main zero page, stack, and bsr
61B6-   60          RTS            ; all's well, so just return



                                   ; print "requires //c or IIe" and halt
61B7-   8D 08 C0    STA   $C008    ; ALTZP off

61BF-   A2 1C       LDX   #$1C     ; print error message
61C1-   BD CD 61    LDA   $61CD,X
61C4-   9D A8 04    STA   $04A8,X
61C7-   CA          DEX
61C8-   10 F7       BPL   $61C1

61CA-   4C CA 61    JMP   $61CA    ; halt

                                   ; "REQUIRED //C OR //E WITH 128K"
61CD-   D2 C5 D1 D5 C9 D2 C5 D3 A0 AF AF C3 A0 CF D2 A0 AF AF C5 A0 D7 C9 D4 C8 A0 B1 B2 B8 CB





;------------begin-not-needed------------------------------------------------------------
61EA-   01 FF 01 01
61EE-   D5 B5 B7 BC DF D4 B4 DB
61F6-   F5 00
;------------end-not-needed------------------------------------------------------------





61F8.61FF- 00



6200-   00                         ; 0 = backup disk, ? = original disk



6201.62FF- 00
6300.63FF- 00















                                   ; BEGIN BOOT PART 3
6400-   4C 89 64    JMP   $6489    ; entry point
6403-   4C B7 64    JMP   $64B7    ; skip splash screen & util menu, go run program
;----begin---copied-to-$0900-and-kept-during-execution-of-program---------------------------
6406-   8D 54 C0    STA   $C054    ; page 1
6409-   8D 52 C0    STA   $C052    ; not mixed
640C-   8D 57 C0    STA   $C057    ; hires
640F-   8D 01 C0    STA   $C001    ; 80STORE on
6412-   8D 50 C0    STA   $C050    ; graphics
6415-   8D 0D C0    STA   $C00D    ; 80 col
6418-   8D 5E C0    STA   $C05E    ; dhires on
641B-   8D 5F C0    STA   $C05F    ; dhires off
641E-   8D 5E C0    STA   $C05E    ; dhires on
6421-   8D 5F C0    STA   $C05F    ; dhires off

6424-   8D 5E C0    STA   $C05E    ; dhires on
6427-   60          RTS

6428-   8D 0C C0    STA   $C00C    ; 40 col
642B-   8D 51 C0    STA   $C051    ; text
642E-   8D 00 C0    STA   $C000    ; 80STORE off
6431-   60          RTS
;----end---copied-to-$0900-and-kept-during-execution-of-program---------------------------
; (actually, more is copied, but cannot be used because the code is not relocatable)

6432-   1F                         ; track number

                                   ; read tracks $6432  , $6432+1 to $2000.$3FFF aux
                                   ; and  tracks $6432+2, $6432+3 to $2000.$3FFF main

6433-   20 3D 64    JSR   $643D    ; read track $6432,$6432+1 to $2000.3FFF
6436-   A9 20       LDA   #$20
6438-   AA          TAX
6439-   A8          TAY
643A-   20 5A 64    JSR   $645A    ; copy $2000.$3FFF main to aux
                                   ; read track $6432++ to $2000.$2FFF

643D-   A9 20       LDA   #$20     ; dest page
643F-   20 44 64    JSR   $6444    ; read track $6432++ to $2000.$2FFF

6442-   A9 30       LDA   #$30     ; read track $6432++ to $3000.3FFF

                                   ; read track $6432++ to page A
6444-   AC 32 64    LDY   $6432    ; track # to read
6447-   EE 32 64    INC   $6432    ; incr track for next time
644A-   4C 00 67    JMP   $6700    ; read track & return


                                   ; read track into given page list
                                   ; input:
                                   ;   list of $10 pages following JSR instr
                                   ;   $6432 track to read
                                   ; output:
                                   ;   $6432 ++
644D-   AC 32 64    LDY   $6432    ; track # to read
6450-   EE 32 64    INC   $6432    ; incr track for next time
6453-   4C 03 67    JMP   $6703

                                   ; copy $10 pages from $2000 main to aux
                                   ; input:
                                   ;   Y dst page (aux)
6456-   A9 20       LDA   #$20
6458-   A2 10       LDX   #$10

                                   ; copy pages from main to aux
                                   ; input:
                                   ;   A src page (main)
                                   ;   Y dst page (aux)
                                   ;   X number of pages
645A-   85 E1       STA   $E1
645C-   84 E3       STY   $E3
645E-   A0 00       LDY   #$00
6460-   84 E0       STY   $E0
6462-   84 E2       STY   $E2
6464-   8C 05 C0    STY   $C005    ; write aux ram
6467-   B1 E0       LDA   ($E0),Y
6469-   91 E2       STA   ($E2),Y
646B-   C8          INY
646C-   D0 F9       BNE   $6467
646E-   E6 E1       INC   $E1
6470-   E6 E3       INC   $E3
6472-   CA          DEX
6473-   D0 F2       BNE   $6467
6475-   8D 04 C0    STA   $C004    ; write main ram
6478-   60          RTS

                                   ; read track $6432++ to $2000.$2FFF
6479-   A9 20       LDA   #$20     ; dest page
647B-   D0 C7       BNE   $6444    ; br always, then return





                                   ; drive on
647D-   A6 2B       LDX   $2B
647F-   BD 89 C0    LDA   $C089,X
6482-   60          RTS
                                   ; drive off
6483-   A6 2B       LDX   $2B
6485-   BD 88 C0    LDA   $C088,X
6488-   60          RTS






                                   ; (BOOT3 entry)

;------------begin-not-needed------------------------------------------------------------
                                   ; show splash screen
6489-   A0 1A       LDY   #$1A
648B-   8C 32 64    STY   $6432    ; starting track number
648E-   20 33 64    JSR   $6433    ; read T$1A,T$1B to $2000.$3FFF aux;
                                   ; and  T$1C,T$1D to $2000.$3FFF main
6491-   20 06 64    JSR   $6406    ; screen mode (dhires, etc.)

6494-   A9 40       LDA   #$40
6496-   20 44 64    JSR   $6444    ; read T$1E to $4000.4FFF

6499-   20 83 64    JSR   $6483    ; drive off
;------------end-not-needed------------------------------------------------------------



649C-   20 06 71    JSR   $7106    ; search for mouse card, and init



;------------begin-not-needed------------------------------------------------------------
                                   ; wait for keypress with timeout
649F-   A9 65       LDA   #$65
64A1-   85 E0       STA   $E0      ; delay factor for keypress timeout
64A3-   20 09 71    JSR   $7109    ; check for keypress (no wait)
64A6-   30 09       BMI   $64B1    ; got one, branch out of loop
64A8-   A9 90       LDA   #$90
64AA-   20 A8 FC    JSR   $FCA8    ; delay
64AD-   C6 E0       DEC   $E0
64AF-   D0 F2       BNE   $64A3    ; keep waiting
;------------end-not-needed------------------------------------------------------------



64B1-   20 28 64    JSR   $6428    ; 40 col text mode
64B4-   4C 00 71    JMP   $7100    ; show RETURN/ESC choice, & run utilities if desired
                                   ; (settings the user can make in the utility menu
                                   ; get saved at $66F0.$66F6, (menu items are 0-origin))
                                   ; when user exits utility menu, he comes back here:









                                   ; BEGIN BOOT PART 4
                                   ; load and run the real DD program
64B7-   20 7D 64    JSR   $647D    ; turn disk drive on
64BA-   A9 00       LDA   #$00
64BC-   20 A8 FC    JSR   $FCA8    ; delay
64BF-   A9 01       LDA   #$01
64C1-   20 09 67    JSR   $6709    ; move disk arm to T$01

                                   ; set up ptrs: ($00)-->$2000, ($2000)-->$0009, ($2100)-->0
64C4-   A0 00       LDY   #$00
64C6-   A9 20       LDA   #$20
64C8-   84 00       STY   $00
64CA-   85 01       STA   $01
64CC-   A0 00       LDY   #$00
64CE-   A9 09       LDA   #$09
64D0-   8D 00 20    STA   $2000
64D3-   8C 01 20    STY   $2001
64D6-   8C 00 21    STY   $2100
64D9-   8C 01 21    STY   $2101
                                   ; read block 9 into $1E00.$1FFF (block map of prodos file)
64DC-   A0 00       LDY   #$00
64DE-   A9 1E       LDA   #$1E
64E0-   A2 01       LDX   #$01
64E2-   20 06 67    JSR   $6706
64E5-   C6 01       DEC   $01
64E7-   C6 01       DEC   $01
                                   ; read prodos file (blocks 8,A-26) ($3C00 bytes) @ $2000.$5BFF
64E9-   A0 00       LDY   #$00
64EB-   A9 20       LDA   #$20
64ED-   A2 00       LDX   #$00
64EF-   20 06 67    JSR   $6706

                                   ; do some patching to the ProDOS image
                                   ; don't display copyright screen
64F2-   A9 2C       LDA   #$2C
64F4-   8D 05 20    STA   $2005    ; 2005: BIT $FFFF

                                   ; break out of the boot process (somewhere)
                                   ; and run DazzleDraw instead
64F7-   A9 4C       LDA   #$4C
64F9-   8D 34 22    STA   $2234
64FC-   A0 16       LDY   #$16
64FE-   A9 65       LDA   #$65
6500-   8C 35 22    STY   $2235
6503-   8D 36 22    STA   $2236    ; 2234: JMP $6516

6506-   A0 18       LDY   #$18
6508-   A9 60       LDA   #$60
650A-   8C F0 55    STY   $55F0    ; 55F0: CLC
650D-   8D F1 55    STA   $55F1    ; 55F1: RTS

6510-   EE A4 23    INC   $23A4    ; some data from $5A to $5B ???





6513-   4C 00 20    JMP   $2000    ; init prodos
                                   ; relocates,
                                   ; loads slide.system???????
                                   ; and jmps here:





6516-   8D 82 C0    STA   $C082    ; r/w ROM, D000:2
6519-   EE F4 03    INC   $03F4    ; make reset reboot



651C-   20 7D 64    JSR   $647D    ; turn disk drive on

                                   ; remove any /RAM drive
651F-   A0 00       LDY   #$00
6521-   B9 32 BF    LDA   $BF32,Y
6524-   29 F0       AND   #$F0
6526-   C9 B0       CMP   #$B0
6528-   F0 0A       BEQ   $6534
652A-   C8          INY
652B-   CC 31 BF    CPY   $BF31
652E-   F0 F1       BEQ   $6521
6530-   90 EF       BCC   $6521
6532-   B0 1F       BCS   $6553    ; done checking, not found, continue with next routine
                                   ; remove /RAM drive from device list
6534-   B9 33 BF    LDA   $BF33,Y
6537-   99 32 BF    STA   $BF32,Y
653A-   C8          INY
653B-   CC 31 BF    CPY   $BF31
653E-   F0 F4       BEQ   $6534
6540-   90 F2       BCC   $6534
6542-   CE 31 BF    DEC   $BF31
6545-   AD 30 BF    LDA   $BF30
6548-   D0 09       BNE   $6553
654A-   AC 31 BF    LDY   $BF31
654D-   B9 32 BF    LDA   $BF32,Y
6550-   8D 30 BF    STA   $BF30    ; update DEVNUM (last device)






                                   ; read T$0B-T$10 to $6000.$BFFF aux
6553-   A9 0B       LDA   #$0B
6555-   8D 32 64    STA   $6432    ; track $0B (start of program)
6558-   20 79 64    JSR   $6479    ; read T$0B to $2000.$2FFF

655B-   AD C0 FB    LDA   $FBC0
655E-   D0 0C       BNE   $656C    ; br if IIe
6560-   4E 03 20    LSR   $2003    ; //c only: $2002.$2003 /= 2
6563-   6E 02 20    ROR   $2002
6566-   4E 05 20    LSR   $2005    ; $2004.$2005 /= 2
6569-   6E 04 20    ROR   $2004

656C-   A0 60       LDY   #$60
656E-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $6000.$6FFF aux

6571-   20 79 64    JSR   $6479    ; read T$0C to $2000.$2FFF
6574-   A0 70       LDY   #$70
6576-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $7000.$7FFF aux

6579-   20 79 64    JSR   $6479    ; read T$0D to $2000.$2FFF
657C-   A0 80       LDY   #$80
657E-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $8000.$8FFF aux

6581-   20 79 64    JSR   $6479    ; read T$0E to $2000.$2FFF
6584-   A0 90       LDY   #$90
6586-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $9000.$9FFF aux

6589-   20 79 64    JSR   $6479    ; read T$0F to $2000.$2FFF
658C-   A0 A0       LDY   #$A0
658E-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $A000.$AFFF aux

6591-   20 79 64    JSR   $6479    ; read T$10 to $2000.$2FFF
6594-   A0 B0       LDY   #$B0
6596-   20 56 64    JSR   $6456    ; copy $2000.$2FFF main to $B000.$BFFF aux





6599-   AD F3 66    LDA   $66F3    ; get input device (0=mouse, etc.)
659C-   0A          ASL
659D-   AA          TAX
659E-   BD D9 65    LDA   $65D9,X
65A1-   85 E0       STA   $E0
65A3-   BD DA 65    LDA   $65DA,X
65A6-   85 E1       STA   $E1      ; make ($E0)--> addr based on input device

65A8-   8D 05 C0    STA   $C005    ; write aux RAM
                                   ; copy $297 bytes from ($E0) to $B660.$B8F6 aux
65AB-   A0 00       LDY   #$00
65AD-   B1 E0       LDA   ($E0),Y
65AF-   99 60 B6    STA   $B660,Y
65B2-   C8          INY
65B3-   D0 F8       BNE   $65AD
65B5-   E6 E1       INC   $E1
65B7-   B1 E0       LDA   ($E0),Y
65B9-   99 60 B7    STA   $B760,Y
65BC-   C8          INY
65BD-   D0 F8       BNE   $65B7
65BF-   E6 E1       INC   $E1
65C1-   B1 E0       LDA   ($E0),Y
65C3-   99 60 B8    STA   $B860,Y
65C6-   C8          INY
65C7-   C0 97       CPY   #$97
65C9-   90 F6       BCC   $65C1
                                   ; copy settings (printer, card, printer slot) to $B8FD.$B8FF aux
65CB-   A2 02       LDX   #$02
65CD-   BD F0 66    LDA   $66F0,X
65D0-   9D FD B8    STA   $B8FD,X
65D3-   CA          DEX
65D4-   10 F7       BPL   $65CD
65D6-   4C E1 65    JMP   $65E1    ; skip table:
                                   ; table of addr to copy from based on input device
65D9-   00 28                      ; mouse    $2800
65DB-   90 2B                      ; koala    $2B90
65DD-   80 28                      ; tablet   $2880
65DF-   80 29                      ; joystick $2980

65E1-   8D 04 C0    STA   $C004    ; write main RAM






                                   ; read T$11-T$14, in special order, into main RAM:
                                   ; $0F00.$1FFF, $2300.$23FF, $8D00.BAFF
65E4-   20 4D 64    JSR   $644D    ; read T$11 into $0F00.$1EFF main
65E7-   0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E
65F7-   20 4D 64    JSR   $644D    ; read T$12 into $1F00.$1FFF, $8D00.$9BFF main
65FA-   1F 8D 8E 8F 90 91 92 93 94 95 96 97 89 99 9A 9B
660A-   20 4D 64    JSR   $644D    ; read T$13 into $9C00.$ABFF main
660D-   9C 9D 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB
661D-   20 4D 64    JSR   $644D    ; read T$14 into $AC00.$BAFF, $2300.$23FF
6620-   AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA 23
                                   ; copy $2300.$23CF to $0300.$03CF
6630-   A0 00       LDY   #$00
6632-   B9 00 23    LDA   $2300,Y
6635-   99 00 03    STA   $0300,Y
6638-   C8          INY
6639-   C0 D0       CPY   #$D0
663B-   90 F5       BCC   $6632
                                   ; IRQ-->$0300, RESET-->$0380
663D-   A0 80       LDY   #$80
663F-   8C F2 03    STY   $03F2
6642-   A0 00       LDY   #$00
6644-   A9 03       LDA   #$03
6646-   8C FE 03    STY   $03FE
6649-   8D FF 03    STA   $03FF
664C-   8D F3 03    STA   $03F3
664F-   49 A5       EOR   #$A5
6651-   8D F4 03    STA   $03F4

6654-   8D 09 C0    STA   $C009    ; use aux BSR
6657-   20 63 66    JSR   $6663    ; copy (tablet, mouse, inp dev) settings to $1A.$1C aux
665A-   8D 08 C0    STA   $C008    ; use main BSR
665D-   20 63 66    JSR   $6663    ; copy same to main
6660-   4C 73 66    JMP   $6673    ; skip the following routine:
                                   ; copy settings to $1A.$1C
6663-   AD F5 66    LDA   $66F5
6666-   85 1A       STA   $1A      ; tablet slot
6668-   AD F3 66    LDA   $66F3
666B-   85 1B       STA   $1B      ; current input device
666D-   AD F6 66    LDA   $66F6
6670-   85 1C       STA   $1C      ; mouse slot
6672-   60          RTS





6673-   20 79 64    JSR   $6479    ; read T$15 to $2000.$2FFF



6676-   18          CLC
6677-   AD F4 66    LDA   $66F4    ; file system (easy/pro)
667A-   69 16       ADC   #$16
667C-   8D 32 64    STA   $6432    ; easy=T$16 pro=T$17
667F-   A9 30       LDA   #$30
6681-   20 44 64    JSR   $6444    ; read T$16 or T$17 to $3000.$3FFF



6684-   A9 18       LDA   #$18
6686-   8D 32 64    STA   $6432    ; T$18
6689-   A9 40       LDA   #$40
668B-   20 44 64    JSR   $6444    ; read T$18 to $4000.$4FFF



668E-   A9 50       LDA   #$50
6690-   20 44 64    JSR   $6444    ; read T$19 to $5000.$5FFF





6693-   20 83 64    JSR   $6483    ; drive off
6696-   8D 09 C0    STA   $C009    ; use aux BSR

                                   ; set ($E0)--> $2000, ($E2)--> $D000 (aux)
6699-   A0 00       LDY   #$00
669B-   A9 20       LDA   #$20
669D-   84 E0       STY   $E0
669F-   85 E1       STA   $E1
66A1-   A9 D0       LDA   #$D0
66A3-   84 E2       STY   $E2
66A5-   85 E3       STA   $E3

66A7-   2C 8B C0    BIT   $C08B    ; R/W RAM, $D000 bank 1
66AA-   2C 8B C0    BIT   $C08B
66AD-   20 D1 66    JSR   $66D1    ; copy $2000.$2FFF (T$15) to aux $D000 bank 1
66B0-   A9 D0       LDA   #$D0
66B2-   85 E3       STA   $E3
66B4-   2C 83 C0    BIT   $C083    ; R/W RAM, $D000 bank 2
66B7-   2C 83 C0    BIT   $C083
66BA-   20 D1 66    JSR   $66D1    ; copy $3000.$3FFF (T$16 or T$17) to aux $D000 bank 2

66BD-   20 D1 66    JSR   $66D1    ; copy $4000.$4FFF (T$18) to aux $E000.$EFFF
66C0-   20 D1 66    JSR   $66D1    ; copy $5000.$5FFF (T$19) to aux $F000.$FFFF

                                   ; copy $6406.$6486 to $0900.$0980
                                   ; most of that code is not relocatable, so
                                   ; the only necessary part must be:
                                   ; $6406.$6431
66C3-   A0 80       LDY   #$80
66C5-   B9 06 64    LDA   $6406,Y
66C8-   99 00 09    STA   $0900,Y
66CB-   88          DEY
66CC-   10 F7       BPL   $66C5





66CE-   4C 00 70    JMP   $7000    ; BOOT PART 5 (inits, then runs DD)





                                   ; copy $1000 bytes from ($E0) to ($E2)
                                   ; input: ($E0),($E2), Y must be zero
66D1-   A2 10       LDX   #$10
66D3-   B1 E0       LDA   ($E0),Y
66D5-   91 E2       STA   ($E2),Y
66D7-   C8          INY
66D8-   D0 F9       BNE   $66D3
66DA-   E6 E1       INC   $E1
66DC-   E6 E3       INC   $E3
66DE-   CA          DEX
66DF-   D0 F2       BNE   $66D3
66E1-   60          RTS







66E2.66EF- 00




;*************************************
;   User Settings
;*************************************


66F0-   03                         ; current printer
66F1-   01                         ; current interface card (always 1 on //c)
66F2-   01                         ; current printer slot (always 1 on //c)
66F3-   01                         ; current input device (1=mouse...)
66F4-   02                         ; current file system (1=easy 2=pro)
66F5-   00                         ; slot # of tablet, or 0 if none found
66F6-   00                         ; slot # of mouse card, or 0 if none found




66F7.66FF- 00














6700-   4C 51 6B    JMP   $6B51    ; read track
6703-   4C ED 6A    JMP   $6AED    ; read track (into given page list)
6706-   4C 22 6B    JMP   $6B22    ; read track
6709-   4C E9 67    JMP   $67E9    ; move disk arm to track
670C-   4C 62 6B    JMP   $6B62


                                   ; standard error-exit
670F-   38          SEC
6710-   60          RTS

                                   ; read sector and store at ($56)
6711-   86 2B       STX   $2B
6713-   8A          TXA
6714-   09 8C       ORA   #$8C
6716-   8D 70 67    STA   $6770    ; self-mod code below (to correct disk slot for reads)
6719-   8D 87 67    STA   $6787
671C-   8D 9D 67    STA   $679D
671F-   8D B1 67    STA   $67B1
6722-   8D C6 67    STA   $67C6
6725-   A5 56       LDA   $56
6727-   A4 57       LDY   $57
6729-   8D C3 67    STA   $67C3    ; ******selfmod
672C-   8C C4 67    STY   $67C4
672F-   38          SEC
6730-   E9 54       SBC   #$54
6732-   B0 02       BCS   $6736
6734-   88          DEY
6735-   38          SEC
6736-   8D AB 67    STA   $67AB    ; ******selfmod
6739-   8C AC 67    STY   $67AC
673C-   E9 57       SBC   #$57
673E-   B0 01       BCS   $6741
6740-   88          DEY
6741-   8D 84 67    STA   $6784    ; ******selfmod
6744-   8C 85 67    STY   $6785
                                   ; read next sector's data
                                   ; (format ... D5 AA AD ($200 bytes) DE ...
6747-   A0 20       LDY   #$20
6749-   88          DEY
674A-   F0 C3       BEQ   $670F
                                   ; locate D5 AA AD
674C-   BD 8C C0    LDA   $C08C,X
674F-   10 FB       BPL   $674C
6751-   49 D5       EOR   #$D5
6753-   D0 F4       BNE   $6749
6755-   EA          NOP
6756-   BD 8C C0    LDA   $C08C,X
6759-   10 FB       BPL   $6756
675B-   C9 AA       CMP   #$AA
675D-   D0 F2       BNE   $6751
675F-   EA          NOP
6760-   BD 8C C0    LDA   $C08C,X
6763-   10 FB       BPL   $6760
6765-   C9 AD       CMP   #$AD
6767-   D0 E8       BNE   $6751
                                   ;
6769-   A0 AA       LDY   #$AA
676B-   A9 00       LDA   #$00

676D-   85 51       STA   $51
676F-   AE EC C0    LDX   $C0EC    ; wait for next byte
6772-   10 FB       BPL   $676F
6774-   BD 00 68    LDA   $6800,X
6777-   99 00 6C    STA   $6C00,Y
677A-   45 51       EOR   $51
677C-   C8          INY
677D-   D0 EE       BNE   $676D

677F-   A0 AA       LDY   #$AA
6781-   D0 03       BNE   $6786    ; branch always
6783-   99 55 41    STA   $4155,Y  ; ******selfmodded addr
6786-   AE EC C0    LDX   $C0EC    ; wait for next byte
6789-   10 FB       BPL   $6786
678B-   5D 00 68    EOR   $6800,X
678E-   BE 00 6C    LDX   $6C00,Y
6791-   5D 00 69    EOR   $6900,X
6794-   C8          INY
6795-   D0 EC       BNE   $6783
6797-   48          PHA
6798-   29 FC       AND   #$FC
679A-   A0 AA       LDY   #$AA
679C-   AE EC C0    LDX   $C0EC    ; wait for next byte
679F-   10 FB       BPL   $679C
67A1-   5D 00 68    EOR   $6800,X
67A4-   BE 00 6C    LDX   $6C00,Y
67A7-   5D 01 69    EOR   $6901,X
67AA-   99 AC 41    STA   $41AC,Y  ; ******selfmodded addr
67AD-   C8          INY
67AE-   D0 EC       BNE   $679C
67B0-   AE EC C0    LDX   $C0EC    ; wait for next byte
67B3-   10 FB       BPL   $67B0
67B5-   29 FC       AND   #$FC
67B7-   A0 AC       LDY   #$AC
67B9-   5D 00 68    EOR   $6800,X
67BC-   BE FE 6B    LDX   $6BFE,Y
67BF-   5D 02 69    EOR   $6902,X
67C2-   99 00 42    STA   $4200,Y  ; *******selfmodded addr
67C5-   AE EC C0    LDX   $C0EC    ; wait for next byte
67C8-   10 FB       BPL   $67C5
67CA-   C8          INY
67CB-   D0 EC       BNE   $67B9
67CD-   29 FC       AND   #$FC
67CF-   5D 00 68    EOR   $6800,X
67D2-   A6 2B       LDX   $2B
67D4-   A8          TAY
67D5-   D0 09       BNE   $67E0    ; error exit
                                   ; ensure ends with DE
67D7-   BD 8C C0    LDA   $C08C,X
67DA-   10 FB       BPL   $67D7
67DC-   C9 DE       CMP   #$DE
67DE-   F0 02       BEQ   $67E2    ; ok
67E0-   38          SEC            ; indicate error
67E1-   24 18       BIT   $18      ; doubled code, with:
;67E2-  18          CLC
67E3-   68          PLA
67E4-   A0 55       LDY   #$55
67E6-   91 56       STA   ($56),Y
67E8-   60          RTS

                                   ; move disk arm
                                   ; input: A = desired track
67E9-   0A          ASL            ; A << 1 (so A = halftrack number)
67EA-   85 5B       STA   $5B

67EC-   A5 FF       LDA   $FF
67EE-   85 5C       STA   $5C
67F0-   38          SEC
67F1-   E5 5B       SBC   $5B
67F3-   F0 29       BEQ   $681E    ; branch to return
67F5-   B0 04       BCS   $67FB
67F7-   E6 FF       INC   $FF
67F9-   90 02       BCC   $67FD
67FB-   C6 FF       DEC   $FF
67FD-   20 13 68    JSR   $6813    ; phase FF on
6800-   20 1F 68    JSR   $681F    ; delay

                                   ; phase 5C off
6803-   A5 5C       LDA   $5C
6805-   29 03       AND   #$03
6807-   0A          ASL
6808-   05 2B       ORA   $2B
680A-   A8          TAY
680B-   B9 80 C0    LDA   $C080,Y
680E-   20 1F 68    JSR   $681F    ; delay

6811-   F0 D9       BEQ   $67EC    ; branch always

                                   ; phase FF on
6813-   A5 FF       LDA   $FF
6815-   29 03       AND   #$03
6817-   0A          ASL
6818-   05 2B       ORA   $2B
681A-   A8          TAY
681B-   B9 81 C0    LDA   $C081,Y
681E-   60          RTS

681F-   A9 28       LDA   #$28
6821-   4C 16 6B    JMP   $6B16    ; delay and return


; return error
6824-   38          SEC
6825-   60          RTS



				;read next sector's address header into vars:
				;$55 = volume
				;$54 = track
				;$53 = sector
				;$52 = checksum
				;(same as DOS 3.3 RDADDR)
6826-   A0 FC       LDY   #$FC
6828-   84 5B       STY   $5B
682A-   C8          INY
682B-   D0 04       BNE   $6831
682D-   E6 5B       INC   $5B
682F-   F0 F3       BEQ   $6824    ; return error
6831-   BD 8C C0    LDA   $C08C,X
6834-   10 FB       BPL   $6831
6836-   C9 D5       CMP   #$D5
6838-   D0 F0       BNE   $682A
683A-   EA          NOP
683B-   BD 8C C0    LDA   $C08C,X
683E-   10 FB       BPL   $683B
6840-   C9 AA       CMP   #$AA
6842-   D0 F2       BNE   $6836
6844-   A0 03       LDY   #$03
6846-   BD 8C C0    LDA   $C08C,X
6849-   10 FB       BPL   $6846
684B-   C9 96       CMP   #$96
684D-   D0 E7       BNE   $6836
684F-   A9 00       LDA   #$00
6851-   85 5C       STA   $5C
6853-   BD 8C C0    LDA   $C08C,X
6856-   10 FB       BPL   $6853
6858-   2A          ROL
6859-   85 5B       STA   $5B
685B-   BD 8C C0    LDA   $C08C,X
685E-   10 FB       BPL   $685B
6860-   25 5B       AND   $5B
6862-   99 52 00    STA   $0052,Y
6865-   45 5C       EOR   $5C
6867-   88          DEY
6868-   10 E7       BPL   $6851
686A-   A8          TAY
686B-   D0 B7       BNE   $6824
686D-   BD 8C C0    LDA   $C08C,X
6870-   10 FB       BPL   $686D
6872-   C9 DE       CMP   #$DE
6874-   D0 AE       BNE   $6824 ; check for DE (only)
6876-   18          CLC
6877-   60          RTS


6878-   FF FF FF FF FF FF FF FF
; storage buffer for sector translations????????
6880-   00 00 00 00 00 00 00 00
6888-   00 00 00 00 00 00 00 00
6890-   00 00 00 00 00 00 00
6897-   04
6898-   98 99 08 0C 9C 10 14 18
68A0-   A0 A1 A2 A3 A4 A5 1C 20 A8 A9 AA 24 28 2C 30 34
68B0-   B0 B1 38 3C 40 44 48 4C B8 50 54 58 5C 60 64 68
68C0-   C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA 6C CC 70 74 78
68D0-   D0 D1 D2 7C D4 D5 80 84 D8 88 8C 90 94 98 9C A0
68E0-   E0 E1 E2 E3 E4 A4 A8 AC E8 B0 B4 B8 BC C0 C4 C8
68F0-   F0 F1 CC D0 D4 D8 DC E0 F8 E4 E8 EC F0 F4 F8 FC
6900-   00 00 00 96 02 00 00 97 01 00 00 9A 03 00 00 9B
	00 02 00 9D 02 02 00 9E 01 02 00 9F 03 02 00 A6
	00 01 00 A7 02 01 00 AB 01 01 00 AC 03 01 00 AD
	00 03 00 AE 02 03 00 AF 01 03 00 B2 03 03 00 B3
	00 00 02 B4 02 00 02 B5 01 00 02 B6 03 00 02 B7
	00 02 02 B9 02 02 02 BA 01 02 02 BB 03 02 02 BC
	00 01 02 BD 02 01 02 BE 01 01 02 BF 03 01 02 CB
	00 03 02 CD 02 03 02 CE 01 03 02 CF 03 03 02 D3
	00 00 01 D6 02 00 01 D7 01 00 01 D9 03 00 01 DA
	00 02 01 DB 02 02 01 DC 01 02 01 DD 03 02 01 DE
	00 01 01 DF 02 01 01 E5 01 01 01 E6 03 01 01 E7
	00 03 01 E9 02 03 01 EA 01 03 01 EB 03 03 01 EC
	00 00 03 ED 02 00 03 EE 01 00 03 EF 03 00 03 F2
	00 02 03 F3 02 02 03 F4 01 02 03 F5 03 02 03 F6
	00 01 03 F7 02 01 03 F9 01 01 03 FA 03 01 03 FB
	00 03 03 FC 02 03 03 FD 01 03 03 FE 03 03 03 FF

                                   ; input:
                                   ;   C A  track & sector: t tttttsss
                                   ;   $6AC9.$6AD8  table of dest pages
6A00-   48          PHA            ; save A
6A01-   29 07       AND   #$07     ; get sector (0-7 only???)
6A03-   8D 19 6A    STA   $6A19    ; self-mod**** sector
6A06-   68          PLA            ; restore A
6A07-   6A          ROR
6A08-   4A          LSR
6A09-   4A          LSR            ; A = track number
6A0A-   C5 5D       CMP   $5D      ; cmp w/dest track
6A0C-   F0 0A       BEQ   $6A18    ; br if arm is already at correct track
6A0E-   48          PHA            ; save A
6A0F-   20 33 6A    JSR   $6A33    ; move to correct track and read it
6A12-   20 9E 6A    JSR   $6A9E    ; zero out sector page map
6A15-   68          PLA            ; restore A
6A16-   85 5D       STA   $5D      ; update track number
                                   ; ???:
6A18-   A0 00       LDY   #$00     ; self-modded*** LDY #xx
6A1A-   BE B9 6A    LDX   $6AB9,Y
6A1D-   AD EA 6A    LDA   $6AEA    ; get page number?
6A20-   EE EA 6A    INC   $6AEA
6A23-   9D C9 6A    STA   $6AC9,X
6A26-   BE C1 6A    LDX   $6AC1,Y
6A29-   AD EA 6A    LDA   $6AEA
6A2C-   EE EA 6A    INC   $6AEA
6A2F-   9D C9 6A    STA   $6AC9,X
6A32-   60          RTS

                                   ; read one track & map it into memory
                                   ; input:
                                   ;   $6AC9.$6AD8  table of dest pages
                                   ;     $5D        desired track
                                   ;   $6AE9        ??? offset within page

                                   ; remap 6AC9 table at 6AD9 (sector order)
6A33-   A2 0F       LDX   #$0F
6A35-   BC A9 6A    LDY   $6AA9,X
6A38-   B9 C9 6A    LDA   $6AC9,Y
6A3B-   9D D9 6A    STA   $6AD9,X
6A3E-   CA          DEX
6A3F-   10 F4       BPL   $6A35

6A41-   A6 2B       LDX   $2B      ; slot
6A43-   A9 64       LDA   #$64
6A45-   85 58       STA   $58      ; number of retries
6A47-   D0 29       BNE   $6A72    ; br always (entry into loop)

6A49-   C6 58       DEC   $58      ; decr number of retries
6A4B-   F0 31       BEQ   $6A7E    ; tried too many times; error
6A4D-   20 26 68    JSR   $6826    ; read address header values into $52.$55
6A50-   B0 F7       BCS   $6A49    ; retry if error
6A52-   A5 54       LDA   $54      ; track
6A54-   C5 5D       CMP   $5D      ; desired track
6A56-   D0 39       BNE   $6A91    ; if on wrong track, move arm and retry
6A58-   A4 53       LDY   $53      ; sector
6A5A-   B9 D9 6A    LDA   $6AD9,Y
6A5D-   F0 EA       BEQ   $6A49
6A5F-   85 57       STA   $57
6A61-   AD E9 6A    LDA   $6AE9    ; ??? offset within page (constant zero)
6A64-   85 56       STA   $56
6A66-   20 11 67    JSR   $6711    ; read sector and store at $mm00, (mm from 6AD9 table)
6A69-   B0 DE       BCS   $6A49
6A6B-   A4 53       LDY   $53      ; sector
6A6D-   A9 00       LDA   #$00
6A6F-   99 D9 6A    STA   $6AD9,Y  ; zero-out entry in map to indicate we've read this sector
                                   ; loop through all sectors and see if any are left to be read
6A72-   A0 0F       LDY   #$0F
6A74-   B9 D9 6A    LDA   $6AD9,Y
6A77-   D0 D0       BNE   $6A49    ; found one we still haven't read
6A79-   88          DEY
6A7A-   10 F8       BPL   $6A74
                                   ; all done reading this track
6A7C-   18          CLC
6A7D-   60          RTS            ; good exit

                                   ; error reading sectors
6A7E-   38          SEC
6A7F-   EA          NOP
6A80-   A0 00       LDY   #$00
6A82-   AD 30 C0    LDA   $C030    ; beep
6A85-   98          TYA
6A86-   38          SEC
6A87-   E9 01       SBC   #$01
6A89-   D0 FB       BNE   $6A86
6A8B-   88          DEY
6A8C-   D0 F4       BNE   $6A82
6A8E-   4C 33 6A    JMP   $6A33    ; try again?

6A91-   A5 54       LDA   $54      ; track #
6A93-   0A          ASL            ; cvt to halftrack #
6A94-   85 FF       STA   $FF
6A96-   A5 5D       LDA   $5D      ; dest track
6A98-   20 E9 67    JSR   $67E9
6A9B-   4C 33 6A    JMP   $6A33

                                   ; zero out sector page map
6A9E-   A0 0F       LDY   #$0F
6AA0-   A9 00       LDA   #$00
6AA2-   99 C9 6A    STA   $6AC9,Y
6AA5-   88          DEY
6AA6-   10 FA       BPL   $6AA2
6AA8-   60          RTS

6AA9-   00 07 0E 06 0D 05 0C 04 0B 03 0A 02 09 01 08 0F
6AB9-   00 0D 0B 09 07 05 03 01 0E 0C 0A 08 06 04 02 0F
6AC9-   40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F ; dest pages
6AD9.6AEC- 00

6AED-   84 5D       STY   $5D      ; dest track
                                   ; set ($5B)--> table following JSR
6AEF-   68          PLA
6AF0-   85 5B       STA   $5B
6AF2-   68          PLA
6AF3-   85 5C       STA   $5C
                                   ; copy given table to 6AC9 table of dest pages
6AF5-   A2 00       LDX   #$00
6AF7-   20 0B 6B    JSR   $6B0B    ; A = next byte
6AFA-   9D C9 6A    STA   $6AC9,X
6AFD-   E8          INX
6AFE-   E0 10       CPX   #$10
6B00-   90 F5       BCC   $6AF7
                                   ; put new return address on stack
6B02-   A5 5C       LDA   $5C
6B04-   48          PHA
6B05-   A5 5B       LDA   $5B
6B07-   48          PHA
6B08-   4C 33 6A    JMP   $6A33    ; read track and return

                                   ; A = ($5B)++
6B0B-   E6 5B       INC   $5B
6B0D-   D0 02       BNE   $6B11
6B0F-   E6 5C       INC   $5C
6B11-   A0 00       LDY   #$00
6B13-   B1 5B       LDA   ($5B),Y
6B15-   60          RTS


                                   ; delay
6B16-   38          SEC
6B17-   48          PHA
6B18-   E9 01       SBC   #$01
6B1A-   D0 FC       BNE   $6B18
6B1C-   68          PLA
6B1D-   E9 01       SBC   #$01
6B1F-   D0 F6       BNE   $6B17
6B21-   60          RTS


                                   ; read track
                                   ; input:
                                   ;   $00.$01 table of t/s to read
                                   ;   Y  offset within page?
                                   ;   A  starting page???
                                   ;   X
6B22-   8C E9 6A    STY   $6AE9    ; offset within page?
6B25-   8D EA 6A    STA   $6AEA    ; starting page?
6B28-   8E EB 6A    STX   $6AEB
6B2B-   20 9E 6A    JSR   $6A9E    ; zero out sector page map
6B2E-   A0 00       LDY   #$00
6B30-   8C EC 6A    STY   $6AEC    ; local counter (from 0 upwards)

6B33-   AC EC 6A    LDY   $6AEC
6B36-   E6 01       INC   $01      ; next page?
6B38-   B1 00       LDA   ($00),Y  ; get byte
6B3A-   4A          LSR            ; store low bit in carry
6B3B-   C6 01       DEC   $01      ; curr page?
6B3D-   B1 00       LDA   ($00),Y  ; get byte
6B3F-   B0 02       BCS   $6B43    ; if low bit was set
6B41-   F0 0B       BEQ   $6B4E
6B43-   20 00 6A    JSR   $6A00
6B46-   EE EC 6A    INC   $6AEC
6B49-   CE EB 6A    DEC   $6AEB
6B4C-   D0 E5       BNE   $6B33

6B4E-   4C 33 6A    JMP   $6A33    ; read one track and return



                                   ; read track
                                   ; input:
                                   ;   A  page to read track into
                                   ;   Y  desired track
6B51-   84 5D       STY   $5D
6B53-   A0 00       LDY   #$00
6B55-   99 C9 6A    STA   $6AC9,Y
6B58-   18          CLC
6B59-   69 01       ADC   #$01
6B5B-   C8          INY
6B5C-   C0 10       CPY   #$10
6B5E-   90 F5       BCC   $6B55
6B60-   B0 EC       BCS   $6B4E ; JMP $6A33

6B62-   A2 60       LDX   #$60
6B64-   8E 7F 6A    STX   $6A7F
6B67-   20 51 6B    JSR   $6B51
6B6A-   A9 EA       LDA   #$EA
6B6C-   8D 7F 6A    STA   $6A7F
6B6F-   60          RTS

6B70.6BFF- 00

















;[FROM TRACKS: 20, 20.5, 21, 21.5]
;----begin---copied-to-$0800-M/A-and-kept-during-execution-of-program---------------------------
                                   ; BOOT PART 5
                                   ; relocate $7000.$70FF to $0800.$08FF
                                   ; (in both main and aux RAM)
7000-   A0 00       LDY   #$00
7002-   B9 00 70    LDA   $7000,Y
7005-   8D 05 C0    STA   $C005    ; write AUX RAM
7008-   99 00 08    STA   $0800,Y
700B-   8D 04 C0    STA   $C004    ; write main RAM
700E-   99 00 08    STA   $0800,Y
7011-   C8          INY
7012-   D0 EE       BNE   $7002
7014-   4C 17 08    JMP   $0817    ; continue running at new adddress

7017-   8D 05 C0    STA   $C005    ; write aux RAM
701A-   8D 03 C0    STA   $C003    ; read aux RAM
701D-   8D 01 C0    STA   $C001    ; 80STORE on (PAGE2 switches 1/1X)
7020-   8D 54 C0    STA   $C054    ; write page 1X
7023-   8D 5E C0    STA   $C05E    ; doublehires
7026-   8D 08 C0    STA   $C008    ; main BSR
7029-   20 99 08    JSR   $0899    ; JSR ($6000) (T$0B S$0 B$00.$01)
702C-   8D 09 C0    STA   $C009    ; aux BSR
702F-   20 99 08    JSR   $0899    ; JSR ($6000) (T$0B S$0 B$00.$01)
7032-   8D 00 C0    STA   $C000    ; 80STORE off (PAGE2 switches 1/2)
7035-   A2 40       LDX   #$40
7037-   8D 05 C0    STA   $C005    ; write aux ram
703A-   20 85 08    JSR   $0885    ; clear $2000.$5FFF aux
703D-   A2 6D       LDX   #$6D
703F-   8D 04 C0    STA   $C004
7042-   20 85 08    JSR   $0885    ; clear $2000.$8CFF main
7045-   8D 02 C0    STA   $C002    ; read main ram
7048-   8D 82 C0    STA   $C082    ; read ROM $D000 bank 2
704B-   AD C0 FB    LDA   $FBC0    ; 0=//c, other=IIe
704E-   48          PHA
704F-   8D 83 C0    STA   $C083    ; R/W RAM, $D000 bank 2
7052-   8D 83 C0    STA   $C083
7055-   BA          TSX
7056-   8E FC 3F    STX   $3FFC
7059-   AD 11 C0    LDA   $C011    ; is $D000 bank 2
705C-   8D FB 3F    STA   $3FFB
705F-   A9 45       LDA   #$45
7061-   48          PHA
7062-   28          PLP
7063-   A0 0C       LDY   #$0C
7065-   A9 60       LDA   #$60
7067-   8C ED 03    STY   $03ED
706A-   8D EE 03    STA   $03EE
706D-   AD 30 BF    LDA   $BF30
7070-   29 7F       AND   #$7F
7072-   8D 30 BF    STA   $BF30
7075-   A2 E3       LDX   #$E3
7077-   68          PLA
7078-   F0 02       BEQ   $707C
707A-   A2 E5       LDX   #$E5
707C-   AC 30 BF    LDY   $BF30
707F-   20 00 09    JSR   $0900
7082-   4C 14 C3    JMP   $C314    ; JMP $600C aux  DAZZLE DRAW PROGRAM ENTRY POINT



                                   ; clear X pages starting at $2000
7085-   A0 00       LDY   #$00
7087-   A9 20       LDA   #$20
7089-   84 00       STY   $00
708B-   85 01       STA   $01
708D-   98          TYA
708E-   91 00       STA   ($00),Y
7090-   C8          INY
7091-   D0 FB       BNE   $708E
7093-   E6 01       INC   $01
7095-   CA          DEX
7096-   D0 F6       BNE   $708E
7098-   60          RTS

7099-   6C 00 60    JMP   ($6000)

709C.70FF- 00
;----end---copied-to-$0800-M/A-and-kept-during-execution-of-program---------------------------
















7100-   4C A7 7B    JMP   $7BA7    ; display the "RETURN or ESC" screen and handle keypress
7103-   4C A7 7B    JMP   $7BA7    ; display the "RETURN or ESC" screen and handle keypress
7106-   4C 6D 73    JMP   $736D    ; search for mouse; if exists, init and check btn
7109-   4C 1D 73    JMP   $731D    ; check key press (return ascii in A)

                                   ; save setup
710C-   A9 F5       LDA   #$F5
710E-   85 00       STA   $00
7110-   A9 F4       LDA   #$F4
7112-   85 01       STA   $01
7114-   A9 F3       LDA   #$F3
7116-   85 02       STA   $02
7118-   A9 F2       LDA   #$F2
711A-   85 03       STA   $03

711C-   A2 0D       LDX   #$0D     ; # of pages
711E-   A9 04       LDA   #$04     ; page $04
7120-   20 27 71    JSR   $7127    ; write $0400.$10FF

7123-   A2 0C       LDX   #$0C     ; # of pages
7125-   A9 60       LDA   #$60     ; starting page
                                   ; write $6000.$6BFF

7127-   86 3C       STX   $3C
7129-   85 3B       STA   $3B
712B-   A0 00       LDY   #$00
712D-   84 3A       STY   $3A
712F-   A6 2B       LDX   $2B
7131-   BD 8D C0    LDA   $C08D,X  ; set to write mode; check write-protect
7134-   BD 8E C0    LDA   $C08E,X
7137-   10 02       BPL   $713B
7139-   38          SEC
713A-   60          RTS            ; error exit if write protected
                                   ; write 9 $FF's
713B-   A0 08       LDY   #$08
713D-   A9 FF       LDA   #$FF
713F-   9D 8F C0    STA   $C08F,X
7142-   1D 8C C0    ORA   $C08C,X
7145-   26 4E       ROL   $4E
7147-   EA          NOP
7148-   20 B9 71    JSR   $71B9    ; delay
714B-   20 B9 71    JSR   $71B9    ; delay
714E-   9D 8D C0    STA   $C08D,X
7151-   1D 8C C0    ORA   $C08C,X
7154-   88          DEY
7155-   D0 F0       BNE   $7147
                                   ; write F5 F4 F3 header
7157-   EA          NOP
7158-   A5 00       LDA   $00
715A-   20 AF 71    JSR   $71AF
715D-   A5 01       LDA   $01
715F-   20 AF 71    JSR   $71AF
7162-   A5 02       LDA   $02
7164-   20 AF 71    JSR   $71AF

7167-   EA          NOP
7168-   90 0C       BCC   $7176
716A-   98          TYA
716B-   D0 09       BNE   $7176

716D-   A5 03       LDA   $03      ; write F2 delimiter
716F-   EA          NOP
7170-   EA          NOP
7171-   20 B3 71    JSR   $71B3

7174-   26 4E       ROL   $4E
7176-   B1 3A       LDA   ($3A),Y  ; get byte to write
7178-   48          PHA
7179-   4A          LSR
717A-   09 AA       ORA   #$AA
717C-   9D 8D C0    STA   $C08D,X  ; write 1st encoded byte
717F-   DD 8C C0    CMP   $C08C,X
7182-   C8          INY
7183-   D0 07       BNE   $718C
7185-   E6 3B       INC   $3B
7187-   C6 3C       DEC   $3C
7189-   4C 8F 71    JMP   $718F
718C-   20 B9 71    JSR   $71B9    ; delay
718F-   68          PLA
7190-   09 AA       ORA   #$AA
7192-   9D 8D C0    STA   $C08D,X  ; write 2nd encoded byte
7195-   DD 8C C0    CMP   $C08C,X
7198-   A5 3C       LDA   $3C
719A-   D0 CE       BNE   $716A
719C-   A5 03       LDA   $03
719E-   A5 03       LDA   $03
71A0-   20 B0 71    JSR   $71B0
                                   ; write F2 trailer
71A3-   A5 03       LDA   $03
71A5-   20 AF 71    JSR   $71AF
                                   ; put back to read mode
71A8-   BD 8E C0    LDA   $C08E,X
71AB-   BD 8C C0    LDA   $C08C,X
71AE-   60          RTS
                                   ; write one byte (in A)
71AF-   18          CLC
71B0-   EA          NOP
71B1-   EA          NOP
71B2-   EA          NOP
71B3-   9D 8D C0    STA   $C08D,X
71B6-   1D 8C C0    ORA   $C08C,X
71B9-   60          RTS







;PRINTING routines*************************************
                                   ; print string
                                   ; input:
                                   ;   string after JSR
71BA-   68          PLA            ; pop return address and save it at $E0.$E1
71BB-   85 E0       STA   $E0
71BD-   68          PLA
71BE-   85 E1       STA   $E1
71C0-   20 19 72    JSR   $7219    ; X,A = byte from after JSR that called us
71C3-   20 CB 71    JSR   $71CB    ; output chracter (or return if done)
71C6-   4C C0 71    JMP   $71C0    ; repeat for next byte

71C9-   A9 8D       LDA   #$8D     ; \r

71CB-   10 13       BPL   $71E0    ; br if 0 <= byte < 80
                                   ; 80 <= byte < 100 do this:
71CD-   C9 A0       CMP   #$A0
71CF-   90 0A       BCC   $71DB    ; br if < A0
71D1-   24 32       BIT   $32
71D3-   30 06       BMI   $71DB
71D5-   C9 E0       CMP   #$E0     ; br if >= E0
71D7-   B0 02       BCS   $71DB
71D9-   29 3F       AND   #$3F     ; 00abcdef
71DB-   09 00       ORA   #$00
71DD-   4C F0 FD    JMP   $FDF0    ; COUT1 and return

                                   ; 0 <= byte < 80 do this:
                                   ; jump to routine from 71F1 table
                                   ; then return to caller
71E0-   C9 20       CMP   #$20
71E2-   D0 02       BNE   $71E6
71E4-   A9 11       LDA   #$11
71E6-   0A          ASL
71E7-   A8          TAY
71E8-   B9 F2 71    LDA   $71F2,Y
71EB-   48          PHA
71EC-   B9 F1 71    LDA   $71F1,Y
71EF-   48          PHA
71F0-   60          RTS

                                   ; address table
71F1-   31 72 ;  0 END OF STRING
        35 FB ;  1 INIT (but keep hires)
        57 FC ;  2 HOME
        3A 72 ;  3 NORMAL
        3D 72 ;  4 FLASH
        47 72 ;  5 MOUSETEXT?
        9B FC ;  6 CLREOL
        41 FC ;  7 CLREOP
        4D 72 ;  8 HTAB x
        54 72 ;  9 VTAB x
        5C 72 ;  A repeat char count
        E9 03 ;  B
        92 FE ;  C PR#0 etc.
        6B 72 ;  D POKE addr val
        74 72 ;  E
        76 72 ;  F
        C5 72 ; 10 STRING@ addr
        D3 72 ; 11 or 20 JSR addr
        EC 72 ; 12 WAITKEY char addr [...]
        AE 73 ; 13 BEEP

                                   ; X,A = ($E0)++
                                   ; input: $E0.$E1
7219-   A0 00       LDY   #$00
721B-   E6 E0       INC   $E0
721D-   D0 02       BNE   $7221
721F-   E6 E1       INC   $E1
7221-   B1 E0       LDA   ($E0),Y
7223-   AA          TAX
7224-   60          RTS

                                   ; $E2.$E3 = ($E0)++,++
                                   ; A = ($E2),Y
7225-   20 19 72    JSR   $7219
7228-   85 E2       STA   $E2
722A-   20 19 72    JSR   $7219
722D-   85 E3       STA   $E3
722F-   B1 E2       LDA   ($E2),Y
7231-   60          RTS
                                   ; 00 handler (END OF STRING)
7232-   68          PLA
7233-   68          PLA
7234-   A5 E1       LDA   $E1
7236-   48          PHA
7237-   A5 E0       LDA   $E0
7239-   48          PHA
723A-   60          RTS
                                   ; 03 handler (NORMAL)
723B-   A9 FF       LDA   #$FF     ; NORMAL
723D-   2C A9 7F    BIT   $7FA9    ; doubled code, with:
                                   ; 04 handler (FLASH)
;723E-  A9 7F       LDA   #$7F     ; FLASH
7240-   A0 00       LDY   #$00
7242-   85 32       STA   $32
7244-   8C DC 71    STY   $71DC    ; self-mod
7247-   60          RTS
                                   ; 05 handler (MOUSETEXT?)
7248-   A9 7F       LDA   #$7F
724A-   A0 40       LDY   #$40
724C-   D0 F4       BNE   $7242
                                   ; 08 handler (HTAB)
724E-   20 19 72    JSR   $7219    ; arg 1
7251-   CA          DEX
7252-   86 24       STX   $24
7254-   60          RTS
                                   ; 09 handler (VTAB)
7255-   20 19 72    JSR   $7219    ; arg 1
7258-   CA          DEX
7259-   8A          TXA
725A-   4C 5B FB    JMP   $FB5B
                                   ; 0A handler (repeat char)
                                   ; arg1 = char
                                   ; arg2 = repeat count
725D-   20 19 72    JSR   $7219    ; arg 1
7260-   48          PHA
7261-   20 19 72    JSR   $7219    ; arg 2
7264-   68          PLA            ; A = arg1, X = arg2
7265-   20 CD 71    JSR   $71CD    ; print A
7268-   CA          DEX
7269-   D0 FA       BNE   $7265    ; repeat X time
726B-   60          RTS
                                   ; 0D handler (POKE)
726C-   20 25 72    JSR   $7225    ; get arg1(addr) into $E2.$E3
726F-   20 19 72    JSR   $7219    ; arg 2
7272-   91 E2       STA   ($E2),Y
7274-   60          RTS
                                   ; 0E handler
7275-   38          SEC
7276-   24 18       BIT   $18      ; doubled code, with:
                                   ; 0F handler
;7277-  18          CLC
7278-   20 25 72    JSR   $7225    ; get arg1(addr) into $E2.$E3
727B-   B0 06       BCS   $7283
727D-   48          PHA
727E-   C8          INY
727F-   B1 E2       LDA   ($E2),Y
7281-   A8          TAY
7282-   68          PLA
7283-   85 E2       STA   $E2
7285-   84 E3       STY   $E3
7287-   A0 04       LDY   #$04
7289-   46 E5       LSR   $E5
728B-   A9 FF       LDA   #$FF
728D-   85 E4       STA   $E4
728F-   E6 E4       INC   $E4
7291-   38          SEC
7292-   A5 E2       LDA   $E2
7294-   F9 BC 72    SBC   $72BC,Y
7297-   AA          TAX
7298-   A5 E3       LDA   $E3
729A-   F9 C1 72    SBC   $72C1,Y
729D-   90 06       BCC   $72A5
729F-   86 E2       STX   $E2
72A1-   85 E3       STA   $E3
72A3-   B0 EA       BCS   $728F
72A5-   A5 E4       LDA   $E4
72A7-   88          DEY
72A8-   30 07       BMI   $72B1
72AA-   AA          TAX
72AB-   D0 04       BNE   $72B1
72AD-   24 E5       BIT   $E5
72AF-   10 07       BPL   $72B8
72B1-   09 B0       ORA   #$B0
72B3-   85 E5       STA   $E5
72B5-   20 CD 71    JSR   $71CD    ; print char
72B8-   98          TYA
72B9-   10 D0       BPL   $728B
72BB-   60          RTS

72BC-   01 0A       ORA   ($0A,X)
72BE-   64 E8       STZ   $E8
72C0-   10 00       BPL   $72C2
72C2-   00          BRK
72C3-   00          BRK
72C4-   03          ???
72C5-   27          ???
                                   ; 10 handler (STRING @)
72C6-   20 25 72    JSR   $7225    ; get address arg1
72C9-   B1 E2       LDA   ($E2),Y
72CB-   F0 06       BEQ   $72D3
72CD-   20 CD 71    JSR   $71CD    ; print char
72D0-   C8          INY
72D1-   D0 F6       BNE   $72C9
72D3-   60          RTS
                                   ; 11 and 20 handler (JSR)
72D4-   20 25 72    JSR   $7225    ; get address arg1
72D7-   A5 E0       LDA   $E0      ; save $E0.$E1
72D9-   48          PHA
72DA-   A5 E1       LDA   $E1
72DC-   48          PHA
72DD-   20 E7 72    JSR   $72E7    ; JSR addr
72E0-   68          PLA            ; restore $E0.$E1
72E1-   85 E1       STA   $E1
72E3-   68          PLA
72E4-   85 E0       STA   $E0
72E6-   60          RTS
72E7-   6C E2 00    JMP   ($00E2)

72EA-   20 AF 73    JSR   $73AF    ; BEEP
                                   ; 12 handler (WAITKEY)
72ED-   20 0E 73    JSR   $730E    ; wait for key press
72F0-   85 E4       STA   $E4
72F2-   A0 01       LDY   #$01
72F4-   B1 E0       LDA   ($E0),Y  ; peek at next arg
72F6-   F0 F2       BEQ   $72EA

72F8-   C5 E4       CMP   $E4
72FA-   08          PHP
72FB-   C8          INY
72FC-   B1 E0       LDA   ($E0),Y
72FE-   85 E2       STA   $E2
7300-   C8          INY
7301-   B1 E0       LDA   ($E0),Y
7303-   85 E3       STA   $E3
7305-   C8          INY
7306-   28          PLP
7307-   D0 EB       BNE   $72F4
7309-   68          PLA
730A-   68          PLA
730B-   6C E2 00    JMP   ($00E2)

                                   ; wait for key press
730E-   20 1D 73    JSR   $731D
7311-   10 FB       BPL   $730E
7313-   2C 10 C0    BIT   $C010
7316-   C9 E0       CMP   #$E0
7318-   90 02       BCC   $731C
731A-   29 DF       AND   #$DF
731C-   60          RTS


;end PRINTING routines*************************************







;MOUSE handling*******************************************************

                                   ; get key press, if any
                                   ; output:
                                   ;   A  ascii value of key pressed
                                   ;      0 if none pressed
                                   ;      (mouse button press yields $8D)
                                   ; in/out:
                                   ;      $5B  apple button pressed status
                                   ;           (not sure how it works)
                                   ;
                                   ;
                                   ;
                                   ; b equ $5B
                                   ; assume b is false
                                   ;
                                   ; if key pressed
                                   ;     return ascii value
                                   ; else
                                   ;     loop1:
                                   ;     if either apple button pressed
                                   ;         if (b)
                                   ;             goto loop1
                                   ;         else
                                   ;             b = true
                                   ;         end if
                                   ;     end if
                                   ;     b = false
                                   ;     if no mouse, return 0
                                   ;     do
                                   ;     {
                                   ;         set mouse vblint
                                   ;         read mouse x,y
                                   ;         set mouse active
                                   ;     }
                                   ;     while mouse button down
                                   ;     if mouse button not pressed
                                   ;         return 0
                                   ;     else
                                   ;         return '\r'
                                   ;     end if
                                   ; end if
731D-   AD 00 C0    LDA   $C000    ; key pressed?
7320-   30 2F       BMI   $7351    ; if yes, return ascii value

7322-   AD 61 C0    LDA   $C061    ; either apple btn pressed?
7325-   0D 62 C0    ORA   $C062
7328-   10 08       BPL   $7332    ; branch if not pressed
                                   ; btn was pressed:
732A-   24 5B       BIT   $5B      ; check btn-pressed state from last time
732C-   30 F4       BMI   $7322    ; br if was pressed (wait for btn to be released)
732E-   85 5B       STA   $5B      ; turn on high on
7330-   10 1D       BPL   $734F    ; ??? branch never taken ???

7332-   46 5B       LSR   $5B      ; clear btn-pressed state
7334-   AD 46 7B    LDA   $7B46    ; mouse slot
7337-   F0 18       BEQ   $7351    ; if no mouse, return 0

7339-   20 53 73    JSR   $7353    ; if have mouse then set vblint on movement
733C-   A0 14       LDY   #$14
733E-   20 5A 73    JSR   $735A    ; read mouse x-y position
7341-   20 56 73    JSR   $7356    ; set mouse active
7344-   AC 46 7B    LDY   $7B46    ; mouse slot #
7347-   B9 78 07    LDA   $0778,Y  ; mouse status byte
734A-   0A          ASL
734B-   30 EC       BMI   $7339    ; br if btn down and still down
734D-   90 02       BCC   $7351    ; br if btn not pressed

734F-   A9 8D       LDA   #$8D     ; "\r"
7351-   78          SEI
7352-   60          RTS


7353-   A9 01       LDA   #$01     ; set mouse mode: vbl interrupt on movement

7355-   2C A9 00    BIT   $00A9    ; doubled code, with:
;7356-  A9 00       LDA   #$00     ; set mouse mode: active

7358-   A0 12       LDY   #$12     ; set mouse mode to accum:



                                   ; call mouse routine # Y
735A-   48          PHA            ; save A
735B-   B9 00 C4    LDA   $C400,Y  ; *** (self-moded, to mouse slot) get init lo byte
735E-   AE 5D 73    LDX   $735D    ; slot addr hi byte
7361-   A4 5A       LDY   $5A      ; ?
7363-   8D 6B 73    STA   $736B
7366-   8E 6C 73    STX   $736C    ; self mod to initialization entry point
7369-   68          PLA            ; restore A
736A-   4C 5A 73    JMP   $735A    ; init card (*** self-modded), and return





                                   ; search for mouse
                                   ; (BOOT3 routine $6400 calls this)
                                   ; if exists, init and check for button press (no wait)
736D-   46 5B       LSR   $5B      ; clear high bit of $5B (apple button pressed status)
736F-   20 DB 7A    JSR   $7ADB    ; search for known input devices
7372-   AD 46 7B    LDA   $7B46
7375-   D0 01       BNE   $7378
7377-   60          RTS            ; if no mouse card, then just return

7378-   09 C0       ORA   #$C0     ; turn slot # into addr (e.g., 4 becomes $C4)
737A-   8D 5D 73    STA   $735D    ; self-mod*** with mouse slot

737D-   0A          ASL
737E-   0A          ASL
737F-   0A          ASL
7380-   0A          ASL
7381-   85 5A       STA   $5A      ; store slot0000 (e.g. $40) (input to $735A fn)

                                   ; initialize mouse
7383-   A0 19       LDY   #$19     ; offset in card of init routine offset
                                   ; (e.g., $C419 contains $1C, meaning we
                                   ; need to JSR $C41C to init the mouse)
7385-   20 5A 73    JSR   $735A    ; init mouse
7388-   20 53 73    JSR   $7353    ; mouse: vbl interrupt on movement
738B-   A0 15       LDY   #$15
738D-   20 5A 73    JSR   $735A    ; set mouse to position 0

7390-   20 1D 73    JSR   $731D    ; get key press, if any

7393-   20 56 73    JSR   $7356    ; set mouse mode active
7396-   78          SEI
7397-   60          RTS


;end MOUSE handling*******************************************************





;some PRINTING routines*******************************************************


                                   ; print 27 dashes and a cr
7398-   20 BA 71    JSR   $71BA    ; print
739B-   0A AD 27                   ; 27 "-"
        8D                         ; "\r"
739F-   00          BRK
73A0-   60          RTS

73A1-   A0 18       LDY   #$18
73A3-   AD 30 C0    LDA   $C030
73A6-   A9 0B       LDA   #$0B
73A8-   20 A8 FC    JSR   $FCA8
73AB-   88          DEY
73AC-   D0 F5       BNE   $73A3
73AE-   60          RTS
                                   ; 13 handler (BEEP)
73AF-   A0 20       LDY   #$20
73B1-   A9 02       LDA   #$02
73B3-   20 A8 FC    JSR   $FCA8    ; delay
73B6-   8D 30 C0    STA   $C030    ; click
73B9-   A9 24       LDA   #$24
73BB-   20 A8 FC    JSR   $FCA8    ; delay
73BE-   8D 30 C0    STA   $C030
73C1-   88          DEY
73C2-   D0 ED       BNE   $73B1
73C4-   60          RTS


                                   ; print "press RETURN", wait for it, and HOME
73C5-   20 BA 71    JSR   $71BA    ; print string:
73C8-   13 13                      ; BEEP BEEP
                                   ; "\r\r\rPress RETURN to continue"
73CA-   8D 8D 8D D0 F2 E5 F3 F3 A0 D2 C5 D4 D5 D2 CE A0 F4 EF A0 E3 EF EE F4 E9 EE F5 E5
73E5-   05 A0 03                   ; cursor
73E8-   12                         ; wait for keypress and jump
        8D ED 73                   ; RETURN: JMP $73ED
73EC-   00                         ; end of string to print

73ED-   4C 58 FC    JMP   $FC58    ; HOME

;end some PRINTING routines*******************************************************





;DISK DRIVE routines****************************************************************
                                   ; turn on disk drive and delay
73F0-   A6 2B       LDX   $2B
73F2-   BD 89 C0    LDA   $C089,X
73F5-   A9 00       LDA   #$00
73F7-   4C A8 FC    JMP   $FCA8    ; delay and return

                                   ; turn off disk drive
73FA-   A6 2B       LDX   $2B
73FC-   BD 88 C0    LDA   $C088,X
73FF-   60          RTS

7400-   20 F0 73    JSR   $73F0    ; turn on disk drive
7403-   A9 1F       LDA   #$1F
7405-   20 09 67    JSR   $6709    ; move arm to track $1F
7408-   A9 60       LDA   #$60
740A-   85 50       STA   $50
740C-   A0 00       LDY   #$00
740E-   A6 2B       LDX   $2B
7410-   88          DEY
7411-   D0 06       BNE   $7419
7413-   C6 50       DEC   $50
7415-   D0 02       BNE   $7419
7417-   38          SEC            ; error exit
7418-   60          RTS
7419-   BD 8C C0    LDA   $C08C,X
741C-   10 FB       BPL   $7419
741E-   C9 F5       CMP   #$F5
7420-   D0 EE       BNE   $7410
7422-   BD 8C C0    LDA   $C08C,X
7425-   10 FB       BPL   $7422
7427-   C9 F4       CMP   #$F4
7429-   D0 F3       BNE   $741E
742B-   BD 8C C0    LDA   $C08C,X
742E-   10 FB       BPL   $742B
7430-   C9 F3       CMP   #$F3
7432-   D0 F3       BNE   $7427
7434-   18          CLC            ; good exit
7435-   60          RTS
;end DISK DRIVE routines****************************************************************





;Utility Menu (1-5)********************************************************************************************
                                   ; display 1-5 Utilities menu and handle key press
7436-   20 BA 71    JSR   $71BA    ; print:
7439-   01                         ; INIT
        02                         ; HOME
        03                         ; NORMAL
743C-   20 98 73    JSR   $7398    ; 27 dashes \r
743F-   0A A0 06                   ; 6 spaces
                                   ; "Dazzle Draw (TM)  Utilities\r"
7442-   C4 E1 FA FA EC E5 A0 C4 F2 E1 F7 A0 A8 D4 CD A9 A0 A0 D5 F4 E9 EC E9 F4 E9 E5 F3 8D
745E-   20 98 73    JSR   $7398    ; 27 dashes \r
7461-   0D 22 00 03                ; POKE 34,3 (set screen top to line 3)
7465-   00          BRK            ; end of print

7466-   38          SEC
7467-   66 5C       ROR   $5C      ; set high bit of $5C dirty flag???

7469-   20 BA 71    JSR   $71BA    ; print:
746C-   02                         ; HOME
746D-   03                         ; NORMAL
746E-   09 07                      ; VTAB 7
                                   ; utility menu text (1-5)
7470-   B1 A0 AD A0 D3 E5 EC E5 E3 F4 A0 C9 EE F0 F5 F4 A0 C4 E5 F6 E9 E3 E5 8D 8D B2 A0 AD A0 D3 E5 EC E5
        E3 F4 A0 C6 E9 EC E5 A0 D3 F9 F3 F4 E5 ED 8D 8D B3 A0 AD A0 D0 F2 E9 EE F4 E5 F2 A0 D3 E5 F4 F5 F0
        8D 8D B4 A0 AD A0 CD E1 EB E5 A0 E2 E1 E3 EB F5 F0 A0 E3 EF F0 F9 A0 EF E6 A0 C4 E1 FA FA EC E5 A0
        C4 F2 E1 F7 8D 8D B5 A0 AD A0 C5 F8 E9 F4 A0 D5 F4 E9 EC E9 F4 F9 AF D3 E1 F6 E5 A0 D3 E5 F4 F5 F0
        8D 8D 8D 8D D3 E5 EC E5 E3 F4 E9 EF EE A0 BF A0 ; ..."Selection ?  "
        05 A0 03                   ; FLASH space NORMAL (cursor)

        12                         ; wait for key and jump:
        B1 56 76                   ; "1": $7656 Select input device
        B2 BA 76                   ; "2": $76BA Select file system
        B3 C2 76                   ; "3": $76C2 Set up printer
        B4 18 75                   ; "4": $7518 Make backup copy
        B5 5F 75                   ; "5": $755F Save and quit
        00
;end Utility Menu (1-5)********************************************************************************************


                                   ; check for/make backup
7518-   AD 00 62    LDA   $6200
751B-   F0 03       BEQ   $7520
751D-   4C 00 40    JMP   $4000    ; make backup and return

7520-   20 BA 71    JSR   $71BA    ; print:
7523-   02                         ; HOME
7524-   09 09                      ; VTAB 9
                                   ; "This disk has already been used\r\rto make a backup."
        D4 E8 E9 F3 A0 E4 E9 F3 EB A0 E8 E1 F3 A0 E1 EC F2 E5
        E1 E4 F9 A0 E2 E5 E5 EE A0 F5 F3 E5 E4 8D 8D F4 EF A0
        ED E1 EB E5 A0 E1 A0 E2 E1 E3 EB F5 F0 AE
7558-   00                         ; end of print
7559-   20 C5 73    JSR   $73C5    ; print "press RETURN", wait for it, and HOME
755C-   4C A7 7B    JMP   $7BA7    ; back to "RETURN or ESC" screen



                                   ; user selected Save and quit from the menu
755F-   A2 00       LDX   #$00
7561-   8E 4B 7B    STX   $7B4B    ; self-mod***
7564-   20 BA 71    JSR   $71BA    ; print:
7567-   02                         ; HOME
7568-   8D 8D 8D                   ; "\r\r\r"
756B-   20 4A 7B    JSR   $7B4A    ; display current values of all settings
                                   ; "Would you like to save this\rsetup to disk ? (Y/N) "
756E-   8D D7 EF F5 EC E4 A0 F9 EF F5 A0 EC E9 EB E5 A0 F4 EF A0 F3 E1 F6 E5 A0 F4
7587-   E8 E9 F3 8D F3 E5 F4 F5 F0 A0 F4 EF A0 E4 E9 F3 EB A0 BF A0 A8 D9 AF CE A9 A0
75A1-   05 A0 03                   ; cursor
                                   ; "\r\rpress ESC for Utility Menu"
75A4-   8D 8D F0 F2 E5 F3 F3 A0 C5 D3 C3 A0 E6 EF F2 A0 D5 F4 E9 EC E9 F4 F9 A0 CD E5 EE F5
        12                         ; wait for key and jump:
75C1-   9B 36 74                   ; ESC: $7436 back to main utility menu
75C4-   D9 CB 75                   ; "Y": $75CB
75C7-   CE A7 7B                   ; "N": $7BA7 back to RETURN or ESC page
75CA-   00

                                   ; Yes, save the setup
75CB-   20 BA 71    JSR   $71BA    ; print string
75CE-   02                         ; HOME
75CF-   09 09                      ; VTAB 9
75D1-   00                         ; end print

75D2-   20 00 74    JSR   $7400    ; make sure DD disk is in drive
75D5-   90 2C       BCC   $7603    ; if it is, branch to "save" routine
75D7-   20 BA 71    JSR   $71BA    ; print
                                   ; "Please insert the Dazzle Draw disk..."
75DA-   D0 EC E5 E1 F3 E5 A0 E9 EE F3 E5 F2 F4 A0 F4 E8 E5 A0 C4 E1 FA FA EC E5 A0 C4 F2 E1 F7 A0 E4 E9 F3 EB AE AE AE
75FF-   00
7600-   4C 4D 76    JMP   $764D    ; wait for RETURN


7603-   20 0C 71    JSR   $710C    ; "save" setup to dazzle draw disk (track 1F)
7606-   20 FA 73    JSR   $73FA    ; turn off disk drive
7609-   B0 03       BCS   $760E    ; br if disk is write protected
760B-   4C A7 7B    JMP   $7BA7    ; back to "RETURN or ESC" screen

760E-   20 BA 71    JSR   $71BA    ; print
                                   ; "Please remove write protect tab"...
7611-   D0 EC E5 E1 F3 E5 A0 F2 E5 ED EF F6 E5 A0 F7 F2 E9 F4 E5 A0 F0 F2 EF F4 E5 E3 F4
762C-   A0 F4 E1 E2 A0 E6 F2 EF ED 8D 8D F4 E8 E5 A0 C4 E1 FA FA EC E5 A0 C4 F2 E1 F7 A0 E4
7648-   E9 F3 EB AE 00

764D-   20 FA 73    JSR   $73FA    ; turn off disk drive
7650-   20 C5 73    JSR   $73C5    ; print "press RETURN", wait for it, and HOME
7653-   4C 64 75    JMP   $7564    ; go to "would you like to save"



                                   ; let user select input device
7656-   20 5C 76    JSR   $765C
7659-   4C 66 74    JMP   $7466    ; go back to main utility menu (1-5)

765C-   A9 03       LDA   #$03
765E-   20 E9 76    JSR   $76E9    ; display input device menu and update $66F0 table
7661-   08          PHP
7662-   20 DB 7A    JSR   $7ADB    ; search for known input devices
7665-   28          PLP
7666-   AE F3 66    LDX   $66F3
7669-   BD 45 7B    LDA   $7B45,X  ; check table of found cards
766C-   F0 01       BEQ   $766F    ; if card not found, branch
766E-   60          RTS            ; if card was found, then OK, return

766F-   20 BA 71    JSR   $71BA    ; print string
7672-   02                         ; HOME
7673-   09 0A                      ; VTAB 10
                                   ; "The "
7675-   D4 E8 E5 A0
7679-   20 7B 7B    JSR   $7B7B
                                   ; "\r\r isn't connected.\r\rPlease select another input device."
767C-   8D 8D E9 F3 EE A7 F4 A0 E3 EF EE EE E5 E3 F4 E5 E4 AE 8D 8D D0 EC E5 E1 F3 E5 A0 F3 E5 EC
        E5 E3 F4 A0 E1 EE EF F4 E8 E5 F2 A0 E9 EE F0 F5 F4 A0 E4 E5 F6 E9 E3 E5 AE 00

76B4-   20 C5 73    JSR   $73C5    ; print "press RETURN", wait for it, and HOME
76B7-   4C 5C 76    JMP   $765C    ; check slots and return





                                   ; let user select file system
76BA-   A9 04       LDA   #$04
76BC-   20 E9 76    JSR   $76E9
76BF-   4C 66 74    JMP   $7466    ; go back to main utility menu (1-5)



                                   ; let user set up printer
76C2-   A9 00       LDA   #$00
76C4-   20 E9 76    JSR   $76E9    ; display printer menu and update $66F0 table
76C7-   B0 1D       BCS   $76E6    ; br if error, exit
76C9-   AD C0 FB    LDA   $FBC0
76CC-   D0 0A       BNE   $76D8
76CE-   A9 01       LDA   #$01     ; for a //c, use:
76D0-   8D F1 66    STA   $66F1    ;     interface card #1 (Apple Super Serial)
76D3-   8D F2 66    STA   $66F2    ;     printer slot #1
76D6-   D0 0E       BNE   $76E6    ;     br always
                                   ; for a IIe:
76D8-   A9 01       LDA   #$01
76DA-   20 E9 76    JSR   $76E9    ; display interface card menu and update $66F0 table
76DD-   B0 E3       BCS   $76C2    ; repeatif error
76DF-   A9 02       LDA   #$02
76E1-   20 E9 76    JSR   $76E9    ; display printer slot menu and update $66F0 table
76E4-   B0 F2       BCS   $76D8    ; repeat if error
76E6-   4C 66 74    JMP   $7466    ; go back to main utility menu (1-5)



                                   ; input:
                                   ;   A  setting number (3=input dev, 4=file sys, tec.)
                                   ; output:
                                   ;   $66F0 table updated with new setting
76E9-   8D 0F C0    STA   $C00F    ; mousetext on
76EC-   85 53       STA   $53
76EE-   AA          TAX
76EF-   BC F0 66    LDY   $66F0,X
76F2-   84 59       STY   $59      ; $59 = the setting's current value
76F4-   0A          ASL
76F5-   AA          TAX            ; times 2
76F6-   86 56       STX   $56      ; save it for later
76F8-   BD 1D 78    LDA   $781D,X  ; name of setting ("Input Device", "Printer", etc.)
76FB-   8D 11 77    STA   $7711    ; modify string below***
76FE-   BD 1E 78    LDA   $781E,X
7701-   8D 12 77    STA   $7712

7704-   20 BA 71    JSR   $71BA    ; display string:
7707-   02                         ; HOME
7708-   04                         ; FLASH
        D3 C5 CC C5 C3 D4 A0       ; "SELECT "
        10
7711-   FF FF                      ; gets modified by **** above to the
7713-   BA                         ; ":"
7714-   03                         ; NORMAL
7715-   8D 00
                                   ; print menu of choices for setting's value
7717-   A6 56       LDX   $56      ; restore X from above
7719-   BD 09 78    LDA   $7809,X
771C-   85 50       STA   $50
771E-   BD 0A 78    LDA   $780A,X
7721-   85 51       STA   $51      ; ($50)-->table of strings
                                   ; calc vert and horiz position of menu on screen
7723-   BD 13 78    LDA   $7813,X
7726-   20 5B FB    JSR   $FB5B    ; VTAB
7729-   38          SEC
772A-   A9 28       LDA   #$28
772C-   FD 14 78    SBC   $7814,X
772F-   4A          LSR
7730-   38          SEC
7731-   E9 02       SBC   #$02
7733-   85 54       STA   $54
7735-   BD 14 78    LDA   $7814,X
7738-   18          CLC
7739-   69 02       ADC   #$02
773B-   85 55       STA   $55
                                   ; print menu
773D-   A9 01       LDA   #$01
773F-   85 52       STA   $52
7741-   A9 FF       LDA   #$FF
7743-   A4 52       LDY   $52
7745-   C4 59       CPY   $59      ; is this the currently selected one?
7747-   D0 01       BNE   $774A
7749-   4A          LSR            ; if so, then inverse
774A-   85 32       STA   $32

774C-   A5 54       LDA   $54
774E-   85 24       STA   $24
7750-   A5 52       LDA   $52
7752-   18          CLC
7753-   69 B0       ADC   #$B0
7755-   C9 BA       CMP   #$BA
7757-   90 02       BCC   $775B
7759-   69 06       ADC   #$06
775B-   8D 6E 7A    STA   $7A6E
775E-   20 CD 71    JSR   $71CD    ; print the number
7761-   A9 AE       LDA   #$AE
7763-   20 CD 71    JSR   $71CD    ; print the period
7766-   A6 55       LDX   $55
7768-   20 F8 77    JSR   $77F8    ; A = ($50)++ get next char from string table
776B-   48          PHA
776C-   09 80       ORA   #$80
776E-   20 CD 71    JSR   $71CD    ; print char
7771-   CA          DEX
7772-   68          PLA
7773-   30 F3       BMI   $7768    ; print the rest of the string
                                   ; print spaces
7775-   20 4A F9    JSR   $F94A
7778-   20 C9 71    JSR   $71C9
777B-   E6 52       INC   $52
777D-   A0 00       LDY   #$00
777F-   B1 50       LDA   ($50),Y
7781-   D0 BE       BNE   $7741    ; print rest of menu

7783-   20 3B 72    JSR   $723B    ; NORMAL
7786-   20 53 7A    JSR   $7A53    ; print  "Use arraow keys.. Press RETURN... "
7789-   C6 52       DEC   $52
778B-   D0 03       BNE   $7790
778D-   20 AF 73    JSR   $73AF    ; BEEP
7790-   20 0E 73    JSR   $730E    ; wait for key press
7793-   C9 9B       CMP   #$9B
7795-   F0 21       BEQ   $77B8    ; br if ESC
7797-   A6 59       LDX   $59
7799-   20 C4 77    JSR   $77C4    ; if user made valid selection 1-n, we don't return to here
                                   ; check for arrow keys
779C-   C9 88       CMP   #$88
779E-   F0 43       BEQ   $77E3    ; move up one
77A0-   C9 8B       CMP   #$8B
77A2-   F0 3F       BEQ   $77E3    ; move up one
77A4-   C9 95       CMP   #$95
77A6-   F0 42       BEQ   $77EA    ; move down one
77A8-   C9 8A       CMP   #$8A
77AA-   F0 3E       BEQ   $77EA    ; move down one

77AC-   C9 8D       CMP   #$8D
77AE-   D0 DD       BNE   $778D    ; if not RETURN, go back to beep and wait for next key press
77B0-   A5 59       LDA   $59      ; current menu selection
77B2-   A6 53       LDX   $53
77B4-   9D F0 66    STA   $66F0,X  ; update selection in settings table
77B7-   18          CLC
77B8-   08          PHP
77B9-   20 58 FC    JSR   $FC58    ; HOME
77BC-   8D 0E C0    STA   $C00E    ; mousetext off
77BF-   38          SEC
77C0-   66 5C       ROR   $5C      ; set high bit of $5C
77C2-   28          PLP
77C3-   60          RTS



                                   ; input:
                                   ;   A  "1", "2", ...
77C4-   8D E1 77    STA   $77E1    ; self-mod (save accum)
77C7-   C9 BA       CMP   #$BA
77C9-   90 02       BCC   $77CD
77CB-   E9 07       SBC   #$07
77CD-   38          SEC
77CE-   E9 B0       SBC   #$B0     ; now A is 1, 2, ...
77D0-   C9 01       CMP   #$01
77D2-   90 0C       BCC   $77E0    ; if less than 1, return
77D4-   C5 52       CMP   $52
77D6-   F0 02       BEQ   $77DA
77D8-   B0 06       BCS   $77E0    ; if >n, return
77DA-   AA          TAX            ; user made a good selection, put it in X
77DB-   68          PLA            ; remove return address from stack
77DC-   68          PLA
77DD-   4C F3 77    JMP   $77F3
77E0-   A9 00       LDA   #$00     ; self-modded (restore accum)
77E2-   60          RTS

77E3-   CA          DEX            ; move menu up one
77E4-   D0 0D       BNE   $77F3
77E6-   A6 52       LDX   $52
77E8-   D0 09       BNE   $77F3

77EA-   E8          INX            ; move menu down one
77EB-   E4 52       CPX   $52
77ED-   F0 04       BEQ   $77F3
77EF-   90 02       BCC   $77F3
77F1-   A2 01       LDX   #$01

77F3-   86 59       STX   $59      ; store user's menu selection 1-n at $59
77F5-   4C 17 77    JMP   $7717    ; go back to redraw the menu



                                   ; A = ($50)++
77F8-   84 58       STY   $58      ; save Y
77FA-   A0 00       LDY   #$00
77FC-   B1 50       LDA   ($50),Y
77FE-   E6 50       INC   $50
7800-   D0 02       BNE   $7804
7802-   E6 51       INC   $51
7804-   A4 58       LDY   $58     ; restore Y
7806-   29 FF       AND   #$FF
7808-   60          RTS

                                   ; table of addresses of string tables
7809-   64 78                      ; 0: table of printer names
        37 79                      ; 1: table of interface card names
        E8 79                      ; 2: table of "Slot x" names
        0D 7A                      ; 3: table of input device names
        38 7A                      ; 4: table of filing system names (easy/pro)
                                   ; table of VTAB, maxwidth of strings
7813-   05 1E
        05 17
        08 0F
        0A 15
        0A 14

                                   ; string table for types of settings
781D-   27 78                      ; 0: "PRINTER"
        2F 78                      ; 1: "INTERFACE CARD"
        3E 78                      ; 2: "PRINTER SLOT"
        4B 78                      ; 3: "INPUT DEVICE"
        58 78                      ; 4: "FILE SYSTEM"

7827-   D0 D2 C9 CE D4 C5 D2 00
782F-   C9 CE D4 C5 D2 C6 C1 C3 C5 A0 C3 C1 D2 C4 00
783E-   D0 D2 C9 CE D4 C5 D2 A0 D3 CC CF D4 00
784B-   C9 CE D0 D5 D4 A0 C4 C5 D6 C9 C3 C5 00
7858-   C6 C9 CC C5 A0 D3 D9 D3 D4 C5 CD 00

;"APPLE Scribe w/color ribbon"
7864-   C1 D0 D0 CC C5 A0 D3 E3 F2 E9 E2 E5 A0 F7 AF E3 EF EC EF F2 A0 F2 E9 E2 E2 EF 6E
787F-   C1 D0 D0 CC C5 A0 D3 E3 F2 E9 E2 E5 A0 F7 AF E2 EC E1 E3 EB A0 F2 E9 E2 E2 EF 6E
        C1 D0 D0 CC C5 A0 C9 ED E1 E7 E5 F7 F2 E9 F4 E5 F2 A0 EF F2 A0 C4 CD 50
        C3 AD C9 F4 EF E8 A0 A8 D0 F2 EF F7 F2 E9 F4 E5 F2 A9 AC A0 CE C5 C3 A0 B8 B0 B2 33
        C5 F0 F3 EF EE A0 CA F8 AD B8 B0 A0 F7 AF E3 EF EC EF F2 A0 F2 E9 E2 E2 EF 6E
78E8-   C5 F0 F3 EF EE A0 C6 F8 AF D2 F8 AF CA F8 AD A0 A8 B8 B0 A0 EF F2 A0 B1 B0 B0 29
7903-   C5 F0 F3 EF EE A0 CD F8 AD B8 B0 A0 EF F2 A0 CD F8 AD B1 B0 30
7918-   C7 E5 ED E9 EE E9 AD B1 B0 F8 AC A0 AD B1 B5 F8 AC A0 C4 E5 EC F4 E1 AC A0 D2 E1 E4 E9 78
        00

;"Apple Super Serial"...
7937-   C1 D0 D0 CC C5 A0 D3 F5 F0 E5 F2 A0 D3 E5 F2 E9 E1 6C
7949-   C5 F0 F3 EF EE A0 C1 D0 4C
7952-   CF F2 E1 EE E7 E5 AC A0 C7 F2 E1 F0 F0 EC E5 72
7962-   C7 F2 E1 F0 F0 EC E5 F2 2B
796B-   C1 D0 D0 CC C5 A0 C9 C9 A0 D0 E1 F2 E1 EC EC E5 6C
797C-   D6 E9 E4 E5 F8 A0 D5 EE E9 F0 F2 E9 EE 74
798A-   D0 CB C1 D3 4F
798F-   D3 F4 E1 F2 A0 CD E9 E3 F2 EF EE E9 E3 F3 A0 C7 F2 E1 E6 F3 F4 E1 72
79A6-   CD E9 E3 F2 EF F4 E5 EB A0 C4 F5 ED F0 EC E9 EE E7 A0 C7 58
79BA-   CD E9 E3 F2 EF F4 E5 EB A0 C4 F5 ED F0 EC E9 EE E7 A0 B6 34
79CE-   CD E9 E3 F2 EF F4 E5 EB A0 D2 D6 AD B6 B1 B1 43
79DE-   C8 E1 F0 F0 E9 E3 E1 F2 64
        00

;"Slot 1" - "Slot 7"
79E8-   D3 EC EF F4 A0 31
79EE-   D3 EC EF F4 A0 32
79F4-   D3 EC EF F4 A0 34
79FA-   D3 EC EF F4 A0 35
7A00-   D3 EC EF F4 A0 36
7A06-   D3 EC EF F4 A0 37
7A0C-   00

;"Mouse" "KoalaPad" "Apple Graphics Tablet" "Joystick"
7A0D-   CD EF F5 F3 65
7A12-   CB EF E1 EC E1 D0 E1 64
7A1A-   C1 F0 F0 EC E5 A0 C7 F2 E1 F0 E8 E9 E3 F3 A0 D4 E1 E2 EC E5 74
7A2F-   CA EF F9 F3 F4 E9 E3 6B
7A37-   00

;"Easy File" "Professional File"
7A38-   C5 E1 F3 F9 A0 C6 E9 EC 65
7A41-   D0 F2 EF E6 E5 F3 F3 E9 EF EE E1 EC A0 C6 E9 EC 65
7A52-   00



7A53-   20 BA 71    JSR   $71BA    ; print "Use arrow keys..."
7A56-   09 14                      ; VTAB 9
7A58-   8D
7A59-   20 98 73    JSR   $7398
7A5C-   D5 F3 E5 A0
7A60-   20 BB 7A    JSR   $7ABB    ; "arrow" or " J K "
7A63-   A0 EB E5 F9 F3 A0 EF F2 A0 B1 AD D8 A0 F4 EF A0 ED E1 EB E5 A0 F3 E5 EC E5 E3 F4 E9 EF EE 8D
7A82-   08 09
;"Press RETURN to accept"
7A84-   D0 F2 E5 F3 F3 A0 D2 C5 D4 D5 D2 CE A0 F4 EF A0 E1 E3 E3 E5 F0 F4 8D
7A9B-   00
7A9C-   24 5C       BIT   $5C
7A9E-   10 1A       BPL   $7ABA
7AA0-   20 BA 71    JSR   $71BA
7AA3-   08 0A
;"Press ESC to go back"
7AA5-   D0 F2 E5 F3 F3 A0 C5 D3 C3 A0 F4 EF A0 E7 EF A0 E2 E1 E3 EB
7AB9-   00
7ABA-   60          RTS
                                   ; print "arrow" or " J K " depending on machine type
7ABB-   2C C0 FB    BIT   $FBC0    ; br on machine type
7ABE-   10 0A       BPL   $7ACA
7AC0-   20 BA 71    JSR   $71BA    ; print:
7AC3-   E1 F2 F2 EF F7             ; "arrow"
7AC8-   00                         ; end print
7AC9-   60          RTS
                                   ; print " J K "
7ACA-   A0 04       LDY   #$04
7ACC-   B9 D6 7A    LDA   $7AD6,Y
7ACF-   20 CD 71    JSR   $71CD    ; print char
7AD2-   88          DEY
7AD3-   10 F7       BPL   $7ACC
7AD5-   60          RTS
7AD6-   A0 4B A0 4A A0             ; " J K " backwards





;SLOT searching*********************************************************
                                   ; search for known input devices
                                   ; (mouse, tablet, koalapad/joystick)

                                   ; search slots mouse card and Apple Graphics Tablet,
                                   ; (but for koalapad/joystick, the only thing we can
                                   ; confirm is that if they pushed one of those buttons
                                   ; already, then one of those is connected?????)
                                   ; output:
                                   ;   $7B46.$7B49
7ADB-   A2 00       LDX   #$00     ; refer to 2 pairs in 7B3A table
7ADD-   20 10 7B    JSR   $7B10    ; search slots
7AE0-   8D 46 7B    STA   $7B46
                                   ; search slots for tablet
7AE3-   A2 05       LDX   #$05     ; refer to 3 pairs in 7B3F table
7AE5-   20 10 7B    JSR   $7B10    ; search slots
7AE8-   8D 48 7B    STA   $7B48

7AEB-   20 F5 7A    JSR   $7AF5    ; chk analog inputs (w/ timeout)
7AEE-   8D 49 7B    STA   $7B49    ; save results (0=not, FF=pressed)
7AF1-   8D 47 7B    STA   $7B47

7AF4-   60          RTS

                                   ; check analog inputs (w/ timeout)
                                   ; output:
                                   ;   A  0 no press; FF pressed
7AF5-   A0 00       LDY   #$00
7AF7-   A2 10       LDX   #$10
7AF9-   AD 70 C0    LDA   $C070
7AFC-   AD 64 C0    LDA   $C064    ; is btn 0 pressed
7AFF-   0D 65 C0    ORA   $C065    ; or btn 1 pressed
7B02-   10 09       BPL   $7B0D    ; br if either btn pressed
7B04-   88          DEY
7B05-   D0 F5       BNE   $7AFC
7B07-   CA          DEX
7B08-   D0 F2       BNE   $7AFC
7B0A-   A9 00       LDA   #$00     ; no btn pressed within time limit, so return 0
7B0C-   2C A9 FF    BIT   $FFA9    ; doubled code with:
;7B0D-  A9 FF       LDA   #$FF     ; btn pressed, so return -1
7B0F-   60          RTS

                                   ; search slots for some kind of card???
7B10-   8E 1C 7B    STX   $7B1C    ; self-mod ***

7B13-   A0 00       LDY   #$00     ; ($50)-->$C700
7B15-   A9 C7       LDA   #$C7
7B17-   84 50       STY   $50
7B19-   85 51       STA   $51
                                   ; loop thru slots, from $C700 to $C100
7B1B-   A2 00       LDX   #$00     ; ***
7B1D-   BC 3A 7B    LDY   $7B3A,X  ; first byte in this pair into Y
7B20-   F0 13       BEQ   $7B35    ; br if no more pairs to check
7B22-   BD 3B 7B    LDA   $7B3B,X  ; second byte in this pair into A
7B25-   D1 50       CMP   ($50),Y  ; see if offset Y in slot is A
7B27-   D0 04       BNE   $7B2D    ; if no match, br to try prev slot
7B29-   E8          INX
7B2A-   E8          INX
7B2B-   D0 F0       BNE   $7B1D    ; br always to check next pair in table
                                   ; starting with the same slot we just found
                                   ; and continuing down to slot 1

7B2D-   C6 51       DEC   $51      ; decr to previous slot
7B2F-   A5 51       LDA   $51
7B31-   C9 C1       CMP   #$C1
7B33-   B0 E6       BCS   $7B1B    ; end of loop

7B35-   A5 51       LDA   $51
7B37-   29 0F       AND   #$0F     ; convert $C1-$C7 to actual slot # ($01-$07)
7B39-   60          RTS

;       offval  offval  offval
;       Y  A    Y  A    Y  A
7B3A-   0C 20   FB D6   00         ; mouse card signature
7B3F-   02 38   05 78   06 2C   00 ; signature for tablet

                                   ; slots of found cards, or 0 if not found
7B46-   00                         ; mouse
7B47-   00                         ; KoalaPad
7B48-   00                         ; Apple Graphics Tablet
7B49-   00                         ; Joystick
;end SLOT searching*********************************************************








                                   ; display all current settings on screen
7B4A-   A2 00       LDX   #$00     ; 7B4B gets modified***
7B4C-   86 52       STX   $52
7B4E-   8A          TXA
7B4F-   0A          ASL
7B50-   AA          TAX
7B51-   BD 1D 78    LDA   $781D,X
7B54-   8D 62 7B    STA   $7B62
7B57-   BD 1E 78    LDA   $781E,X
7B5A-   8D 63 7B    STA   $7B63    ; self-mod to string address of current setting
7B5D-   20 BA 71    JSR   $71BA    ; print string:
7B60-   04                         ; FLASH
        10 FF FF                   ; 7B62,7B63 gets modified to current setting string addr
7B64-   BA                         ; ":"
7B65-   03                         ; NORMAL
7B66-   A0                         ; " "
        00                         ; end of print string

7B68-   A6 52       LDX   $52
7B6A-   20 80 7B    JSR   $7B80    ; name of current setting
7B6D-   20 C9 71    JSR   $71C9    ; \r
7B70-   20 C9 71    JSR   $71C9    ; \r
7B73-   A6 52       LDX   $52
7B75-   E8          INX
7B76-   E0 05       CPX   #$05
7B78-   90 D2       BCC   $7B4C
7B7A-   60          RTS



                                   ; display name of current input device
7B7B-   A2 03       LDX   #$03
7B7D-   2C A2 04    BIT   $04A2    ; doubled code, with:
                                   ; display name of current file system (easy/pro)
;7B7E-  A2 04       LDX   #$04

                                   ; X = which setting (3=input dev, 4=filing sys)
7B80-   BC F0 66    LDY   $66F0,X  ; current value of setting (1-n)
                                   ; ($50)--> table of names for the setting
7B83-   8A          TXA
7B84-   0A          ASL
7B85-   AA          TAX
7B86-   BD 09 78    LDA   $7809,X
7B89-   85 50       STA   $50
7B8B-   BD 0A 78    LDA   $780A,X
7B8E-   85 51       STA   $51
                                   ; skip past names until we find ours
7B90-   88          DEY
7B91-   F0 07       BEQ   $7B9A    ; br if we have found the correct name

7B93-   20 F8 77    JSR   $77F8    ; A = ($50)++ get next char from string
7B96-   30 FB       BMI   $7B93    ; move to end of this name
7B98-   10 F6       BPL   $7B90    ; br always to check next name

7B9A-   20 F8 77    JSR   $77F8    ; A = ($50)++ get next char from string
7B9D-   48          PHA
7B9E-   09 80       ORA   #$80     ; turn high bit on (only affects last char in string)
7BA0-   20 CD 71    JSR   $71CD    ; print char
7BA3-   68          PLA
7BA4-   30 F4       BMI   $7B9A    ; loop if we're not at the end (last char in string has high bit clear)

7BA6-   60          RTS



                                   ; JMP $7100 comes here:


                                   ; display the "RETURN or ESC" screen and handle keypress
7BA7-   8D 0E C0    STA   $C00E    ; primary char set
7BAA-   20 BA 71    JSR   $71BA    ; print:
7BAD-   01                         ; INIT
        02                         ; HOME
        03                         ; NORMAL
        20 98 73    JSR   $7398    ; 27 dashes \r
        08 0C                      ; HTAB 12
                                   ; "Dazzle Draw  (TM)\r"
        C4 E1 FA FA EC E5 A0 C4 F2 E1 F7 A0 A0 A8 D4 CD A9 8D
        08 0D                      ; HTAB 13
                                   ; "by David Snyder\r"
        E2 F9 A0 C4 E1 F6 E9 E4 A0 D3 EE E9 E4 E5 F2 8D
        08 0B                      ; HTAB 11
                                   ; "Copyright (C)  1984\r"
        C3 EF F0 F9 F2 E9 E7 E8 F4 A0 A8 C3 A9 A0 A0 B1 B9 B8 B4 8D
        08 0B                      ; HTAB 11
                                   ; "Broderbund Software\r"
        C2 F2 EF E4 E5 F2 E2 F5 EE E4 A0 D3 EF E6 F4 F7 E1 F2 E5 8D
        20 98 73    JSR   $7398    ; 27 dashes \r
        0D 22 00 07                ; POKE $22,7 (set screen top row to 7)
        20 F8 7C    JSR   $7CF8    ; check for "/" or ESC keypress (don't wait)
        20 D7 7C    JSR   $7CD7    ; check for input device and printer, set if needed
        20 61 76    JSR   $7661
        02                         ; HOME
        09 0A                      ; VTAB 10
        08 04                      ; HTAB 4
                                   ; "Input Device: "
        C9 EE F0 F5 F4 A0 C4 E5 F6 E9 E3 E5 BA A0
        20 7B 7B    JSR   $7B7B    ; display name of current input device
        09 0C                      ; VTAB 12
        08 05                      ; HTAB 5
                                   ; "File System: "
        C6 E9 EC E5 A0 D3 F9 F3 F4 E5 ED BA A0
        20 7E 7B    JSR   $7B7E    ; display name of current file system (easy/pro)
        09 11                      ; VTAB 17
        08 07                      ; HTAB 7
                                   ; "Press RETURN "... "press ESC" ... "backup "
7C43-   D0 F2 E5 F3 F3 A0 D2 C5 D4 D5 D2 CE A0 F4 EF A0 E7 EF 8D 08 07 E4 E9 F2 E5 E3 F4 EC F9 A0
7C61-   F4 EF A0 C4 E1 FA FA EC E5 A0 C4 F2 E1 F7 AC A0 EF F2 8D 8D 08 07 F0 F2 E5 F3 F3 A0 C5 D3
7C7F-   C3 A0 E6 EF F2 A0 D5 F4 E9 EC E9 F4 F9 A0 CD E5 EE F5 8D 08 07 EF F2 A0 F4 EF A0 ED E1 EB
7C9D-   E5 A0
7C9F-   E2 E1 E3 EB F5 F0 A0
        05 A0 03                   ; flashing space (cursor)
7CA9-   8D 8D 8D                   ; "\r\r\r"
7CAC-   0A AD 27                   ; 27 dashes
        12                         ; wait for key and jump:
7CB0-   8D B7 7C                   ; RETURN $7CB7 go below:
7CB3-   9B 36 74                   ; ESC    $7436 go to main utility menu
7CB6-   00




                                   ; (user press RETURN "run DD" comes here)
                                   ; ensure we've got the latest values for
                                   ; the mouse and tablet slots
7CB7-   AD 48 7B    LDA   $7B48
7CBA-   8D F5 66    STA   $66F5
7CBD-   AD 46 7B    LDA   $7B46
7CC0-   8D F6 66    STA   $66F6
                                   ; decr $66F0.$66F4 (change settings from 1-origin to 0-origin)
7CC3-   A2 04       LDX   #$04
7CC5-   DE F0 66    DEC   $66F0,X
7CC8-   CA          DEX
7CC9-   10 FA       BPL   $7CC5

7CCB-   20 BA 71    JSR   $71BA    ; print:
7CCE-   01 02 00                   ; INIT HOME
7CD1-   A2 FF       LDX   #$FF     ; clear out the stack
7CD3-   9A          TXS
7CD4-   4C 03 64    JMP   $6403    ; skip splash and util menu... go run program







7CD7-   AD F3 66    LDA   $66F3    ; input device setting (1=mouse, etc.)
7CDA-   30 01       BMI   $7CDD
7CDC-   60          RTS
7CDD-   A9 01       LDA   #$01
7CDF-   8D F3 66    STA   $66F3    ; set to "use mouse for input"
7CE2-   46 5C       LSR   $5C
7CE4-   20 5C 76    JSR   $765C
7CE7-   B0 F9       BCS   $7CE2
7CE9-   A9 04       LDA   #$04
7CEB-   20 E9 76    JSR   $76E9
7CEE-   B0 F2       BCS   $7CE2
7CF0-   A2 03       LDX   #$03
7CF2-   8E 4B 7B    STX   $7B4B    ; self-mod***
7CF5-   4C 64 75    JMP   $7564    ; go to "would you like to save"

                                   ; check for keypress (from splash screen) (don't wait)
                                   ; "/" causes DD to launch
                                   ; ESC causes backup routine to run
7CF8-   AD 00 C0    LDA   $C000
7CFB-   C9 AF       CMP   #$AF     ; "/"
7CFD-   F0 0B       BEQ   $7D0A
7CFF-   2C 10 C0    BIT   $C010
7D02-   C9 9B       CMP   #$9B     ; ESC
7D04-   F0 01       BEQ   $7D07
7D06-   60          RTS            ; otherwise, just return
7D07-   4C 18 75    JMP   $7518    ; ESC: jmp to backup routine
                                   ; "/": launch DD program:
7D0A-   A9 04       LDA   #$04
7D0C-   8D F3 66    STA   $66F3
7D0F-   4C B7 7C    JMP   $7CB7

7D12.7FFF- 00
