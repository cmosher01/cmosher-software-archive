                                ;
                                ;
                                ; Apple ][ DOS 3
                                ;
                                ;
                                ;
                                ; This is a 6502 assembly source file to build the
                                ; Apple ][ Disk Operating System.
                                ;
                                ; This file is intended for Frank A. Kingswood's AS65
                                ; assembler. It can be assembled with a command line such as:
                                ;
                                ; as65-dos -c -h0 -i -l -m -n -t -v -w -z -x -DDOS31 -odos33.obj dos33.a65
                                ;
                                ; This file can build any of the following versions of Apple ][ DOS,
                                ; by defining the corresponding label:
                                ;
                                ; version       release date   label
                                ; DOS 3.0       1978-06        DOS30 (not yet implemented)
                                ; DOS 3.1       1978-07-20     DOS31
                                ; DOS 3.2       1979-06-01     DOS32
                                ; DOS 3.2.1     1979-07-31     DOS321 (not yet implemented)
                                ; DOS 3.3 (0)   1980-08-25     DOS33_1980
                                ; DOS 3.3 (1)   1983-01-01     DOS33_1983
                                ; DOS 3.3 (2)   1986-03?       DOS33_1986
                                ; Franklin Ace  ?              FRANKLIN
                                ;
                                ;
                                ;
                                ;
                                ;
                                ; There were (at least) 3 different versions of
                                ; DOS 3.3.
                                ; This is from the Apple ][ FAQ at
                                ; http://home.swbell.net/rubywand/
                                ; under Csa2DOSMM, question 17
                                ; -----------------------------------------------------------
                                ; From: Edhel Iaur, Esq.
                                ;
                                ; 017- How many 'official' versions of DOS 3.3 are there
                                ; and how can I tell which is running?
                                ;
                                ; According to The Dostalk Scrapbook, there are 3 official (as in Apple made
                                ; 'em, I think) versions of DOS 3.3.  PEEK (46725) supposedly tells you which is
                                ; running:
                                ;
                                ; 165: oldest  (1980)
                                ; 186: better  (January 1, 1983)
                                ; 182: latest  (?)
                                ;
                                ; I remember one had something to do with the way text files are handled.
                                ;
                                ; ---------------------
                                ;
                                ; From: Dave Althoff
                                ;
                                ; The second version would be the IIe release ("DOS 3.3e") which contains yet another
                                ; APPEND patch, and an additional bit of code which shuts off the 80-column
                                ; firmware during boot. That version comes on a new System Master which uses the
                                ; LOADER.OBJ0 program to fast-load INTBASIC (or FPBASIC), and a revised "HELLO"
                                ; program which displays the "BE SURE CAPS LOCK IS DOWN" reminder on a IIe.
                                ;
                                ; ---------------------
                                ;
                                ; From: Rubywand and Olcott
                                ;
                                ; One big problem with DOS 3.3e is that it uses some memory in the DOS area which
                                ; the 1980 release leaves alone. This means it can not be safely patched with Beagle's
                                ; "Prontodos" speed-up mods.
                                ;
                                ; With the newer DOS,  you get an APPEND patch (which turns out to introduce a new
                                ; APPEND bug),  a few IIe display frills, and a DOS which is _much_ slower than the 1980
                                ; DOS 3.3 patched for Prontodos.
                                ; -----------------------------------------------------------
                                ;
                                ;
                                ;
                                ; Chris Mosher's observations:
                                ; Location $B685 is in the boot sector, T$00, S$00,
                                ; and is the high byte of the address of a JMP instruction.
                                ; Values are as follows
                                ; From the first part, values in hex:
                                ; 1980: $A5
                                ; 1983: $BA
                                ; 1986: $B6
                                ;
                                ; According to the above list, then, this source code
                                ; would be for the last version, shown as "latest" or "1986".
                                ; This is consistent with the fact that I found a disk
                                ; image documented as being the "last" version of DOS 3.3,
                                ; never officially released but available through some
                                ; Nibble magazine #47, in 1986. On that boot
                                ; image, the JMP instruction jumps to $36B3, the high
                                ; order byte being $36, which upon load is fixedup to $B6.
                                ; Here are the relevant lines from the assembly listing files:
                                ;                IF DOS33_1986
                                ; 3683: 4cb336       JMP RSETPTRS
                                ;                ELSE
                                ;                IF DOS33_1983
                                ; 3683: 4c843a       JMP CMPATCH
                                ;                ELSE
                                ;                IF DOS33_1980
                                ; 3683: 4c4625       JMP BK2APND
                                ;                ENDIF
                                ;                ENDIF
                                ;                ENDIF
                                ;
                                ;
                                ;
                IF FRANKLIN
DOS33_1980      = 1
                ENDIF

                IF DOS31+DOS32+DOS33_1980+DOS33_1983+DOS33_1986 != 1
ERROR: Must define DOS version to build.
                ENDIF




                                ; --------------------------------
                                ; ZERO-PAGE ADDRESSES
                                ; --------------------------------

CH              = $24           ; OFFSET FROM LEFT EDGE OF WINDOW
                                ; TO NEXT CHR POS'N ON SCRN LINE.
                                ; (RANGE:  $00-$23.)
PT2BTBUF        = $26           ; PTR ($26,$27) TO TARGET BUF USED
                                ; WHEN READING IN DOS DURING BOOT.
HOLDNIBL        = $26           ; TEMP REG USED FOR HOLDING TWO-
                                ; ENCODED NIBBLES WHEN WRITING
                                ; A SECTOR DURING RWTS'S FORMAT OR
                                ; WRITE OPERATIONS.
PROSCRTH        = $26           ; TEMP REG USED FOR:
                                ; - DECODING ODD/EVEN ADDR FIELD
                                ; BYTES.
                                ; - CNTR AND INDEX TO RWTS BUFFERS
                                ; (1 & 2) WHEN POSTNIBBLING.
                                ; - CNTR FOR # OF CHANCES TO FIND
                                ; THE CORRECT ADDR PROLOGUE.
STPSDONE        = $26           ; - CNTR FOR # OF HALFTRKS MOVED.
                                ; - CURRENT DISTANCE (EXPRESSED IN
                                ; HALFTRACKS) FROM THE START OR
                                ; DESTINATION HALFTRACK POS'NS.
FRMTSLOT        = $27           ; SLOT * 16 USED TO INDEX DRIVE
                                ; BASE ADDRESSES.
HOLDPRES        = $27           ; HOLDS CURRENT HALFTRACK POSITION
                                ; WHEN SEEKING.
CKSUMCAL        = $27           ; RUNNING CHKSUM CALCULATION USED
                                ; WHEN READING ODD-EVEN ENCODED
                                ; ADDRESS FIELD BYTES.
BASL            = $28           ; PTR ($28,$29) TO THE LEFT END OF
                                ; THE SCREEN LINE.
DESTRK          = $2A           ; DESTINATION HALFTRACK POS'N WHEN
                                ; SEEKING.
SLT16ZPG        = $2B           ; SLOT*16 USED TO INDEX DRIVE
                                ; FUNCTIONS.
CKSUMDSK        = $2C           ; DECODED CHECKUSM VAL READ FROM
                                ; ADDR FIELD (RWTS).
SECDSK          = $2D           ; PHYS SEC # FOUND IN ADDR FIELD.
TRKDSK          = $2E           ; TRK # FOUND IN ADDR FIELD.
VOLDSK          = $2F           ; VOL # FOUND IN ADDR FIELD.
PROMPT          = $33           ; PROMPT CHAR USED TO SIGNAL INPUT
                                ; IS REQUIRED.  ALSO USED AS A FLG
                                ; IN THE CMD PARSING & PROCESSING
                                ; ROUTINES.
DRVZPG          = $35           ; DENOTES DRIVE SELECTED:
                                ; NEG = DRIVE 1, POS = DRIVE 2.
CSW             = $36           ; MAIN OUTPUT HOOK (ALSO KNOWN AS
                                ; THE CHARACTER OUTPUT SWITCH).
                                ; PTR ($36,$37) TO DEVICE/ROUTINE
                                ; WHICH HANDLES OUTPUT CHARACTERS.
KSW             = $38           ; MAIN INPUT HOOK (ALSO KNOWN AS
                                ; THE KEYBOARD SWITCH).
                                ; PTR ($38,$39) TO DEVICE/ROUTINE
                                ; THAT HANDLES INPUT CHARACTERS.
PTR2DCT         = $3C           ; PTR ($3C,$3D) TO RWTS'S DEVICE
                                ; CHARACTERISTIC TABLE.
BOOTSEC         = $3D           ; PHYS SEC # WANTED WHEN BOOTING.
PTR2RDSC        = $3E           ; PTR ($3E,$3F) TO BOOT0'S READ-
                                ; SECTOR SUBROUT'N (BTRDSEC, $CS5C
                                ; WHERE S=SLOT #, NORMALLY=$C65C.)
PTR2BUF         = $3E           ; PTR ($3E,$EF) TO RWTS'S CURRENT
                                ; DATA BUFFER.
HOLDAA          = $3E           ; - HOLDS  A CONSTANT ($AA) FOR
                                ; PROLOGUE AND EPILOGUE BYTES
                                ; USED WHEN FORMATTING.
                                ; - ALSO USED AS A TEMP REG WHEN
                                ; CREATING ODD-EVEN ENCODED BYTS
                                ; ASSOC WITH THE ADDR FIELD.

FRMTSEC         = $3F           ; HOLDS # OF SEC TO BE FORMATTED &
                                ; ALSO ACTS AS CNTR FOR # OF SECS
                                ; VERIFIED WHEN CHECKING TRK JUST
                                ; FORMATTED.
FRMTVOL         = $41           ; VOL # TO WRITE WHEN FORMATTING.
FRMTKCTR        = $44           ; TRK# TO WRITE/READ WHEN FORMAT-
                                ; TING/VERIFYING. ALSO ACTS AS A
                                ; CNTR OF THE # OF TRKS FORMATTED/
                                ; VERIFIED.

A3L             = $40           ; MULTIPURPOSE REG & PTR ($40,$41)
A3H             = $41
A4L             = $42           ; MULTIPURPOSE REG & PTR ($42,$43)
A4H             = $43
A5L             = $44           ; MULTIPURPOSE REG & PTR ($44,$45)
A5H             = $45

SYNCNTR         = $45           ; # OF SYNC BYTES 2 WRT BTWN SECS
                                ; & DELAY CNTR TO LET SOME SYNCS
                                ; PASS BY READ HEAD WHEN VERIFYING
                                ; A TRK JUST FORMATTED.
MTRTIME         = $46           ; MOTOR-ON-TIME COUNT ($46,$47).
                                ; CNTR USED TO DETERMINE IF THE
                                ; DRIVE MOTOR HAS BEEN ON LONG
                                ; ENOUGH TO DO RELIABLE READING.
                                ; THE MOTOR IS CONSIDERED TO BE UP
                                ; TO SPEED AFTER APPROX. 1 SECOND
                                ; (AT WHICH TIME, MTRTIME = 0000).
PTR2IOB         = $48           ; PTR ($48,49) TO RWTS'S INPUT/
                                ; OUTPUT BLOCK (IOB).
STATUS          = $48           ; STATUS REGISTER SAVE AREA.
LOMEM           = $4A           ; PTR ($4A,$4B) 2 START OF INTEGER
                                ; BASIC'S VARIABLE TABLE.
HIMEM           = $4C           ; PTR ($4C,$4D) TO END OF INTEGER
                                ; BASIC PRGM.
TXTTAB          = $67           ; PTR ($67,$68) TO START OF THE
                                ; APPLESOFT PRGM TEXT. DEFAULTS TO
                                ; $801 ON A COLDSTART (ONCE EXECU-
                                ; TION FLOWS INTO APPLESOFT).
                                ; PTR'S CONTENTS CAN BE CHANGED TO
                                ; ACCOMMODATE THE LOADING OF AN
                                ; APPLESOFT PRGM IN A NON-STANDARD
                                ; POSITION.
VARTAB          = $69           ; PTR ($69,$6A) TO START OF SIMPLE
                                ; VARIABLE TABLE.
FRETOP          = $6F           ; PTR ($6F,$70) TO START OF FREE
                                ; SPACE (LOCATED BTWN THE END OF
                                ; THE VARIABLE TBL & THE START OF
                                ; THE STRING VALUES).
MEMSIZ          = $73           ; PTR ($73,$74) TO HIGHEST MEMORY
                                ; LOCATION (PLUS 1) THAT IS AVAIL-
                                ; ABLE TO AN APPLESOFT PRGM.  (NOT
                                ; TO BE CONFUSED WITH THE END OF
                                ; THE APPLESOFT PRGM). CAN ALSO BE
                                ; EXPRESSED AS A PTR TO THE FIRST
                                ; BYTE OF THE DOS BUFFER REGION.
CURLIN          = $75           ; CURRENT APPLESOFT PROGRAM LINE
                                ; NUMBER ( $75,$76).  USED BY DOS
                                ; 2 DETERMINE IF BASIC IS RUNNING.
                                ; (CURLIN+1 CONTAINS AN $FF WHEN
                                ; COMPUTER IS IN THE IMMED MODE.)
PRGEND          = $AF           ; PTR ($AF,$B0) 2 END OF APPLESOFT
                                ; PRGM (PLUS 1) IF FP CMD WAS USED
                                ; OR TO END OF PRGM (PLUS 2) IF A
                                ; NEW CMD WAS USED.
INTPGMST        = $CA           ; PTR ($CA,$CB) TO START OF THE
                                ; INTEGER PRGM.
INTVRLND        = $CC           ; INTEGER BASIC'S CURRENT END-OF-
                                ; VARIABLE PTR ($CC,$CD).
PROTFLG         = $D6           ; PRGM PROTECTION FLAG.
                                ; IF PROTECTION FLAG IS ON (NEG),
                                ; ALL APPLESOFT CMDS CAUSE A RUN &
                                ; DOS'S SAVE CMD CAUSE A PHONY
                                ; PROGRAM-TOO-LARGE ERROR MSG 2 BE
                                ; GENERATED.
ERRFLG          = $D8           ; ON-ERROR FLAG.  EQUALS $80 IF
                                ; ON-ERR IS ACTIVE.
RUNMODE         = $D9           ; INTEGER BASIC'S MODE FLAG.
                                ; CONTAINS A NEG VALUE IF INTEGER
                                ; IS IN THE DEFERRED MODE.


                                ; --------------------------------
                                ; PAGE TWO
                                ; --------------------------------
BUF200          = $200          ; THE INPUT BUFFER ($200-$2FF).
                                ; (ALSO KNOWN AS KEYBOARD BUFFER.)

                                ; --------------------------------
                                ; PAGE THREE
                                ; --------------------------------
PG3DOSVT        = $3D0          ; START OF PAGE-3 DOS VECTOR TBL.
RESETVEC        = $3F2          ; RESET VECTOR.  CONTAINS ADDR OF
                                ; ROUT'N WHERE EXECUT'N DIVERTS TO
                                ; WHEN THE RESET KEY IS PRESSED.
VLDBYTE         = $3F4          ; RESET VALIDATION BYTE.
                                ; IF $3F3 EOR #$A5 IS NOT EQUAL TO
                                ; $3F4, THEN DISK REBOOTS AND A
                                ; COLDSTART IS DONE.  OTHERWISE,
                                ; EXECUTION GOES TO THE ADDR IN
                                ; $3F2/$3F3.


                                ; --------------------------------
                                ; TEXTSCREEN HOLES
                                ; --------------------------------
TRK4DRV1        = $478          ; BASE ADR USED TO REFERENCE THE
                                ; LOCATION THAT CONTAINS THE LAST
                                ; HALFTRACK ON WHICH DRIVE 1 WAS
                                ; ALIGNED.
PRESTRK         = $478          ; - CURRENT HALFTRACK NUMBER.
                                ; - SAVE REG FOR WHOLE TRK# WANTED
                                ; WHEN HAVE TO GO RECALIBRATE.
TRK4DRV2        = $4F8          ; BASE ADR USED TO REFERENCE THE
                                ; LOCATION THAT CONTAINS THE LAST
                                ; HALFTRACK ON WHICH DRIVE 2 WAS
                                ; ALIGNED.
RSEEKCNT        = $4F8          ; CNTR FOR # OF RE-SEEKS ALLOWED
                                ; BETWEEN RECALIBRATIONS (4 --> 1,
                                ; DO RECALIBRATION WHEN CNTR = 0.)

READCNTR        = $578          ; CNTR FOR # OF ATTEMPTS ALLOWED 2
                                ; GET A GOOD ADDR OR DATA READ.
SLOTPG5         = $5F8          ; SLOT*16 USED WHEN DOS WAS BOOTED

SLOTPG6         = $678          ; SLOT*16 USED WHEN FORMATTING &
                                ; WRITING.
RECLBCNT        = $6F8          ; CNTR FOR # OF RECALIBRATIONS
                                ; ALLOWED BEFORE RWTS GIVES UP.



                                ; --------------------------------
                                ; RAM-BASED APPLESOFT ADDRESSES
                                ; A(RAM)
                                ; --------------------------------
CLRFPRAM        = $E65          ; ENTRY POINT TO CLEAR VARIABLES
                                ; FROM A RAM-BASED APPLESOFT PRGM.
RUNFPRAM        = $FD4          ; ENTRY POINT 2 EXECUTE RAM-BASED
                                ; APPLESOFT PRGM.


                                ; --------------------------------
                                ; DOS BUFFER START
                                ; --------------------------------

DOSTOP          = $BF00         ; Mosher: first byte of highest page to
                                ; relocate DOS to





                                ;
COL80OFF        = $C00C
ALTCAHR0FF      = $C00E

RRAMWXXXD2      = $C080
RROMWRAMD2      = $C081
RROMWXXXD2      = $C082
RRAMWRAMD2      = $C083
RRAMWXXXD1      = $C088
RROMWRAMD1      = $C089
RROMWXXXD1      = $C08A
RRAMWRAMD1      = $C08B

                                ; --------------------------------
                                ; DRIVE FUNCTION BASE ADDRS
                                ; --------------------------------
                                ; NOTE:  THE ACTUAL ADDRESSES
                                ; USED ARE DEPENDENT UPON WHICH
                                ; SLOT HOUSES THE DSK CONTROLLER
                                ; CARD. (SEE COMMENTS IN ANY ONE
                                ; OF THE FORMATTED DISASSEMBLIES
                                ; OF RWTS FOR MORE DETAILS.)

                                ; TURN STEPPER MOTOR MAGNETS OFF OR ON.
MAG0FF          = $C080
MAG0ON          = $C081
MAG1FF          = $C082
MAG1ON          = $C083
MAG2FF          = $C084
MAG2ON          = $C085
MAG3FF          = $C086
MAG3ON          = $C087

MTROFF          = $C088         ; TURN DRIVE MOTOR OFF.
MTRON           = $C089         ; TURN DRIVE MOTOR ON.
SELDRV1         = $C08A         ; SELECT DRIVE 1.
SELDRV2         = $C08B         ; SELECT DRIVE 2.
Q6L             = $C08C         ; SHIFT BYTE IN OR OUT OF LATCH.
Q6H             = $C08D         ; LOAD LATCH FROM DATA BUS.
Q7L             = $C08E         ; PREPARE TO READ.
Q7H             = $C08F         ; PREPARE TO WRITE.

BTRDSEC         = $C65C         ; BOOT0'S READ SECTOR SUBROUTINE.
                                ; (ACTUALLY=$CS5C, WHERE S=SLOT#.)


                                ; --------------------------------
                                ; APPLESOFT ADDRESSES
                                ; --------------------------------
RESTART         = $D43C         ; APLSFT BASIC'S WRMSTART ROUTINE.
SETLINKS        = $D4F2         ; ROUT'N THAT CLEARS ALL VAR'BLES,
                                ; RESETS THE STK PTR & RECALCS THE
                                ; LINKS IN @ APPLESOFT PRGM LINE.
                                ; (THIS ROUTINE IS WHAT ENABLES
                                ; APLSFT PRGMS TO BE RELOCATABLE.)
SETZPTRS        = $D665         ; APPLESOFT ROUTINE THAT SIMULATES
                                ; CLEAR & RESTORE STATEMENTS.
NEWSTT          = $D7D2         ; ROUTINE TO COLLECT & EXECUTE THE
                                ; APPLESOFT PRGM STATEMENT.
BSCERHLR        = $D865         ; BASIC'S ERROR-HANDLING ROUTINE.
BASICCLD        = $E000         ; BASIC'S COLDSTART ROUTINE.
BASICWRM        = $E003         ; BASIC'S WARMSTART ROUTINE.
BASICCHN        = $E836         ; BASIC'S CHAIN ENTRY POINT.
BASICERR        = $E3E3         ; BASIC'S ERROR HANDLER???

                                ; --------------------------------
                                ; MONITOR ROM ROUTINES
                                ; --------------------------------
INSDS2          = $F88E         ; Instruction translation routine
OLDBRK          = $FA59         ; DEFAULT BREAK INTERRUPT HANDLER.
INIT            = $FB2F         ; SCREEN INITIALIZATION ROUTINE.
                                ; (SET FULL SCREEN TEXT.)
HOME            = $FC58         ; BLANK OUT CURRENT SCROLL WINDOW
                                ; & PUT THE CURSOR IN THE TOP LEFT
                                ; CORNER OF THE WINDOW.  (DOES NOT
                                ; RESET THE WINDOW SIZE.)
RDKEY           = $FD0C         ; REQUEST INPUT VIA INPUT HOOK.
KEYIN           = $FD1B         ; WAIT FOR INPUT FROM KEYBOARD.
PRBYTE          = $FDDA         ; PRINT CONTENTS OF (A) AS HX VAL.
COUT            = $FDED         ; ROUTE OUTPUT VIA THE OUTPUT HK.
COUT1           = $FDF0         ; MONITOR ROM (TRUE) OUTPUT HNDLR.
SETKBD          = $FE89         ; SELECT KEYBOARD AS INPUT DEVICE.
INPORT          = $FE8B         ; ENTRY POINT TO SELECT INPUT
                                ; DEVICE OTHER THAN KEYBOARD.
SETVID          = $FE93         ; SELECT SCREEN AS OUTPUT DEVICE.
OUTPORT         = $FE95         ; ENTRY POINT TO SELECT OUTPUT
                                ; DEVICE OTHER THAN SCREEN.
MONRTS          = $FF58         ; AN RTS INSTRUC LOC'D IN MONITOR
                                ; ROM. MANY RELOCATABLE PGMS "JSR"
                                ; TO HERE IN ORDER TO LOAD UP THE
                                ; STACK WITH THE ADDR OF THE "JSR"
                                ; SO THEY CAN FIND OUT THE PRGM'S
                                ; PRESENT LOCATION.
MON             = $FF65         ; NORM ENTRY ROUTE 2 MONITOR ROM.
                                ; ("CALL -151" GOES HERE.)






                                ; ASCII VALUES (WITH HIGH-BIT SET)
CR              = $0D|%10000000 ; carriage-return
SP              = " "|%10000000 ; space






LDAZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $AD
                DW    ZEROPAGE_LOC
                ELSE
                LDA   ZEROPAGE_LOC
                ENDIF
                ENDM

LDYZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $AC
                DW    ZEROPAGE_LOC
                ELSE
                LDY   ZEROPAGE_LOC
                ENDIF
                ENDM

STAZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $8D
                DW    ZEROPAGE_LOC
                ELSE
                STA   ZEROPAGE_LOC
                ENDIF
                ENDM

STXZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $8E
                DW    ZEROPAGE_LOC
                ELSE
                STX   ZEROPAGE_LOC
                ENDIF
                ENDM

STYZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $8C
                DW    ZEROPAGE_LOC
                ELSE
                STY   ZEROPAGE_LOC
                ENDIF
                ENDM

ADCZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $6D
                DW    ZEROPAGE_LOC
                ELSE
                ADC   ZEROPAGE_LOC
                ENDIF
                ENDM

DECZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $CE
                DW    ZEROPAGE_LOC
                ELSE
                DEC   ZEROPAGE_LOC
                ENDIF
                ENDM

INCZ            MACRO ZEROPAGE_LOC
                IF DOS31
                DB    $EE
                DW    ZEROPAGE_LOC
                ELSE
                INC   ZEROPAGE_LOC
                ENDIF
                ENDM




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ; Chris Mosher:
                                ; added DOS master relocation routine disassembly
                                ; to beginning of original DOS (slave) disassembly,
                                ; and fixed original assembly code to assemble at
                                ; $1B00 instead of $9B00
                ORG   $1B00

MASTERDOS       JMP   DOSCOLD

DOSRELOC
                                ; (A3) --> DOSTOP
                LDA   #HI DOSTOP
                STAZ  A3H
                LDX   #LO DOSTOP
                STXZ  A3L

                                ; check for existence of RAM,
                                ; starting at page $BF and working downwards
L1B0B           LDY   #0
                LDA   (A3L,X)   ; (note: X is always 0)
                STA   PROSCRTH
L1B11           TYA
                EOR   PROSCRTH
                STA   PROSCRTH
                TYA
                EOR   (A3L,X)   ; (note: X is always 0)
                STA   (A3L,X)   ; (note: X is always 0)
                CMP   PROSCRTH
                BNE   L1B24
                INY
                BNE   L1B11
                BEQ   L1B28

L1B24
                DECZ  A3H
                BNE   L1B0B     ; always branches

                IF DOS31
L1B28           JSR   L1B28SR
                ELSE
                                ; upon entry, A3 --> first byte of highest RAM page (e.g., $BF00)
L1B28
                LDAZ  A3H
                AND   #$DF      ; $BF becomes $9F
                STAZ  A4H
                STXZ  A4L       ; (A4) --> $9F00
                LDA   (A4L,X)
                PHA             ; save (A4) in case we need to restore it below
                STA   PROSCRTH
L1B35           TYA
                EOR   PROSCRTH
                STA   PROSCRTH
                TYA
                EOR   (A3L,X)
                STA   (A4L,X)
                CMP   PROSCRTH
                BNE   L1B4C
                INY
                BNE   L1B35
                                ; comes here if 9F page maps to BF page
                LDY   A4H       ; $9F
                PLA             ; (A4)
                JMP   L1B51




L1B4C           PLA
                STA   (A4L,X)   ; restore (A4)
                LDY   A3H       ; $BF

                ENDIF


                                ; upon entry Y contains highest destination page (e.g., $BF)
L1B51           INY
                STY   DSTPAGELIM ; page limit (e.g., $C0)
                SEC
                TYA
                SBC   PAGECNT
                STA   DSTPAGE   ; first page to reloc to (e.g., $9D)
                SEC
                SBC   SRCPAGE   ; first page to reloc from (e.g., $1D)
                BEQ   MASTERDOS ; if no reloc is necessary (already at dst addr), branch to boot routine



                STA   OFFSET    ; $80
                LDA   SRCPAGE   ; $1D
                STA   ADOSTART+1; fixup dos-start vector

                                ; fix this pointer inside DOS: it used to
                                ; point to us (the relocation), but since we
                                ; are doing the relocating now, change it
                                ; so it just goes right to the DOS cold-start routine
                LDA   #HI DOSCOLD
                STA   TODOSCLD2+2
                LDA   #LO DOSCOLD
                STA   TODOSCLD2+1


                                ; fix up DOS vectors (ranges defined
                                ; in FIXVECTBL).
                LDX   #0
                STXZ  A3L

FIXVEC          LDA   FIXVECTBL,X
                TAY
                LDA   FIXVECTBL+1,X
                STAZ  A3H
                JMP   L1B93

L1B86           CLC
                LDA   (A3L),Y
                ADC   OFFSET
                STA   (A3L),Y
                INY
                BNE   L1B93
                INCZ  A3H
L1B93           INY
                BNE   L1B98
                INCZ  A3H
L1B98
                LDAZ  A3H
                CMP   FIXVECTBL+3,X
                BCC   L1B86
                TYA
                CMP   FIXVECTBL+2,X
                BCC   L1B86

                TXA
                CLC
                ADC   #4
                TAX
                CPX   FIXVECTBLSIZ
                BCC   FIXVEC



                                ; Do the fixups.
                                ; Look through the DOS machine code instructions
                                ; and look for absolute references to addresses
                                ; within the code that is being relocated, and
                                ; add the offset (in pages) to the high-order byte.
                LDX   #0
FIXCOD          STX   CURDIRNX
                LDA   FIXCODTBL,X
                STAZ  A3L
                LDA   FIXCODTBL+1,X
                STAZ  A3H

.LOOP           LDX   #0
                LDA   (A3L,X)
                JSR   INSDS2
                LDYZ  VOLDSK
                CPY   #2
                BNE   .NOCHANGE
                LDA   (A3L),Y
                CMP   SRCPAGE
                BCC   .NOCHANGE
                CMP   SRCPAGELIM
                BCS   .NOCHANGE
                ADC   OFFSET
                STA   (A3L),Y
.NOCHANGE       SEC
                LDAZ  VOLDSK
                ADCZ  A3L
                STAZ  A3L
                LDA   #$00
                ADCZ  A3H
                STAZ  A3H
                LDX   CURDIRNX
                CMP   FIXCODTBL+3,X
                BCC   .LOOP
                LDAZ  A3L
                CMP   FIXCODTBL+2,X
                BCC   .LOOP

                TXA
                CLC
                ADC   #4
                TAX
                CPX   FIXCODTBLSIZ
                BCC   FIXCOD

                                ; Copy the image to the new location
RELOC           LDA   #$3F
                STAZ  A3H
                LDY   DSTPAGELIM
                DEY
                STYZ  A4H
                LDA   #0
                STAZ  A3L
                STAZ  A4L
                TAY
.LOOP2          LDA   (A3L),Y
                STA   (A4L),Y
                INY
                BNE   .LOOP2
                DEC   PAGECNT2
                BEQ   .DONE
                DECZ  A3H
                DECZ  A4H
                BNE   .LOOP2
.DONE
                                ; Done relocating, so now cold-start it
                JMP   IMGCOLVT



                                ; Table of vectors within DOS that we need to
                                ; fix up. Format:
                                ; START,LIMIT
FIXVECTBLSIZ    DB    FIXVECTBLLIM-FIXVECTBL ; size of table in bytes
FIXVECTBL       DW    ADOSFNB1,CHAINTRY
                DW    RUNTRY,ADBSCERR
                DW    IMGINTV+2,IMGINTV+4
                DW    IMGFPV,IMGFPV+4
                DW    IMGARAMV,IMGARAMV+4
                DW    IMGARAMV+6,IMGARAMV+8
                DW    ADRIOB,FMXTNTRY
                DW    ADROFIOB,IBTYPE
                DW    IBDCTP,IBBUFP
FIXVECTBLLIM

                DS    12

                                ; Table of code within DOS that we need to
                                ; fix up. Format:
                                ; START,LIMIT
FIXCODTBLSIZ    DB    FIXCODTBLLIM-FIXCODTBL ; size of table in bytes
FIXCODTBL       DW    DOSCOLD,CMDTXTBL
                DW    FMXTNTRY,CURDIRTK
                IF DOS31 || DOS32
                DW    BOOT2
                ELSE
                DW    APPNDFLG
                ENDIF
                DW    NMPG2RD
                IF DOS31
                DW    BOOT1-2, BOOT2-$102 ; NONSENSE ENTRIES?
                ELSE
                IF DOS32
                DW    BOOT1-2, BOOT1-2 ; NONSENSE ENTRIES?
                ELSE
                DW    WRITADR,FREE1
                ENDIF
                ENDIF
                DW    PRENIBL
                IF DOS31 || DOS32
                DW    ONTABLE-1
                ELSE
                DW    ONTABLE
                ENDIF
                IF DOS33_1986 || DOS33_1983
                DW    CKIFAPND,CMPATCH
                ENDIF
                DW    RWTS
                IF !DOS31 && !DOS32
                DW    SECFLGS,CLOBCARD
                ENDIF
                DW    DOSLIM-1
FIXCODTBLLIM
                IF DOS31 || DOS32
                DS 4
                ENDIF

SRCPAGE         DB    $1D
SRCPAGELIM      DB    $40

DSTPAGE         DS    1
DSTPAGELIM      DS    1

PAGECNT         DB    $23       ; number of pages to be moved
OFFSET          DS    1         ; number of pages to add, to reloc addresses
PAGECNT2        DB    $23       ; (redundant?) number of pages to be moved

                IF DOS31
                DB    $13       ; UNUSED CODE???
                BMI   *-$46
                JSR   L1C7B
                LDA   #$80
                STA   $13
                PLA
                BNE   *-$2E
L1C7B           LDX   MEMSIZ
                ENDIF
                IF DOS31 || DOS32
                LDA   MEMSIZ+1  ; UNUSED CODE???
                STX   FRETOP
                STA   FRETOP+1
                LDY   #$00
                STY   $8B
                LDA   $6D
                LDX   $6E
                STA   $9B
                STX   $9C
                LDA   #$55
                LDX   #$00
                STA   $5E
                STX   $5F
L1C97           CMP   $52
                BEQ   L1CA0
                JSR   *+$7F
                BEQ   L1C97
L1CA0           LDA   #$07
                STA   $8F
                LDA   VARTAB
                LDX   VARTAB+1
                STA   $5E
                STX   $5F
L1CAC           CPX   $6C
                BNE   L1CB4
                CMP   $6B
                BEQ   L1CB9
L1CB4           JSR   OUTHNDTB
                BEQ   L1CAC
L1CB9           STA   $94
                STX   $95
                LDA   #$03
                STA   $8F
L1CC1           LDA   $94
                LDX   $95
                CPX   $6E
                BNE   L1CD0
                CMP   $6D
                BNE   L1CD0
                JMP   *+$8C
L1CD0           STA   $5E
                STX   $00
DOSNMBF1        LDY   #$00
                LDA   ($5E),Y
                TAX
                INY
                LDA   ($5E),Y
                PHP
                INY
                LDA   ($5E),Y
                ADC   $94
                STA   $94
                INY
                LDA   ($5E),Y
                ADC   $95
                STA   $95
                PLP
                BPL   L1CC1
                TXA
                BMI   L1CC1
                DW $1CA6,$1BA6,$1AA6,$1A80,$5E65,$5E85
                DB $90,$02,$E6
                ELSE
                                ; unused:
                IF DOS33_1980 || DOS32
                DS    4
                ENDIF
                IF !DOS31 && !DOS32
                DS    $52
                ENDIF
DOSNMBF1        DS    $2D       ; this label represents the first DOS buffer
                ENDIF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



                                ; ====================================
                                ; RELOCATABLE ADDRESS CONSTANTS TABLE.
                                ; ($9D00 - $9D0F)
                                ; (ADRS CAN BE CHANGED TO POINT TO
                                ; CUSTOMIZED ROUTINES, TABLES, ETC.)
                                ; ====================================

ADOSFNB1
                IF DOS31 || DOS32
                DW DOSNMBF1-1   ; PTS TO FIRST DOS BUFFER AT ITS
                                ; FILE NAME FIELD.
                ELSE
                DW DOSNMBF1
                ENDIF

ADINPTCP        DW INPTINCP     ; PTS TO DOS'S INPUT INTERCEPT ROUTINE.
ADOPUTCP        DW OPUTINCP     ; PTS TO DOS'S OUTPUT INTERCEPT ROUTINE.
ADRPFNBF        DW PRIMFNBF     ; PTS TO PRIMARY FILENAME BUFFER.
ADRSFNBF        DW SCNDFNBF     ; PTS TO SECONDARY FILENAME BUFFER.
ADLENADR        DW LENADRBF     ; PTS TO 2-BYTE BUF THAT RECEIVES
                                ; BLOAD ADR & LENGTH READ FROM DSK
ADOSTART        DW MASTERDOS    ; PTS TO 1RST BYTE OF DOS.
ADFMPARM        DW OPCODEFM     ; PTS TO FM PARAMETER LIST.


                                ; =====================================
                                ; TABLE OF OUTPUT HANDLER ENTRY POINTS
                                ; ($9D10 - $9D1D)
                                ; (ADR-1 OF ROUT'NS WHICH HANDLE PRINT
                                ; STATEMENTS CONTAINING DOS CMDS.)
                                ; =====================================

OUTHNDTB        DW OPUTHDL0-1   ; EVALUATE START OF INPUT LINE.
                DW OPUTHDL1-1   ; COLLECT THE DOS COMMAND.
                DW OPUTHDL2-1   ; PRINT A <CR> AND RETURN.
                DW OPUTHDL3-1   ; PROCESS THE INPUT INFORMATION.
                DW OPUTHDL4-1   ; WRITE DATA TO DISK.
                DW OPUTHDL5-1   ; ANALYZE 1RST CHR OF DATA FRM DSK
                DW OPUTHDL6-1   ; IGNORE INPUT PROMPT ("?").


                                ; =======================================
                                ; COMMAND HANDLER ENTRY POINT TABLE
                                ; ($9D1E - $9D55)
                                ; ALL ADRS ARE ONE LESS THAN THE ACTUAL
                                ; ENTRY POINTS BECAUSE THESE ROUT'NS ARE
                                ; ENTERED VIA A "STACK JUMP".  IF YOU
                                ; CREATE A NEW DOS CMD, PLACE THE ADR-1
                                ; OF THE NEW CMD IN THE FOLLOWING TABLE.
                                ; (ALSO MAKE SURE THAT THE FIRST CMD IN
                                ; THE TABLE CAN CREATE A NEW FILE.)
                                ; SOME AUTHORS DISABLE SPECIFIC DOS
                                ; CMDS BY POINTING THE CMD'S TABLE ADR
                                ; AT DOS'S COLDSTART ROUTINE OR BY
                                ; PLACING AN "RTS" OPCODE AT THE CMD'S
                                ; ENTRY POINT.
                                ; =======================================

CMDTBL          DW CMDINIT-1    ; $A54F-1
                DW CMDLOAD-1    ; $A413-1
                DW CMDSAVE-1    ; $A397-1
                DW CMDRUN-1     ; $A4D1-1
                DW CMDCHAIN-1   ; $A4F0-1
                DW CMDELETE-1   ; $A263-1
                DW CMDLOCK-1    ; $A271-1
                DW CMDUNLOK-1   ; $A275-1
                DW CMDCLOSE-1   ; $A2EA-1
                DW CMDREAD-1    ; $A51B-1
                DW CMDEXEC-1    ; $A5C6-1
                DW CMDWRITE-1   ; $A510-1
                DW CMDPOSN-1    ; $A5DD-1
                DW CMDOPEN-1    ; $A2A3-1
                DW CMDAPPND-1   ; $A298-1
                DW CMDRENAM-1   ; $A281-1
                DW CMDCATLG-1   ; $A56E-1
                DW CMDMON-1     ; $A233-1
                DW CMDNOMON-1   ; $A23D-1
                DW CMDPR-1      ; $A229-1
                DW CMDIN-1      ; $A22E-1
                DW CMDMXFIL-1   ; $A251-1
                DW CMDFP-1      ; $A57A-1
                DW CMDINT-1     ; $A59E-1
                DW CMDBSAVE-1   ; $A331-1
                DW CMDBLOAD-1   ; $A35D-1
                DW CMDBRUN-1    ; $A38E-1
                DW CMDVERFY-1   ; $A27D-1

                                ; ===========================================
                                ; ACTIVE BASIC ENTRY POINT VECTOR TABLE
                                ; ($9D56 - $9D61)
                                ; (NOTE:  TBL CUTOMIZED BY DOS ACCORDING TO
                                ; THE CURRENT VERSION OF BASIC THAT IS BEING
                                ; USED.  ADRS SHOWN AS OPERANDS BELOW,
                                ; ASSUME THAT APPLESOFT BASIC IS ACTIVE.)
                                ; ===========================================

CHAINTRY        DW BASICCHN     ; ADR OF CHAIN ENTRY PT TO BASIC.
RUNTRY          DW RUNINTGR     ; ADR OF BASIC'S RUN CMD.
ADBSCERR        DW BASICERR     ; ADR OF BASIC'S ERROR HANDLER.
TOCLDVEC        DW BASICCLD     ; ADR OF BASIC'S COLD START ROUT'N
TOWRMVEC        DW BASICWRM     ; ADR OF BASIC'S WARM START ROUT'N

                IF !DOS31
RLOCNTRY
                IF DOS32
                DS 2
                ELSE
                DW SETLINKS
                                ; ADR OF ROUT'N THAT ENABLES BASIC
                                ; PRGMS TO BE RELOCATABLE.
                ENDIF

                ENDIF

                                ; ====================================
                                ; IMAGE OF INTEGER BASIC'S ENTRY
                                ; POINT VECTOR TABLE ($9D62 - $9D6B).
                                ; ====================================

IMGINTV         DW BASICCHN
                DW RUNINTGR
                DW BASICERR
                DW BASICCLD
                DW BASICWRM


                                ; =======================================
                                ; IMAGE OF ROM APPLESOFT BASIC'S ENTRY
                                ; POINT VECTOR TABLE ($9D6C - $9D77).
                                ; =======================================

IMGFPV          DW RUNFPROM
                DW RUNFPROM
                DW BSCERHLR
                DW BASICCLD
                IF DOS31
                DS 2
                ELSE
                DW RESTART
                DW SETLINKS
                ENDIF


                                ; ========================================
                                ; IMAGE OF RAM APPLESOFT BASIC'S  ENTRY
                                ; POINT VECTOR TABLE ($9D78 - $9D83).
                                ; (NOTE: A(RAM) REFERS TO A DISK-BASED
                                ; VERSION OF APPLESOFT BASIC THAT IS
                                ; HOUSED ON THE "SYSTEMS MASTER" DISK.)
                                ; ========================================

IMGARAMV        DW FPRAMRUN
                DW FPRAMRUN
                DW $1067
                DW DOSCOLD
                IF DOS31
                DS 2
                ELSE
                DW $C3C
                DW $CF2
                ENDIF


                                ; =================================
                                ; DOS'S COLD START ROUTINE.
                                ; (PS. DON'T CONFUSE WITH BASIC'S
                                ; COLD START ROUTINE - BASICCLD.)
                                ; =================================

                                ; GET SLOT & DRV #'S & STORE THEM AS
                                ; DEFAULT VALS IN CASE NO SUCH PARMS
                                ; WERE ISSUED WITH THE COMMAND.

DOSCOLD         LDA IBSLOT      ; SLOT# * 16 FROM RWTS'S IOB TBL.
                LSR A           ; DIVIDE BY 16.
                LSR A
                LSR A
                LSR A
                STA SLOTPRSD    ; PUT SLOT IN PARSED TABLE.
                LDA IBDRVN      ; DRV # FROM RWTS'S IOB.
                STA DRVPRSD     ; PUT DRIVE # IN PARSED TABLE.

                                ; CHK WHICH BASIC IS IN ROM.

                LDA BASICCLD    ; SET IDENTIFYING BYTE WITH
                EOR #$20        ; $20 = INTEGER OR $40 = A(ROM).
                BNE ISFPROM     ; BRANCH IF APPLESOFT IS IN ROM.

                                ; INTEGER BASIC IS ACTIVE.

ISINT           STA ACTBSFLG    ; SET ACTIVE BASIC FLAG
                                ; TO DENOTE INTEGER (#$00).

                                ; COPY IMAGE OF INTEGER BASIC'S
                                ; ENTRY POINT VECTOR TABLE TO THE
                                ; ACTIVE BASIC ENTRY VECTOR TABLE.

                LDX #10
INT2BSIC        LDA IMGINTV-1,X
                STA CHAINTRY-1,X
                DEX
                BNE INT2BSIC    ; 10 BYTES TO COPY (10 --> 1).
                JMP BYPASWRM

                                ; COPY IMAGE OF APPLESOFT'S ENTRY
                                ; POINT VECTOR TABLE TO THE ACTIVE
                                ; BASIC ENTRY POINT VECTOR TABLE.

ISFPROM         LDA #$40        ; SET ACTIVE BASIC FLAG TO #$40
                STA ACTBSFLG    ; SO SIGNAL APPLESOFT ROM.
                LDX #IMGARAMV-IMGFPV
AROM2BSC        LDA IMGFPV-1,X
                STA CHAINTRY-1,X
                DEX
                BNE AROM2BSC
BYPASWRM        SEC             ; (C) = 1, SIGNAL FOR COLDSTART.
                                ; (C) = 0, SIGNAL FOR WARMSTART.
                BCS CMWRMCLD    ; FORCE BRANCH TO BYPASS PART OF
                                ; THE WARMSTART ROUTINE.


                                ; =================================
                                ; DOS'S WARMSTART ROUTINE.
                                ; (PS. DON'T CONFUSE WITH BASIC'S
                                ; WARMSTART ROUTINE - RESTART.)
                                ; =================================

DOSWARM
                IF !DOS31
                LDA ACTBSFLG    ; SEE WHICH LANGUAGE IS UP.
                BNE CKBASIC     ; IF A(ROM), #$40 OR A(RAM), #$80.

                                ; INTEGER WAS UP.

                LDA #$20        ; (A) = OPCODE FOR "JSR" INSTRUC.
                BNE DTRMNBSC    ; ALWAYS.


                                ; ACTIVE BASIC FLAG DENOTED THAT A
                                ; VERSION OF APPLESOFT WAS ACTIVE,
                                ; SO NOW CHECK IF DEALING WITH
                                ; A(RAM) OR A(ROM).

CKBASIC         ASL A           ; MULTIPLY CODE TIMES 2.
                BPL FORWARM     ; BRANCH IF A(RAM).
                                ; (IE. A(RAM) YEILDS $40 * 2 = $80
                                ; & A(ROM) YEILDS $80 * 2 = $00.)

                                ; USING A(ROM).

                LDA #$4C        ; (A) = OPCODE FOR "JMP" INSTRUC.
DTRMNBSC        JSR SETROM      ; GO TEST CARD OR MOTHERBOARD TO
                                ; INSURE THAT DEVICE CONTAINING
                                ; ROM VERSION WE WANT IS SELECTED.
                ENDIF

FORWARM         CLC             ; (C) = 0, SIGNAL FOR WARMSTART.
CMWRMCLD        PHP             ; SAVE (C) DENOTING WARM OR COLD.
                JSR INITIOHK    ; INITIALIZE THE I/O HOOKS SO THAT
                                ; DOS INTERCEPTS ALL IN/OUTPUT.
                IF DOS31
                LDA #$70
                ELSE
                LDA #0
                ENDIF
                STA CIOCUMUL    ; SIMULATE A "NOMON" COMMAND.
                                ; NOTE: CAN "NOP" OUT THIS INSTRUC
                                ; TO DEFEAT "NOMONCIO" WHEN COLD-
                                ; OR WARMSTARTING.
                IF DOS31
                LDA #0
                ENDIF
                STA OPUTCOND    ; SET CONDITION 0.
                PLP             ; GET SAVED STATUS BACK OFF STK &
                ROR A           ; ROTATE (C) INTO HI BIT OF (A) TO
                STA CONDNFLG    ; SET CONDNFLG = $00 FOR WARMSTART
                                ; OR CONDNFLG = $80 FOR COLDSTART.
                BMI LANGCOLD    ; BRANCH IF DOING COLDSTART.

LANGWARM        JMP (TOWRMVEC)  ; JMPS TO BASIC'S WARMSTART ROUT'N
                                ; (RESTART) AT $D43C.

LANGCOLD        JMP (TOCLDVEC)  ; JMPS TO BASIC'S COLDSTART ROUT'N
                                ; (BASICCLD) AT $E000.


                                ; =================================
                                ; INITIAL PROCESSING WHEN FIRST
                                ; KEYBOARD INPUT REQUEST IS MADE
                                ; BY BASIC AFTER A COLDSTART.
                                ; =================================

                                ; TEST IF USING A(RAM) OR NOT.
                                ; ON ENTRY, (A) = CONTENTS OF CONDNFLG.
                                ; = $00 = WARM START.
                                ; = $01 = READING.
                                ; = $80 = COLD START.
                                ; = $C0 = USING A(RAM).

KEYCOLD         ASL A           ; (A) * 2 TO DROP OUT HI BIT.
                BPL SKPDARAM    ; BRANCH IF NOT USING A(RAM).
                STA ACTBSFLG    ; USING A(RAM) - WAS LOADED BY
                                ; INTEGER BASIC ROM
                                ; - ACTV BSC FLG=$80

                                ; COPY IMAGE OF A(RAM)'S ENTRY
                                ; POINT VECTOR TABLE TO THE
                                ; ACTIVE BASIC ENTRY POINT VECTOR
                                ; TABLE.

                LDX #DOSCOLD-IMGARAMV
ARAM2BSC        LDA IMGARAMV-1,X
                STA CHAINTRY-1,X
                DEX
                BNE ARAM2BSC

                                ; BLANK OUT THE PRIMARY FILENAME
                                ; BUFFER TO MAKE SURE A "HELLO"
                                ; FILE WON'T BE RUN.

                LDX #29         ; 30 BYTES TO BLANK (29 --> 00).
BLNKPRIM        LDA SCNDFNBF,X  ; COPY BLANK SECONDARY TO PRIMARY.
                STA PRIMFNBF,X
                DEX
                BPL BLNKPRIM

                                ; BUILD DOS BUFS & SET CONDITION.

SKPDARAM        LDA MAXDFLT     ; SET MXFILVAL TO DEFAULT VAL OF 3
                STA MXFILVAL    ; NOTE: DEFAULT VAL CAN BE CHANGED
                                ; BY SETTING MAXDFLT BTW'N 1 - 16
                                ; AND THEN INITING A DISK.
                JSR BILDBUFS    ; GO BUILD THE DOS BUFFERS.
                LDA EXECFLAG    ; CHK IF AN EXEC FILE IS RUNNING.
                BEQ SKPDEXEC    ; BRANCH IF NOT EXECING.

                PHA             ; YES - WE ARE EXECING.
                JSR PT2EXEC     ; GET ADR OF BUF WE'RE EXECING IN.
                PLA             ; RETRIEVE EXEC FLG FROM STK.
                LDY #0          ; RESERVE DOS BUFFER FOR EXECING
                STA (A3L),Y     ; IN CASE WE WANT TO MODIFY DOS TO
                                ; EXEC ON THE BOOT?

SKPDEXEC        JSR RESTAT0     ; SET CONDNFLG=0 SO SIGNAL FILE
                                ; NOT BEING READ.
                                ; RESET OPUTCOND=0 (TO SIGNAL WANT
                                ; TO EVALU8 START OF LINE ON RTN).

                                ; CHECK IF DISK WAS JUST BOOTED.
                                ; (IF JUST BOOTED DISK, NDX2CMD
                                ; CONTAINS A $00 WHICH WAS ETCHED
                                ; ON THE DISK WHEN THE DISK WAS
                                ; ORIGINALLY INITED.)
                IF !DOS31
                LDA NDX2CMD     ; WAS LAST CMD AN "INIT"?
                BNE OLDBOOT     ; NO - TAKE BRANCH.
                ENDIF

                                ; DISK WAS JUST BOOTED SO COPY IMAGE
                                ; OF DOS'S ENTRY POINT VECTOR TABLE
                                ; TO PAGE 3.

                IF DOS31
                LDX #INPUTCLD-IMGDOSVT
                ELSE
                LDX #INPTINCP-IMGDOSVT-1
                ENDIF

STOR3DOS        LDA IMGDOSVT,X  ; COPY IMAGE TO PAGE 3.
                STA PG3DOSVT,X
                DEX
                BPL STOR3DOS

                IF DOS31
                LDA   NDX2CMD
                BNE   OLDBOOT
                LDA   PRIMFNBF
                EOR   #$A0
                BEQ   OLDBOOT
                JMP   CMDRUN
                ELSE
                                ; PROGRAM THE RESET KEY TO POINT AT
                                ; DOS'S WARMSTART ROUTINE.
                                ;
                                ; NOTE THAT THE RESET KEY CAN BE
                                ; PROGRAMMED TO PT AT ANY LOCATION
                                ; SIMPLY BY PUTTING THE ADR OF THE
                                ; TARGET ROUTINE (IN LOW/HI FORMAT)
                                ; IN $3F2/$3F3.  NEXT, EOR THE
                                ; CONTENTS OF $3F3 WITH THE NUMBER
                                ; #$A5 AND PUT THE RESULT IN $3F4.
                                ; (IF $3F3 EOR #$A5 < > $3F4, THEN
                                ; DISK REBOOTS & A COLDSTART IS DONE.)

                LDA IMGDOSVT+2  ; WRITE OVER OLD (OUT-DATED) IMAGE
                STA RESETVEC+1  ; WHICH CONTAINED A "JSR MON"
                EOR #$A5        ; INSTRUC APPLIC TO NON-AUTOSTART.
                STA VLDBYTE     ; SET VALIDATION (POWER UP) BYTE.
                LDA IMGDOSVT+1
                STA RESETVEC

                                ; SET THE COMMAND INDEX TO RUN
                                ; THE "HELLO" FILE.

                LDA #6          ; CMD INDEX FOR "RUN".
                                ; (CAN BE CHANGED TO "BRUN", ETC.)
                BNE DOPENDNG    ; ALWAYS.
                ENDIF

                                ; CHECK IF A COMMAND IS PENDING.

OLDBOOT         LDA NEXTCMD
                BEQ NOPEND      ; NO CMD PENDING.

                                ; GO DO THE PENDING COMMAND.  IF THE
                                ; DISK WAS JUST BOOTED, THEN RUN THE
                                ; "HELLO" FILE.  NOTE THAT THE ACTUAL
                                ; NAME OF THE HELLO FILE RESIDES IN
                                ; THE PRIMARY FILENAME BUFFER.  IT
                                ; WAS WRITTEN TO THE DISK AS PART OF
                                ; THE DOS IMAGE WHEN THE DISK WAS INITED.
                                ; THERE4, IF YOU WANT TO CHANGE THE
                                ; NAME OF THE HELLO FILE, YOU MUST:
                                ; (1) CHNG NAME IN FILENAME FIELD
                                ; OF DIRECTORY SEC. (EASIEST JUST
                                ; TO USE THE RENAME CMD.)
                                ; (2) ZAP PRIMARY NAME BUF ON DISK
                                ; (TRK$01/SEC$09/OFFSETS$75-$92).

DOPENDNG        STA NDX2CMD     ; SET CMD INDEX & GO DO CMD.
                IF DOS31
                JMP TORESTAT0
                ELSE
                JMP DODOSCMD
                ENDIF
NOPEND
                IF DOS31
                JMP DOSEXIT
                ELSE
                RTS
                ENDIF


                                ; =================================
                                ; IMAGE OF DOS VECTOR TABLE.
                                ; (COPIED TO PAGE 3, $3D0 - $3FF.)
                                ; =================================

                                ; PAGE-3 ADDR & FUNCTION

IMGDOSVT        JMP DOSWARM     ; $3D0 - GO TO DOS'S WARM START
                                ; ROUTINE.  LEAVE PGRM INTACT.
IMGCOLVT        JMP DOSCOLD     ; $3D3 - GO TO DOS'S COLD START
                                ; ROUT'N. RESET HIMEM, REBUILD DOS
                                ; BUFS & WIPE OUT PRGM.
                JMP FMXTNTRY    ; $3D6 - ALLOW USER TO ACCESS FM
                                ; VIA HIS OWN ASSEMBLY LANG PRGMS.
                IF DOS31
                JMP RWTS
                ELSE
                JMP ENTERWTS    ; $3D9 - ALLOW USER TO ACCESS RWTS
                                ; VIA HIS OWN ASSEMBLY LANG PRGMS.
                ENDIF
                LDA ADFMPARM+1  ; $3DC - LOCATE FM PARAMETER LIST.
                LDY ADFMPARM
                RTS

                LDA ADRIOB+1    ; $3E3 - LOCATE RWTS'S I/O BLOCK.
                LDY ADRIOB
                RTS

                IF !DOS31
                JMP INITIOHK    ; $3EA - PT I/O HOOKS AT DOS'S
                                ; INTERCEPT HANDLERS.
                NOP
                NOP
                JMP OLDBRK      ; $3EF - GOES TO MONITOR'S ROUTINE
                                ; WHICH HANDLES "BRK" INSTRUC'S.
                JMP MON         ; AFTER THIS INSTRUCTION IS COPIED
                                ; TO PAGE 3 (AT $3F2 - $3F4), THE
                                ; ROUTINE AT $9E30 OVERWRITES THE
                                ; PAGE-3 IMAGE 2 PROGRAM THE RESET
                                ; KEY. THIS OVERWRITTING IS DONE 2
                                ; ACCOMMODATE NEWER "AUTOSTART"
                                ; ROM USED IN THE APPLE II+, IIE &
                                ; IIC MACHINES.  THE PAGE-3 LOC'S
                                ; ARE DESCRIBED BELOW:
                                ; $3F2/$3F3 - ADR OF RESET HNDLING
                                ; ROUT'N (IN LOW/HI FORMAT).
                                ; NORMALLY=ADR OF DOSWARM ($9DBF).
                                ; $3F4 - IMG OF VALIDATION BYTE.
                                ; NORMALLY CONTAINS #$38 CAUSE:
                                ; #$9D EOR #$A5 = #$38.

                JMP MONRTS      ; $3F5 - DISABLE &-VECTOR.
                JMP MON         ; $3F8 - LET CTL-Y ENTER MONITOR.
                JMP MON         ; $3FB - HNDL NON-MASK INTERUPTS.
                DW MON          ; ROUT'N 2 HNDL MASKABLE INTERUPTS
                ENDIF


                                ; ==================================
                                ; DOS'S INPUT INTERCEPT ROUTINE.
                                ; (INTERCEPTS ALL INPUT FROM
                                ; KEYBOARD OR DISK.)
                                ; ==================================

INPTINCP        JSR PREP4DOS    ; SAVE THE REGS & RESTORE I/O HKS
                                ; TO PT TO THE TRUE I/O HANDLERS.
                                ; ADJUST STK PTR & SAVE IT SO WE
                                ; CAN LATER RTN 2 THE ROUTINE THAT
                                ; CALLED ROUTINE THAT CONTAINED
                                ; THE "JSR PREP4DOS" INSTRUCTION.
                LDA CONDNFLG    ; TEST IF DOING WARMSTART.
                BEQ INPUTWRM    ; YES - BRANCH IF WARM.

                IF DOS31
                BPL INPUTCLD
                JMP KEYCOLD
INPUTCLD        LDA ASAVED

                ELSE
                                ; READING FILE OR COLDSTARTING.

                PHA             ; SAVE THE CONDITION FLAG.
                LDA ASAVED      ; GET THE SUBSTITUTE CURSOR & PUT
                STA (BASL),Y    ; IT BACK ON THE SCREEN.
                PLA             ; GET CONDITION FLAG BACK IN (A).
                BMI INPUTCLD    ; BRANCH FOR COLD.
                JMP READTEXT    ; READ FILE BYTE.

                                ; DOING A COLDSTART.

INPUTCLD        JSR KEYCOLD     ; SET IMPORTANT PAGE 3 VECTORS.
                                ; SET MXFILVAL=3 & BUILD DOS BUFS.
                                ; SET WARMSTART FLAG.
                                ; EXECUTE PENDING COMMAND.
                LDY CH          ; GET HORZ CURSOR POS'N.
                LDA #$60        ; GET CURSOR.
                ENDIF

                STA (BASL),Y    ; REINSTATE CURSOR ON SCREEN.

                                ; USING WARMSTART STATUS.
                                ; AT THIS POINT IN TIME, BOTH
                                ; CONDNFLG & OPUTCOND = 0 FOR
                                ; WARM- & COLDSTARTS.
                IF DOS31
                JMP READTEXT
                ENDIF

INPUTWRM        LDA EXECFLAG    ; ARE WE EXECING?
                BEQ INPTNOXC    ; NO.
                IF DOS31
                JMP READEXEC
                ELSE
                JSR READEXEC    ; YES - GO READ AN EXEC FILE BYTE.
                ENDIF
INPTNOXC        LDA #3          ; SET OUTPUT CONDITION = 3 CAUSE
                STA OPUTCOND    ; WANT TO PROCESS INPUT INFO.
                JSR RESTOREG    ; RESTORE (A), (Y) & (X) REGS.
                JSR TOTRUIN     ; GET CHAR & PUT IT ON SCREEN VIA
                                ; THE TRUE OUTPUT HANDLER (COUT1).
                STA ASAVED      ; SAVE CHAR & (X).
                IF !DOS31
                STX XSAVED
                ENDIF
                JMP DOSEXIT     ; EXIT DOS.

TOTRUIN         JMP (KSW)       ; JUMP TO THE TRUE INPUT HANDLER.


                                ; =================================
                                ; DOS'S OUTPUT INTERCEPT ROUTINE.
                                ; (INTERCEPTS ALL OUPUT TO SCREEN
                                ; OR OTHER PERIPHERALS.)
                                ; =================================

OPUTINCP        JSR PREP4DOS    ; SAVE REGS & RESTORE I/O HKS 2 PT
                                ; 2 TRUE I/O HANDLERS.  ADJUST STK
                                ; PTR & SAVE IT SO CAN LATER RTN
                                ; TO THE ROUTINE THAT CALLED THE
                                ; ROUTINE THAT CONTAINED THE
                                ; "JSR PREP4DOS" INSTRUCTION.

                                ; USE CURRENT OPUTCOND TO INDEX
                                ; TABLE CONTAINING ADDRS (MINUS 1)
                                ; OF THE OUTPUT CONDITION HANDLERS.
                                ; DO A "STACK JUMP" TO THE APPROPRIATE
                                ; HANDLER.

                LDA OPUTCOND
                ASL A           ; TIMES 2 CAUSE 2 BYTES / ADDRESS.
                TAX             ; SET (X) TO INDEX TABLE OF ADRS.
                LDA OUTHNDTB+1,X
                                ; PUT ADR OF OUTPUT HNDLR ON STK
                PHA             ; (HI BYTE FIRST) & THEN DO A
                LDA OUTHNDTB,X  ; "STACK JUMP" TO THE APPROPRIATE
                PHA             ; HANDLER.
                LDA ASAVED      ; GET CHAR TO BE PRINTED.
                RTS             ; EXECUTE THE STACK JUMP.


                                ; ================================
                                ; PREPARE FOR PROCESSING BY DOS.
                                ; SAVE THE REGS & RESET THE I/O
                                ; HOOKS TO POINT TO THE TRUE I/O
                                ; HANDLERS.
                                ; ================================

PREP4DOS        STA ASAVED      ; SAVE (A), (Y) & (X) REGS.
                STX XSAVED
                STY YSAVED
                TSX             ; ADJUST STK PTR & SAVE IT SO WHEN
                INX             ; WE LATER RESTORE IT & HIT AN
                INX             ; RTS, WE CAN RTN 2 ROUTINE THAT
                STX STKSAVED    ; CALLED ROUTINE THAT CONTAINED
                                ; THE "JSR PREP4DOS" INSTRUCTION.

                                ; DISCONNECT DOS - THIS ENTRY POINT
                                ; IS FREQUENTLY USED BY ASSEMBLY
                                ; LANGUAGE PROGRAMMERS TO DISCONNECT
                                ; DOS COMPLETELY.

UNCONDOS        LDX #3          ; RESTORE THE I/O HKS TO PT TO THE
                                ; TRUE I/O HANDLERS, EX:
SETRUHKS        LDA CSWTRUE,X   ; KSWTRUE: KEYIN --> KSW: KEYIN
                STA CSW,X       ; CSWTRUE: COUT1 --> CSW: COUT1
                DEX
                BPL SETRUHKS    ; 4 BYTES (0 TO 3) TO MOVE.
                RTS


                                ; =================================
                                ; OUTPUT HANDLER 0.
                                ; (EVALUATE START OF LINE.)
                                ; =================================

OPUTHDL0
                IF !DOS31
                LDX RUNTRUPT    ; CONTAINS A NONZERO VALUE IF RUN
                BEQ NONTRUPT    ; CMD WAS INTERRUPTED TO DO A LOAD
                JMP FINSHRUN    ; FINISH OFF THE RUN COMMAND.
                ENDIF

                                ; FILE NOT BEING READ.

NONTRUPT        LDX CONDNFLG    ; GET CONDITION FLAG. CHECK IF WE
                                ; ARE DOING A WARMSTART ($00),
                                ; COLDSTART ($80), USING A(RAM)
                                ; ($C0) OR DOING A READ ($01).
                BEQ SETIGNOR    ; BRANCH IF WARMSTARTING.

                                ; DOING COLDSTART, READING FILE OR USING A(RAM).
                                ; CHECK (A) TO SEE IF USING "?" ASSOCIATED
                                ; WITH READING AN INPUT STATEMENT.

                CMP #"?"|0x80   ; IF READING, USING "?" AS PROMPT.
                BEQ OPUTHDL6    ; GO DSPLY INPUT CONDITIONALLY IF
                                ; GETTING READY 2 READ A TEXT FILE
                                ; BYTE.
                CMP PROMPT      ; ARE WE PRINTING A PROMPT?
                IF DOS31
                BEQ OPUTHDL6
                ELSE
                BEQ SET2EVAL    ; BRANCH IF ABOUT TO PRINT PROMPT.
                ENDIF
SETIGNOR        LDX #2          ; SET CONDITION 2 FOR DEFAULT TO
                STX OPUTCOND    ; SIGNAL SHOULD IGNORE NON-DOS
                                ; COMMANDS.

                CMP DCTRLCHR    ; IS CHAR = DOS'S CTRL CHAR?
                BNE OPUTHDL2    ; NO.
                DEX             ; LINE STARTED WITH DOS'S CTRL CHR
                STX OPUTCOND    ; SO SET CONDITION 1.
                DEX             ; (X) = 1 --> 0.
                STX NDX2INBF    ; INDEX TO 1RST POS'N IN INPUT BUF


                                ; =================================
                                ; OUTPUT HANDLER 1.
                                ; - COLLECT THE DOS COMMAND.
                                ; (IE. - STICK CHAR IN THE INPUT
                                ; BUF & THEN GO DISPLAY CHAR OR
                                ; ELSE GO PARSE CMD.)
                                ; =================================

OPUTHDL1        LDX NDX2INBF    ; GET INDEX TO INPUT BUFFER.
PUTINBUF        STA BUF200,X    ; PUT CHAR IN INPUT BUFFER.
                INX             ; KICK UP INDEX 4 NEXT BUF POS'N.
                STX NDX2INBF
                CMP #CR        ; WAS CHAR A <CR>?
                BNE DSPLYCMD    ; NO.
                JMP PARSECMD    ; YES - GOT END OF INPUT, SO NOW
                                ; SEE IF IT IS A DOS CMD.

                                ; =================================
                                ; OUTPUT HANDLER 2.
                                ; (IGNORE NON-DOS COMMAND.)
                                ; =================================

OPUTHDL2        CMP #CR        ; <CR>?
                BNE DSPLYALL    ; NO - (WAS AN "RH BRACKETT"?)
SET2EVAL        LDX #0          ; SET CONDITION0 - EVALUATE START
                STX OPUTCOND    ; OF LINE.
                JMP DSPLYALL    ; GO DISPLAY CHAR UNCONDITIONALLY.


                                ; =================================
                                ; OUTPUT HANDLER 3.
                                ; (PROCESS INPUT INFO.)
                                ; =================================

OPUTHDL3        LDX #0          ; SET CONDITION 0 WHEN INPUT ENDS.
                STX OPUTCOND
                CMP #CR        ; <CR>?
                BEQ ASUMIMED    ; YES.


TESTEXEC        LDA EXECFLAG    ; ARE WE EXECING?
                BEQ DSPLYALL    ; NO.
                BNE DSPLYINP    ; YES.  EXECFLAG CONTAINS THE 1RST
                                ; CHR OF NAME OF THE EXEC FILE.

ASUMIMED
                IF !DOS31
                PHA             ; SAVE CHAR ON STK.
                SEC             ; (C)=1, DFLT, ASSUME IMMED MODE.
                LDA EXECFLAG    ; ARE WE EXECING?
                BNE TESTMODE    ; BRANCH IF EXECING.
                JSR CKBSCRUN    ; NOT EXECING, SO SEE IF BASIC IS
                                ; RUNNING A PRGM OR NOT.
                                ; (C) = 0, EITHER BASIC RUNNING.
                                ; (C) = 1 IF IMMEDIATE.
TESTMODE        PLA             ; RETRIEVE CHAR FROM STK.
                BCC TESTEXEC    ; BASIC RUNNING, DSPLY INPUT & XIT
                ENDIF

                                ; EXECING OR IN IMMEDIATE MODE
                                ; (CAUSE (C) = 1).

                LDX XSAVED      ; RETRIEVE (X).
                JMP PUTINBUF    ; GO PUT CHR IN INPUT BUF (COND 1)


                                ; =================================
                                ; OUTPUT HANDLER 4.
                                ; (WRITING DATA.)
                                ; =================================

OPUTHDL4        CMP #CR        ; <CR>?
                BNE CMWRTBYT    ; NO.
                LDA #5          ; SET CONDITION 5.
                STA OPUTCOND
CMWRTBYT        JSR WRITEXT     ; GO WRITE DATA BYTE.
                JMP DSPLYOUT    ; DISPLAY OUTPUT CONDITIONALLY.


                                ; ===================================
                                ; OUTPUT HANDLER 5.
                                ; (EVALUATE START OF DATA TO WRITE)
                                ; ===================================

OPUTHDL5        CMP DCTRLCHR    ; IS CHAR = DOS'S CTRL CHAR?
                                ; ************* NOTE ***********
                                ; * DOS'S CTRL CHAR CANCELS THE
                                ; * WRITE MODE.
                                ; ******************************

                BEQ OPUTHDL0    ; YES - SO GO TO CONDITION 0.
                CMP #$8A        ; IS CHAR AN <LF>?
                BEQ CMWRTBYT    ; YES -GO WRITE IT, STAY IN COND 5
                LDX #4          ; NO -RESET TO CONDITION4 - SIGNAL
                STX OPUTCOND    ; WANT TO WRITE ANOTHER LINE.
                BNE OPUTHDL4    ; ALWAYS.


                                ; =================================
                                ; OUTPUT HANDLER 6.
                                ; (SKIP THE QUESTION MARK PROMPT.)
                                ; =================================

OPUTHDL6
                LDA #0          ; SET CONDITION 0.
                STA OPUTCOND
                BEQ DSPLYINP    ; ALWAYS.
                                ; GO CONDITIONALLY DISPLAY INPUT.


                                ; =================================
                                ; FINISH OFF THE RUN COMMAND
                                ; (BECAUSE IT WAS INTERRUPTED TO
                                ; DO A LOAD.)
                                ; =================================

FINSHRUN
                IF !DOS31
                LDA #0          ; ZERO OUT THE RUN INTERRUPT FLAG.
                STA RUNTRUPT
                JSR INITIOHK    ; RESET I/O HOOKS 2 PT AT DOS.
                JMP RUNFPINT    ; JUMP BACK INTO THE RUN COMMAND
                                ; TO FINISH IT OFF.
                                ; ************* NOTE ************
                                ; * THE STACK WAS RESET SO WE
                                ; * RETURN AT THE CORRECT LEVEL.
                                ; *******************************
                ENDIF


                                ; ======================================
                                ; COMMON ROUT'N TO FINISH OFF MOST DOS
                                ; CMDS.  THE WRITE & READ CMD HNDLRS
                                ; RTN HERE.  CMDWRITE ($A510) SETS
                                ; OPUTCOND=5 BEFORE RETURNING.
                                ; CMDREAD ($A51B) RTNS WITH CONDNFLG=1.
                                ; ======================================

FINSHCMD        LDA BUF200      ; GET FIRST CHAR IN BUF.
                CMP DCTRLCHR    ; WAS CMD DONE VIA DOS'S CTRL CHR?
                BEQ DSPLYCMD    ; YES.


                                ; CANCEL CMD BY REPLACING THE CHAR
                                ; WITH A <CR> & THEN FALL THRU TO
                                ; CONTINUE THE EXIT SEQUENCE.
                IF DOS31
                LDA #$A0
                STA BUF200
                LDA #CR
                STA BUF200+1
                ELSE
                LDA #CR        ; <CR>
                STA BUF200      ; SET 200: 8D.
                ENDIF

                LDX #0          ; SET INDEX TO START OF INPUT BUF.
                STX XSAVED


                                ; ---------------------------------------
                                ; DISPLAY CHARACTER OUPUT CONDITIONALLY.
                                ; (THAT IS, PREPARE TO SEND THE CHAR
                                ; TO THE OUTPUT DEVICE.)
                                ; ---------------------------------------

DSPLYCMD        LDA #%01000000  ; SET BIT6 TO SEE IF USING "MON C"
                BNE DSPLYCHR    ; ALWAYS.
DSPLYOUT        LDA #%00010000  ; SET BIT4 TO SEE IF USING "MON O"
                BNE DSPLYCHR    ; ALWAYS.
DSPLYINP        LDA #%00100000  ; SET BIT5 TO SEE IF USING "MON I"
DSPLYCHR        AND CIOCUMUL    ; TEST FLAG:  SEE IF SHOULD DSPLY.
                BEQ DOSEXIT     ; NO DISPLAY -SPECIFIC BIT WAS OFF
                                ; MON/NOMON CLR/SET SPECIFIC BITS.


                                ; ---------------------------------
                                ; DISPLAY THE CHARACTER.
                                ; ---------------------------------

DSPLYALL        JSR RESTOREG    ; RESTORE (A), (Y) & (X) REGS.
                JSR GODSPLY     ; OUTPUT  CHR VIA TRU OUTPUT HNDLR
                IF !DOS31
                STA ASAVED      ; SAVE (A), (Y) & (X) REGS.
                STY YSAVED
                STX XSAVED
                ENDIF


                                ; =================================
                                ; ROUTINE TO EXIT DOS.
                                ; POINT THE I/O HKS AT DOS AND
                                ; RESET THE STACK POINTER.
                                ; ---------------------------------

DOSEXIT         JSR INITIOHK    ; RESET I/O HKS TO POINT TO DOS.
                LDX STKSAVED    ; RETRIEVE SAVED STACK POINTER.
                TXS
RESTOREG        LDA ASAVED      ; RESTORE (A), (Y) & (X) REGS.
                LDY YSAVED
                LDX XSAVED
                IF !DOS31
                SEC             ; WHY?????
                ENDIF
                RTS             ; ************ NOTE *************
                                ; * IF THIS RTS IS ENCOUNTERED
                                ; * VIA A FALL THRU FROM DOSEXIT,
                                ; * THEN RTN TO THE ROUTINE THAT
                                ; * CALLED THE ROUTINE THAT
                                ; * CONTAINED THE "JSR PREP4DOS"
                                ; * INSTRUCTION.
                                ; *******************************


                                ; =================================
                                ; CHARACTER OUTPUT HANDLER.
                                ; =================================

GODSPLY         JMP (CSW)       ; USUALLY POINTS 2 THE TRUE OUTPUT
                                ; HANDLER (COUT1, $FDF0 IF SCRN).

CRVIADOS
                IF DOS31
                BIT CIOCUMUL
                BVC   L1F6E
                ENDIF

                LDA #CR        ; <CR>.

                IF DOS31
                JSR GODSPLY
L1F6E           RTS
                ELSE
                JMP GODSPLY     ; USUALLY PRINTS A <CR> THRU THE
                                ; OUTPUT HANDLER (COUT1). HOWEVER,
                                ; WHEN ACCESSED BY RUNFPINT($A4DC)
                                ; DURING A COLDSTART, GOES INTO
                                ; DOS'S OUTPUT INTERCEPT ROUTINE
                                ; (OPUTINCP, $9EBD).
                ENDIF


                                ; =================================
                                ; DOS'S COMMAND PARSING ROUTINE.
                                ; =================================

PARSECMD        LDY #$FF        ; INITIALIZE INDEX TO CMD TXT TBL.
                STY NDX2CMD
                INY             ; (Y) = 0.
                STY NEXTCMD     ; SIGNAL NO PENDING COMMAND FOR
                                ; NEXT TIME AROUND.
GETCHR1         INC NDX2CMD     ; INDEX TO COMMAND TEXT TABLE.
                                ; (0 ON ENTRY.)
                LDX #0          ; INITIALIZE INDEX TO INPUT CHARS.
                PHP             ; SAVE STATUS (WITH Z=1) ON STK.
                                ; (DFLT STATUS, ASSUME CHRS MTCH.)
                LDA BUF200,X    ; GET FIRST CHAR IN INPUT BUFFER.
                CMP DCTRLCHR    ; IF IT IS NOT DOS'S CTRL CHAR,
                BNE SAVLINDX    ; SET LINE INDEX TO 0.  IF IT IS
                INX             ; DOS'S CTRL CHAR, SET INDEX TO 1
                                ; SO SKIP CTRL CHAR.

                                ; DOES THE INPUT CHAR EQUAL A CHAR
                                ; IN DOS'S CMD TEXT TABLE (CMDTXTBL)?
                                ; (NOTE:  LAST CHAR IN @ CMD IS NEGATIVE
                                ; ASCII, REST OF CHARS IN A GIVEN CMD
                                ; ARE POSITIVE ACSII.)

SAVLINDX        STX NDX2INBF    ; SAVE INDEX TO INPUT BUF.
INVSCMD         JSR PURGECMD    ; GET CHAR FROM INPUT BUFFER
                                ; (IGNORE SPACES).
                AND #$7F        ; STRIP HI BIT OFF OF CHAR.
                EOR CMDTXTBL,Y  ; DOES INPUT CHAR MATCH A CMD CHR?
                                ; IF POS INPUT CHAR/POS ASCII CMD
                                ; CHAR MATCH, THEN (A) = 0.
                                ; IF POS INPUT CHR / NEG ASCII CMD
                                ; CHAR MATCH, THEN (A) = $80.
                INY             ; KICK UP INDEX TO NEXT CHAR IN
                                ; THE COMMAND TEXT TABLE.
                ASL A           ; IF POS/POS MATCH (A)=0 & (C)=0.
                                ; IF POS/NEG MTCH (A)=$80 & (C)=1.
                BEQ CKIFCHRS    ; CHAR MATCHED SO GO CHK CARRY.

                                ; INPUT CHARS < > TEXT CMD CHAR.

                PLA             ; PULL SAVED STATUS OFF STK TO CLR
                                ; Z-FLG (CAUSE IF SAVED STATUS
                                ; HAD (Z) OR (C) = 1, THEN NEW (A)
                                ; WILL HAVE AT LEAST 1 BIT SET SO
                                ; THEN (A) < > 0.)
                PHP             ; PUSH STATUS ON STK (WITH Z-FLAG
                                ; CLR & (C) CONDITIONED AS PER
                                ; ABOVE "ASL" INSTRUCTION.

                                ; SEE IF THER ARE ANY MORE CHARS TO
                                ; CHECK IN THE TEXT OF A GIVEN CMD.

CKIFCHRS        BCC INVSCMD     ; IF (C)=0, MORE CHARS TO CHK IN
                                ; GIVEN CMD LISTED IN TABLE.
                                ; IF (C)=1, CHKD LAST CHR IN TBL.

                                ; FINISHED CHECKING TEXT
                                ; OF A PARTICULAR COMMAND.

                PLP             ; GET STATUS OFF STACK.

                                ; DID COMMAND MATCH?

                BEQ PRPDOCMD    ; IF LAST CHR MATCHED, THEN ENTIRE
                                ; CMD MATCHED SO GO PROCESS CMD.

                                ; CHECK IF SEARCHED ENTIRE TABLE.

                LDA CMDTXTBL,Y  ; LAST CHAR DIDN'T MATCH, SO NOT
                BNE GETCHR1     ; CORRECT CMD.  THERE4, GO CHK IF
                                ; NEXT CHAR BYTE IN TABLE IS $00.
                                ; IF NOT $00, GO CHK REMAINING
                                ; CMDS IN TBL.  IF IT IS $00, THEN
                                ; DONE ENTIRE TBL & NO CMDS MTCHD.

                                ; EITHER AT END OF TABLE AND NO
                                ; CMDS MATCHED OR ELSE DETECTED A
                                ; BSAVE CMD WITH NO ACCOMPANYING
                                ; A- OR L- PARAMETERS.

                                ; CHECK IF DOS'S CTRL CHAR WAS USED.

CKIFCTRL        LDA BUF200      ; IS 1RST CHAR IN THE INPUT BUFFER
                CMP DCTRLCHR    ; EQUAL TO DOS'S CTRL CHAR?
                BEQ CHKIFCR     ; YES.
                JMP DSPLYALL    ; NO -GO DSPLY CHR & THEN XIT DOS.

                                ; WAS DOS'S CTRL CHAR THE ONLY CHAR ON LINE?

CHKIFCR         LDA BUF200+1    ; GET 2ND BYTE IN INPUT BUFFER.
                CMP #CR        ; WAS IT A <CR>?
                BNE PRSYNERR    ; NO -NOT SIMPLY DEALING WITH CMD
                                ; CANCELLING DOS CTRL CHR AND <CR>
                                ; SO GO ISSUE A SYNTAX-ERROR MSG.
                JSR RESTAT0     ; YES - SET CONDITION 0.
                JMP DSPLYCMD    ; GO DISPLAY <CR>.
PRSYNERR        JMP SYNTXERR    ; EITHER A CTRL CHR DENOTED THAT A
                                ; DOS CMD WAS WANTED & NO MATCHING
                                ; CMD WAS FOUND (ELSE DETECTED A
                                ; BSAVE CMD WITH NO A- OR L-PARMS)
                                ; SO GO GIVE DOS'S SYNTAX ERR MSG.


                                ; ========================================
                                ; PREPARE TO EXECUTE THE DOS COMMAND.
                                ; ON ENTRY - A DOS CMD WAS PARSED.
                                ; - NDX2CMD = COMMAND CODE.
                                ; - I/O HKS PT TO TRUE HANDLERS.
                                ; NOTE THAT THIS ROUTINE MAKES EXTENSIVE
                                ; USE OF A TABLE (CMDATTRB, $A909-$A940)
                                ; WHICH CONTAINS AN ENCODED LIST OF THE
                                ; ATTRIBUTES ASSOCIATED WITH @ COMMAND.
                                ; ========================================

PRPDOCMD
                IF DOS31
                LDA NDX2CMD
                ASL A
                STA NDX2CMD
                TAY
                ELSE
                ASL NDX2CMD     ; DOUBLE INDEX CAUSE 2 BYTES/ADDR
                LDY NDX2CMD     ; IN TABLE OF DOS CMD ENTRY PTS.
                JSR CKBSCRUN    ; CHECK IF BASIC IS RUNNING A PGM:
                BCC CHKIFRUN    ; (C)=0= BASIC RUNNING.
                                ; (C)=1= BASIC NOT RUNNING.

                                ; USING IMMEDIATE MODE, SO NOW CHK
                                ; IF CMD IS LEGAL IN THAT MODE.

IMMED           LDA #%00000010  ; CHK BIT1 OF CMDATTRB TO SEE IF
                AND CMDATTRB,Y  ; CMD IS LEGAL IN THAT MODE.
                BEQ CHKIFRUN    ; BRANCH IF LEGAL.
NODIRCMD        LDA #15         ; SET RETURN CODE TO SIGNAL THAT
                JMP ERRHNDLR    ; WE GOT A NOT-DIRECT-COMMAND ERR.

                                ; RUNNING PROGRAM OR ELSE COMMAND
                                ; COMPLIES WITH IMMEDIATE MODE.

CHKIFRUN        CPY #6          ; CHECK TO SEE IF CMD WAS A "RUN".
                BNE TST4NAME    ; BRANCH IF NOT.
                STY PROMPT      ; PUT AN $06 IN PROMPT IF COMMAND
                                ; WAS A "RUN".

                                ; CHECK TO SEE IF A FILENAME
                                ; IS APPLICABLE TO THE COMMAND.
                ENDIF

TST4NAME        LDA #%00100000  ; BIT5 = 1 IF FILENAME APPLICABLE.
                AND CMDATTRB,Y
                BEQ FNOTAPPL    ; BRANCH IF NAME NOT APPLICABLE.
                                ; (EX. CMDS: CATALOG, PR#, IN#,
                                ; MON, NOMON, MAXFILES, FP & INT.)

                                ; FILENAME APPLICABLE TO CMD ISSUED
                                ; SO BLANK OUT FILENAME BUFFERS IN
                                ; ANTICIPATION OF RECEIVING NAME.

FNXPCTD         JSR BLNKFNBF    ; BLANK BOTH 1RST & 2ND NAME BUFS.
                PHP             ; SAVE STATUS (Z-FLAG=1) ON STK.
                                ; NOTE:  Z-FLAG USED TO SIGNAL IF
                                ; DEALING WITH PRIMARY OR
                                ; SECONDARY NAME BUFFERS.
FNAMCHR1        JSR PURGECMD    ; GET 1RST CHAR IN NAME. (IGNORE
                                ; LEADING SPACES.)
                BEQ DONEFN      ; GOT "," OR <CR> - CHK IF DONE
                                ; (CAUSE THESE NOT LEGAL 4 NAME).

                                ; CHK IF CHAR IS LEGAL TENDER FOR NAME.
                                ; (KNOW IT WASN'T A <SPC>, "," OR <CR>
                                ; BUT IT STILL MAY NOT BE LEGAL.)

                ASL A           ; (C) = HI BIT OF CHAR.
                BCC LGLFNCHR    ; IF INV OR FLSH, OK FOR NAME.
                                ; BUT, NOTE THAT THEY CAN ONLY BE
                                ; POKED INTO INPUT BUF FROM A
                                ; RUNNING PRGM. (THIS TECHNIQUE IS
                                ; USED IN MANY PROTECT'N SCHEMES.)
                BMI LGLFNCHR    ; ACTUALLY TESTING BIT6 CAUSE JUST
                                ; DID AN "ASL".IF BYTE IS 11XXXXXX
                                ; (IE. $C0, NORMAL "@" OR GREATER)
                                ; CHAR IS LEGAL FOR NAME.
                JMP CKIFCTRL    ; GOT ILLEGAL NAME CHAR SO GO DO A
                                ; FEW MORE CHKS ON CTRL CHRS, ETC
                                ; & EXIT DOS. (WAS IT A CTRL CHAR,
                                ; NUMBER OR ONE OF THE FOLLOWING
                                ; NORMAL CHARS:SPC, !, ", #, $, %,
                                ; &, ', (, ), *, +, COMMA, -, ., /
                                ; :, ;, <, -, >, OR ?

                                ; CHAR IS LEGAL TENDER FOR NAME.

LGLFNCHR        ROR A           ; RESTORE NAME CHAR.
                JMP SVFNCHAR    ; SAVE IT IN 1RST OR 2ND NAME BUF.

                                ; PROCESS REST OF CHARS.

NCHR2ETC        JSR CMDCHAR     ; GET 2ND & SUB'QUENT CHRS IN NAME
                BEQ DONEFN      ; GOT A <CR> OR "," SO GO CHK IF
                                ; JUST FINISHED SECOND FILENAME.

                                ; PUT CHARS IN FILENAME BUF.

SVFNCHAR        STA PRIMFNBF,Y  ; (Y)=OFFSET FRM PRIMARY NAME BUF.
                INY
                CPY #60         ; TOTAL OF 60 CHARS IN BOTH BUFS.
                BCC NCHR2ETC    ; HAVEN'T HIT ",", EOL MARKER (IE.
                                ; <CR>) OR DONE ALL 60 CHARS YET.

                                ; DONE ALL 60 CHARS SO IGNORE REST
                                ; OF CHARS UNTIL GET "," OR <CR>.

PURGEFN         JSR CMDCHAR     ; GET NEXT CHAR.
                IF DOS31
                BEQ PURGEFN     ; BUG???
                ELSE
                BNE PURGEFN     ; NOT $00 YET SO GO GET NXT CHAR.
                ENDIF

                                ; JUST FINISHED NAME, SO CHK IF IT
                                ; WAS FIRST OR SECOND FILENAME.

DONEFN          PLP             ; RETRIEVE STATUS FROM STACK.
                BNE CKFN2LGL    ; Z-FLAG CLR SO DONE 2ND FILENAME.

                                ; JUST FINISHED FIRST NAME, SO SEE
                                ; IF A SECOND FILENAME IS REQUIRED.
                                ; (THAT IS, ARE WE DEALING WITH
                                ; THE "RENAME" COMMAND?)

FINFIRST        LDY NDX2CMD     ; GET INDEX ASSOC WITH CMD ISSUED.
                LDA #%00010000  ; CHK BIT 4 OF CMDATTRB TO SEE IF
                AND CMDATTRB,Y  ; 2ND NAME REQUIRED (IE RENAME ?).
                BEQ CKFN1LGL    ; 2ND NAME NOT APPLICABLE SO GO
                                ; & CHK 1RST NAME BUF.

                                ; SECONDARY FILENAME APPLICABLE SO
                                ; DEALING WITH "RENAME" COMMAND.

                LDY #30         ; (Y) = INDEX 2 START OF 2ND NAME.
                PHP             ; PUT STATUS ON STK (Z-FLG = 0) TO
                BNE FNAMCHR1    ; SIGNAL DEALING WITH 2ND NAME &
                                ; GO BACK TO GET ITS CHARS.
                                ; ALWAYS TAKE BRANCH.

                                ; DONE PROCESSING ASSOC WITH SECONDARY
                                ; FILENAME SO NOW CHK IF ANY OF THESE
                                ; CHARS WERE LEGAL & THERE4 STUCK IN
                                ; THE SECONDARY FILENAME BUFFER.

CKFN2LGL        LDA SCNDFNBF    ; CHK 1RST BYTE IN SECONDARY.
                CMP #SP         ; IF IT IS A <SPC>, THEN NO CHARS
                BEQ GOXITDOS    ; WERE GOOD & SO A 2ND NAME WAS
                                ; REQUIRED BUT NOT ISSUED,SO EXIT.

                                ; ONLY PRIMARY FILENAME APPLICABLE
                                ; SO CHK IF WE GOT ANY CHRS THAT
                                ; WERE LEGAL & THERE4 PUT IN THE
                                ; PRIMARY FILENAME BUFFER.

CKFN1LGL        LDA PRIMFNBF    ; IF 1RST CHAR IN BUF IS A <SPC>,
                CMP #SP         ; A LEGAL PRIMARY FILENAME WAS NOT
                                ; ISSUED SO FALL THRU TO SEE IF IT
                                ; WAS REQUIRED OR OPTIONAL.
                BNE DFLTPRSD    ; BRANCH IF GOT PRIMARY FILENAME.

                                ; PRIMARY FILENAME WAS NOT ISSUED
                                ; SO CHK IF IT WAS REQUIRED OR OPTIONAL.
                                ; (IE. WAS CMD A CLOSE, LOAD, SAVE OR RUN?)

                LDY NDX2CMD     ; GET INDEX ASSOC WITH CMD.
                LDA #%11000000  ; CHK BITS 7 & 6 TO SEE IF A NAME
                AND CMDATTRB,Y  ; IS REQUIRED.
                BEQ GOXITDOS    ; A PRIMARY NAME IS REQUIRED BUT
                                ; WAS NOT ISSUED, SO GO EXIT DOS.

                                ; WAS COMMAND A "CLOSE"?

                BPL DFLTPRSD    ; NAME WASN'T PRESENT, BUT IS NO
                                ; BIG DEAL CAUSE IT WAS OPTIONAL.
GOXITDOS        JMP CKIFCTRL    ; CMD WAS LOAD, RUN OR SAVE WHICH
                                ; CAN ALSO BE BASIC COMMANDS.


                                ; ======================================
                                ; BLANK OUT BOTH PRIMARY ($AA75-$AA92)
                                ; AND SECONDARY ($AA93-$AAB0) FILENAME
                                ; BUFFERS.
                                ; ======================================

BLNKFNBF
                IF DOS31
                LDA #0
                ENDIF
                LDY #60         ; 30 BYTES IN EACH BUFFER.
BLNK1RST        LDA #SP         ; BLANK.
STORBLNK        STA PRIMFNBF-1,Y
                DEY
                BNE STORBLNK    ; MORE BYTES TO BLANK OUT.
                RTS


                                ; ===================================
                                ; FILENAME NOT APPLICABLE TO COMMAND
                                ; (EX. CATALOG, MON, NOMON, FP, INT,
                                ; PR#, IN# OR MAXFILES).
                                ; ===================================

FNOTAPPL        STA PRIMFNBF    ; PUT A $00 IN THE FIRST BYTE OF
                                ; THE PRIMARY FILENAME BUFFER.
                                ; ************* NOTE ************
                                ; * ALTHOUGH THIS SEEMS LIKE A
                                ; * BEGNIN INSTRUCTION, IT IS
                                ; * IMPORTANT BECAUSE IT IS LATER
                                ; * USED 2 INSURE THAT A MATCHING
                                ; * DOS FILENAME BUF WON'T BE
                                ; * FOUND WHEN THE GETBUFF ROUT'N
                                ; * ($A764) IS EVENTUALLY USED BY
                                ; * THE VARIOUS DOS CMDS.  AS A
                                ; * RESULT, THE HIGHEST NUMBERED
                                ; * (LOWEST IN MEMORY) FREE DOS
                                ; * FILENAME BUFFER WILL BE
                                ; * SELECTED.
                                ; *******************************

                                ; COMMAND DIDN'T REQUIRE A FILENAME
                                ; SO NOW CHK & SEE IF IT EXPECTS ANY
                                ; NUMERIC ARGUMENTS.  (IE. WAS IT PR#,
                                ; IN# OR MAXFILES CMD?)

                LDA #%00001100  ; TEST BITS 2 & 3 TO SEE IF IN#,
                AND CMDATTRB,Y  ; PR# OR MAXFILES NUMERIC
                                ; OPERAND IS EXPECTED.
                BEQ DFLTPRSD    ; BRANCH IF NOT EXPECTED.

                                ; IN#,PR# OR MAXFILES NUMERIC
                                ; OPERAND EXPECTED.

INPRMAX         JSR CNVRTASC    ; CONVERT ASCII NUMBER ARGUMENT TO
                                ; HEX WITH RESULT IN A5L/H.
                IF DOS31
                BCS GOXITDOS
                ELSE
                BCS TOSYNTX     ; CHR NOT #, EXIT WITH SYNTAX ERR.
                ENDIF
                TAY             ; (Y) = HI BYTE OF CONVERTED CHAR.
                IF DOS31
                BNE GOXITDOS
                ELSE
                BNE ARGRNGER    ; RANGE ERROR - CAUSE VALUE > 255.
                ENDIF
                CPX #17
                IF DOS31
                BCS GOXITDOS
                ELSE
                BCS ARGRNGER    ; RANGE ERROR CAUSE IF MAXFILES OR
                                ; IN# OR PR# ARGUMENT > 16, THEN
                                ; VALUE TOO LARGE.
                ENDIF

                                ; WAS COMMAND A PR# OR IN#?

                LDY NDX2CMD     ; CHK TO SEE IF A SLOT VALUE IS
                LDA #%00001000  ; APPLICABLE TO THE COMMAND.
                AND CMDATTRB,Y
                BEQ MAXFMIN     ; SLOT VAL NOT APPLICABLE SO MUST
                                ; BE DEALING WITH MAXFILES.

                                ; COMMAND WAS PR# OR IN# SO NOW CHECK
                                ; IF SLOT VALUE IS TOO LARGE OR NOT.
                                ; (LEGAL RANGE IS 0 TO 7.)

                CPX #8          ; TOO LARGE?
                BCS GOXITDOS    ; YES -BAIL OUT.
                BCC DFLTPRSD    ; NO -SET DFLTS & CONTINUE PARSING

                                ; CHECK MINIMUM VALUE FOR MAXFILES.
                                ; (LEGAL RANGE IS 1 TO 16.)

MAXFMIN         TXA
                IF DOS31
                BEQ GOXITDOS
                ELSE

                BNE DFLTPRSD    ; NOT 0, SO OKAY.

                                ; ARGUMENT FOR MAXFILES, SLOT, IN#
                                ; OR PR# WERE ILLEGAL.

ARGRNGER        LDA #2          ; SET RETURN CODE FOR RANGE ERROR.
                JMP ERRHNDLR    ; GO HANDLE THE ERROR.

TOSYNTX         JMP SYNTXERR    ; EXIT VIA SYNTAX ERROR.
                ENDIF
                                ; INITIALIZE CUMLOPTN & PARSED TABLE.

DFLTPRSD        LDA #0
                STA CUMLOPTN    ; SET CUMLOPTN TO DEFAULT VAL OF 0
                                ; TO ASSUME NO OPTIONS ISSUED.
                STA MONPRSD     ; SET DEFAULT VALS IN PARSED TBL.
                IF DOS31
                STA VOLPRSD2    ; THAT IS ASSUME THAT:
                STA LENPRSD+1   ; - C, I, O WEREN'T ISSUED.
                STA TEMPBYT
                ELSE
                STA VOLPRSD    ; THAT IS ASSUME THAT:
                STA LENPRSD     ; - C, I, O WEREN'T ISSUED.
                STA LENPRSD+1   ; - VOL # AND LENGTH ARE 0.
                JSR ZEROPTCH    ; SET TEMPBYT & BYTPRSD TO 0 DFLTS
                ENDIF
                LDA NDX2INBF    ; IRREL, MIGHT AS WELL BE 3 "NOP"S
                                ; (MADE OBSOLETE BY ZEROPTCH).

                                ; DO MORE PARSING OF COMMAND LINE.
                                ; (IGNORE ANY COMMAS OR SPACES.)

NXCMDCHR        JSR PURGECMD    ; GET NEXT CHAR.
                BNE CHKOPTNS    ; IF IT ISN'T A <CR> OR COMMA THEN
                                ; MAYBE ITS AN OPTION, SO TAKE
                                ; BRANCH TO CHECK IT OUT.
                CMP #CR        ; WAS IT A <CR>?
                BNE NXCMDCHR    ; NO - SO MUST HAVE BEEN A COMMA.
                                ; BRANCH BACK TO IGNORE COMMAS.

                                ; GOT A <CR> (IE. EOL MARKER), SO NOW
                                ; DONE PARSING & MUST MAKE SURE THAT
                                ; THE CUMMULATIVE RECORD OF THE OPTIONS
                                ; WE ENCOUNTERED IS APPLICABLE TO THE CMD.

                LDX NDX2CMD
                LDA CUMLOPTN    ; CHK IF OPTIONS ARE LEGAL.
                ORA CMDATTRB+1,X
                EOR CMDATTRB+1,X
                BNE GOXITDOS    ; ILLEGAL SO EXIT.

                                ; CUMMULATIVE RECORD OF OPTIONS CAN
                                ; LEGALLY BE ASSOCIATED WITH COMMAND.

                LDX TEMPBYT     ; TEMPBYT = 0 AS SET IN ZEROPTCH.
                IF DOS31
                BEQ TORESTAT0
                ELSE
                BEQ TODOSCMD    ; ALWAYS.
                ENDIF

                                ; MEANINGLESS INSTRUCTIONS (MADE
                                ; OBSOLETE BY INCLUSION OF ZEROPTCH).

                STA TEMPBYT
                STX NDX2INBF
                BNE NXCMDCHR

                                ; CHECK IF CHAR IS AN OPTION.
                                ; (IE. A, B, R, L, S, D, V, C, I, O.)

CHKOPTNS        LDX #10
CKNXOPTN        CMP OPTNTXT-1,X
                BEQ OPTNOK      ; FOUND AN OPTION.
                DEX
                BNE CKNXOPTN    ; HAVEN'T CHKD ALL OPTIONS YET.
TOTOSYNT
                IF DOS31
                BEQ TODOSCMD
                ELSE
                BEQ TOSYNTX     ; COULDN'T FIND A MATCH.
                                ; (SYNTAX ERR - CHAR NOT OPTION.)
                                ; GOT AN OPTION SO CHK IF IT WAS
                                ; "C", "I" OR "O".  (IE. IS A
                                ; NUMERIC ARGUMENT EXPECTED?)
                ENDIF

OPTNOK          LDA OPTNISSD-1,X
                BMI CIOPTNS     ; IF HI BIT=0, THEN OPTION WAS A
                                ; "C", "I" OR "O" AND NO NUMERIC
                                ; ARGUMENT IS NEEDED.

                                ; UPDATE CUMLOPTN TO REFLECT
                                ; THE LATEST OPTION.

                ORA CUMLOPTN
                STA CUMLOPTN

                                ; NOW CHK IF NUMERIC ARGUMENT THAT
                                ; WAS ISSUED WITH OPTION IS LEGAL.

                DEX             ; REDUCE COUNTER THAT WAS KICKED UP
                                ; IN ANTICIPATION OF MORE CHARS
                                ; IN THE CMDCHAR ROUTINE.
                STX NDX2OPTN    ; SAVE INDEX TO OPTION.
                JSR CNVRTASC    ; CONVERT ASCII # TO HEX.

                                ; WAS IT A NUMERIC CHARACTER?

                IF DOS31
                BCS TODOSCMD
                ELSE
                BCS TOSYNTX     ; NO - SYNTAX ERROR.
                ENDIF

                                ; CHARACTER WAS NUMERIC.

                LDA NDX2OPTN    ; RETRIEVE INDEX TO OPTION.
                ASL A           ; TIMES 4 CAUSE GOING TO CHK MIN
                ASL A           ; & MAX VALS OF LEGAL RANGES ASSOC
                                ; WITH OPTION (2 BYTES @).
                TAY             ; (Y) = INDEX TO LEGAL RANGE TBL.

                                ; CHECK IF ARGUMENT IS TOO LARGE.

                LDA A5H         ; GET HI BYTE OF ARGUMENT.
                BNE CKMAXVAL    ; BRANCH IF NOT 0.
                LDA A5L         ; HI BYTE WAS 0 SO CHK LOW BYTE.
                CMP OPTNRNG,Y
                IF DOS31
                BCC TODOSCMD
                ELSE
                BCC ARGRNGER    ; RANGE ERR -ARGUMENT < MIN LEGAL.
                ENDIF

                                ; CHECK IF ARGUMENT < = MAX LEGAL PLUS 1.

                LDA A5H
CKMAXVAL        CMP OPTNRNG+3,Y ; CMP HI BYTE TO MAX LEGAL VAL.
                BCC SVALOPTN    ; LESS THAN MAX SO ARGUMENT OK.
TOARGRNG
                IF DOS31
                BNE TODOSCMD
                ELSE
                BNE ARGRNGER    ; ARGUMENT > MAX LGL, SO RNG ERR.
                ENDIF
                LDA A5L         ; NOW CHK IF LOW BYTE OF ARGUMENT
                CMP OPTNRNG+2,Y ; COMPLIES TO MAX LEGAL LOW BYTE.
                BCC SVALOPTN    ; ARGUMENT IS LEGAL.
                IF DOS31
                BNE TODOSCMD
                ELSE
                BNE TOARGRNG    ; ARGUMENT IS ILLEGAL.
                ENDIF

                                ; SAVE THE OPTION VALUE IN THE PARSED TABLE.

SVALOPTN        LDA TEMPBYT     ; OBSOLETE, TEMPBYT WAS SET TO 0
                BNE NXCMDCHR    ; IN ZEROPTCH SO ALWAYS FALL THRU.
                TYA             ; (Y)-->(A)=INDEX TO OPTION RNGS.
                LSR A           ; DIVIDE BY 2 CAUSE @ OPTION RANGE
                                ; TABLE HAS 4 BYTES, BUT @ PARSED
                                ; VAL ENTRY IS ONLY 2 BYTES LONG.
                TAY             ; PUT INDEX 2 PARSED TABLE IN (Y).
                LDA A5H         ; STORE ARGUMENT IN PARSED TBL.
                STA VOLPRSD+1,Y
                LDA A5L
                STA VOLPRSD,Y

                                ; GO SEE IF ANY MORE OPTIONS ARE
                                ; PRESENT ON THE COMMAND LINE.

TONXOPTN        JMP NXCMDCHR

                                ; OPTION WAS A "C", "I" OR "O".

CIOPTNS         PHA             ; PUT (A) = OPTNISSD ON STK.
                LDA #%10000000  ; UPDATE CUMLOPTN TO SIGNAL THAT
                ORA CUMLOPTN    ; "C", "I" OR "O" OPTIONS ISSUED.
                STA CUMLOPTN
                PLA             ; GET (A) = OPTNISSD BACK FRM STK.
                AND #%01111111  ; TURN HI BIT OFF.
                ORA MONPRSD     ; UPDATE MONPRSD IN PARSED TABLE.
                STA MONPRSD
                BNE TONXOPTN    ; GO SEE IF ANY MORE OPTIONS.
                IF !DOS31
                BEQ TOTOSYNT    ; IRRELEVANT.
                ENDIF


                                ; =================================
                                ; FINAL PROCESSING OF DOS COMMAND.
                                ; =================================

TODOSCMD
                IF DOS31
                JMP CKIFCTRL
TORESTAT0       JSR RESTAT0     ; RESET CONDITION TO 0.  THAT IS,
                                ; SET CONDNFLG AND OPUTCOND = 0.
                JSR CLRFMPRM    ; CLEAR OUT THE FM PARAMETER LIST
                                ; SO WE CAN CUSTOMIZE IT IN
                                ; ACCORDANCE WITH THE SPECIFIC DOS
                                ; COMMAND HANDLER CALLED.
                ENDIF
                JSR DODOSCMD    ; GO DO THE DOS COMMAND.


                                ; ---------------------------------------
                                ;
                                ; - MOST, BUT NOT ALL, DOS CMDS RTN HERE.
                                ; - IF AN ERROR IS ENCOUNTERED, EXECUTION
                                ; EXITS DOS'S ERROR HANDLER VIA RESTART
                                ; ($D43C) OR BASIC'S ERROR-HANDLING
                                ; ROUTINE (BSCERHLR, $D865).
                                ; - FP EXITS BACK INTO DOS'S COLDSTART
                                ; ROUTINE (DOSCOLD, $9D84).
                                ; - INT & CHAIN GO INTO INTEGER BASIC IF
                                ; THE INTEGER LANGUAGE IS AVAILABLE.
                                ; - THE WRITE & READ CMDS RETURN TO THE
                                ; FINSHCMD ROUTINE ($9F83) SHOWN BELOW.
                                ; - BLOAD RTNS TO AFTRCMD IF IT WAS NOT
                                ; CALLED BY THE BRUN CMD.  OTHERWISE,
                                ; BLOAD RTNS TO THE BRUN CMD HNDLR AT
                                ; $A391.
                                ; - BRUN EXECUTES THE BINARY FILE BEFORE
                                ; RETURNING. IF THE BRUNED PGM PERFORMED
                                ; ANY INPUT OR OUTPUT, OR IF THE BINARY
                                ; FILE WAS BRUN WITH MON IN EFFECT, THE
                                ; PRGM GETS HUNG UP IN AN ININITE LOOP.
                                ; (SEE FORMATTED DISASSEMBLY OF THE CMD
                                ; PARSING & PROCESSING ROUTINES FOR
                                ; FURTHER DETAILS.)
                                ; - THE LOAD CMD GOES INTO APPLESOFT (AT
                                ; $D4F2) TO RESET THE PRGM LINK PTRS
                                ; AND THEN GOES ON TO THE RESTART
                                ; ROUTINE ($D43C).  IF THE LOAD CMD WAS
                                ; CALLED FROM A RUN, EXECUTION JUMPS
                                ; BACK INTO THE RUN CMD HNDLR AT
                                ; RUNFPINT ($A4DC).
                                ; - THE RUN CMD EXITS INTO APPLESOFT AT
                                ; STKINI ($D683) & EVENTUALLY RTNS TO
                                ; THE RESTART ROUTINE ($D43C).
                                ;
                                ; -----------------------------------------

AFTRCMD         JMP FINSHCMD



                                ; =================================
                                ; DO THE DOS COMMAND.
                                ; =================================

DODOSCMD
                IF !DOS31
                JSR RESTAT0     ; RESET CONDITION TO 0.  THAT IS,
                                ; SET CONDNFLG AND OPUTCOND = 0.
                JSR CLRFMPRM    ; CLEAR OUT THE FM PARAMETER LIST
                                ; SO WE CAN CUSTOMIZE IT IN
                                ; ACCORDANCE WITH THE SPECIFIC DOS
                                ; COMMAND HANDLER CALLED.
                ENDIF
                LDA NDX2CMD     ; GET (A) = INDEX TO COMMAND.
                TAX             ; (X) = INDEX 2 TBL OF ENTRY PTS.
                LDA CMDTBL+1,X  ; GET ADR-1 OF THE CMD'S ROUTINE &
                PHA             ; PUT IT ON STACK (HI BYTE 1RST).
                LDA CMDTBL,X
                PHA
                RTS             ; DO A "STK JMP" TO PROCESS CMD.


                                ; =================================
                                ; GET CHAR FROM INPUT BUFFER, SET
                                ; Z-FLAG IF <CR> OR COMMA.
                                ; =================================

CMDCHAR         LDX NDX2INBF    ; (X) = INDEX TO INPUT BUFFER.
                IF FRANKLIN
                JSR FRANK
                ELSE
                LDA BUF200,X    ; GET NEXT CHAR.
                ENDIF
                CMP #CR        ; IS IT A <CR>?
                BEQ CMDCHRTS    ; YES.
                INX             ; (X)=INDEX 4 NXT ANTICIPATED CHR.
                STX NDX2INBF
                CMP #","|0x80   ; COMMA?
CMDCHRTS        RTS             ; EXIT WITH Z-FLAG CONDITIONED.
                                ; Z=1 IF CHAR IS A <CR> OR COMMA.


                                ; ========================================
                                ; GET 1RST NON-SPACE CHAR FROM INPUT BUF.
                                ; SET Z-FLAG IF IT IS <CR> OR ",".
                                ; ========================================

PURGECMD        JSR CMDCHAR     ; GET 1RST CHAR.
                BEQ CMDCHRTS    ; EXIT IF <CR> OR COMMA.
                CMP #SP         ; SPACE?
                BEQ PURGECMD    ; YES - IGNORE LEADING SPACES.
                RTS


                                ; =================================
                                ; CLEAR OUT THE FM PARAMETER LIST.
                                ; - SO WE CAN CUSTOMIZE IT IN
                                ; ACCORANCE WITH THE SPECIFIC
                                ; DOS COMMAND HANDLER CALLED.
                                ; =================================

CLRFMPRM        LDA #0
                LDY #$16        ; 22 BYTES TO ZERO OUT.
ZFMPARM         STA FMPRMLST-1,Y
                                ; STORE ZERO BYTE.
                DEY             ; $16 --> $01, EXIT AT $00.
                BNE ZFMPARM
                RTS


                                ; ======================================
                                ; CONVERT ASCII TO HEX OR DEC.
                                ; ON ENTRY: NDX2INBF INDEXES INPUT BUF.
                                ; ON EXIT: A5L/H AND (X,A) = LOW/HI
                                ; BYTES OF RESULT.
                                ; (C) = 0 = GOOD CONVERSION.
                                ; (C) = 1 = INVALID CHARS.
                                ; ======================================

CNVRTASC        LDA #0          ; ZERO OUT LOC'S TO HOLD RESULT.
                STA A5L         ; LOW BYTE OF RESULT.
                STA A5H         ; HI BYTE OF RESULT.
                JSR PURGECMD    ; GET 1RST NON-SPACE CHAR.
                PHP             ; SAVE STATUS (Z-FLAG) ON STK.
                                ; (IF <CR> OR COMMA, Z-FLAG = 1.)

                                ; CHK TO SEE IF WANT TO CONVERT
                                ; ASCII TO HEX OR ASCII TO DEC.

                CMP #"$"|0x80   ; IS HEX SYMBOL PRESENT?
                BEQ ASC2HEX     ; YES - BRANCH FOR ASCII TO HEX.


                                ; --------------------------------
                                ; ASCII TO DEC CONVERSION WANTED.
                                ; --------------------------------

                PLP             ; GET STATUS DENOTING IF CR OR ","
                JMP CKIFDONE    ; BEGIN DEC CONVERSION OF 1RST CHR

ASC2DEC         JSR PURGECMD    ; GET 2ND & SUBSEQUENT ASCII CHARS
                                ; TO BE CONVERTED TO DECIMAL.
                                ; (IGNORE SPACES.)

CKIFDONE        BNE SUBTRASC    ; BRANCH IF NOT <CR> OR COMMA.
                                ; (ALWAYS FALL THRU IF ACCESSED FRM
                                ; THE HEX CONVERSION ROUTINE.)

                                ; SUCCESSFUL CONVERSION - EXIT
                                ; WITH A5L/H AND (X,A) CONTAINING
                                ; LOW/HI BYTES OF RESULT.

                LDX A5L         ; RESULT LOW.
                LDA A5H         ; RESULT HI.
                CLC             ; (C)=0 TO SIGNAL GOOD CONVERSION.
                RTS             ; EXIT TO CALLER OF CNVRTASC.

                                ; CHECK VALIDITY OF ASCII CHARS FOR
                                ; REPRESENTATION OF DECIMAL NUMBERS.

SUBTRASC        SEC
                SBC #$B0        ; SUBTRACT ASCII "0".
                BMI NOTASCII    ; ERROR CAUSE < 0.
                CMP #$0A        ; DECIMAL 10.
                BCS NOTASCII    ; ERROR CAUSE > 9.

                                ; MULTIPLY RUNNING RESULT * 10
                                ; AND THEN ADD NEW DIGIT.

                JSR DOUBLE      ; GET RESULT * 2.
                ADC A5L
                TAX             ; (X) = LOW RESULT * 2 + NEW DIGIT
                LDA #0
                ADC A5H         ; ADD (C) TO HI BYTE OF RESULT.
                TAY             ; (Y) = HI BYTE OF RESULT*2 + (C).
                JSR DOUBLE      ; (A) = RESULT * 8.
                JSR DOUBLE
                TXA
                ADC A5L
                STA A5L         ; (RESULT*2+NEW DIGIT)+(RESULT*8).
                TYA
                ADC A5H         ; ADD (C) TO UPDATE HI BYTE.
                STA A5H
                BCC ASC2DEC     ; BRANCH IF # <65536.

                                ; ERROR - INVALID ASCII NUMBER.

NOTASCII        SEC             ; EXIT WITH (C)=1 TO SIGNAL ERROR.
                RTS             ; RETURN TO CALLER OF CNVRTASC.

                                ; MULTIPLY 2-BYTE RESULT TIMES 2.

DOUBLE          ASL A5L         ; "ROLL" HI & LOW BYTES AS A UNIT.
                ROL A5H         ; (PICK UP (C) IN HI BYTE.)
                IF DOS31
                BCS NOTASCII
                ENDIF
                RTS


                                ; ---------------------------------
                                ; CONVERT ASCII CHARS TO HEX.
                                ; ---------------------------------

ASC2HEX         PLP             ; THROW SAVED STATUS OFF STACK.
GETASCII        JSR PURGECMD    ; GET 1RST & SUBSEQUENT CHARS THAT
                                ; OCCUR AFTER THE HEX ("$") SYMBOL
                BEQ CKIFDONE    ; GO EXIT IF <CR> OR COMMA.

                                ; CHECK VALIDITY OF ASCII CHARS
                                ; FOR CONVERSION TO HEX.

                SEC
                SBC #$B0        ; SUBTRACT ASCII "0".
                BMI NOTASCII    ; ERROR CAUSE < 0.
                CMP #$0A
                BCC PRP2DUBL    ; VALID: 0 <--> 9.
                SBC #7          ; CHK HI RANGE OF HEX #'S.
                BMI NOTASCII    ; ERROR CAUSE > $09 AND < $0A.
                CMP #$10
                BCS NOTASCII    ; ERROR CAUSE > $0F.

                                ; MOVE RESULT IN A5L/H UP A NIBBLE
                                ; BY ROLLING IT AS A UNIT (IE. *16).

PRP2DUBL
                IF DOS31
                JSR DOUBLE      ; MULTIPLY RESULT * 2.
                JSR DOUBLE      ; MULTIPLY RESULT * 2.
                JSR DOUBLE      ; MULTIPLY RESULT * 2.
                JSR DOUBLE      ; MULTIPLY RESULT * 2.
                ELSE
                LDX #4          ; (X) = # OF TIMES TO DOUBLE UNIT.
TIMES2          JSR DOUBLE      ; MULTIPLY RESULT * 2.
                DEX
                BNE TIMES2      ; MORE MULTIPLICATION TO DO.
                ENDIF

                                ; MERGE HEX REPRESENTATION OF DIGIT
                                ; INTO LOW NIBBLE POS'N OF RESULT.
                                ;
                                ; NOTE BUG:  NO CHK IS MADE TO TRAP
                                ; NUMBERS > $FFFF.  IF TOO MANY #'S
                                ; ARE INPUT, ONLY THE LAST 4 DIGITS
                                ; ARE REFLECTED IN THE RESULT.

                ORA A5L
                STA A5L
                JMP GETASCII    ; GO GET NEXT CHAR TO CONVERT.


                                ; ==================================
                                ; PR# COMMAND HANDLER.
                                ; ==================================

                                ; ON ENTRY, A5L/H CONTAINS THE HEX
                                ; VALUE OF THE ARGUMENT (SLOT #)
                                ; THAT WAS ISSUED WITH THE CMD.
                                ; THE ARGUMENT WAS PREVIOUSLY
                                ; SCREENED BY THE INPRMAX ($A0AA)
                                ; ROUTINE.  IF SLOT# = 0, THEN THE
                                ; OUTPUT HOOK (CSW) POINTS 2 COUT1
                                ; ($FDF0).  OTHERWISE, CSW POINTS
                                ; TO $CS00 (WHERE S = SLOT #).

CMDPR           LDA A5L         ; GET SLOT NUMBER.
                JMP OUTPORT     ; USE MONITOR ROM 2 SET OUTPUT HK.
                                ; RTN 2 THE CALLER OF THE PR# CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; =================================
                                ; THE IN# COMMAND HANDLER.
                                ; =================================

                                ; ON ENTRY, A5L/H CONTAINS THE HEX
                                ; VALUE OF THE ARGUMENT (SLOT #)
                                ; THAT WAS ISSUED WITH THE CMD.
                                ; THE ARGUMENT WAS PREVIOUSLY
                                ; SCREENED BY THE INPRMAX ($A0AA)
                                ; ROUTINE.  IF SLOT# = 0, THEN THE
                                ; INPUT HOOK (KSW) POINTS TO KEYIN
                                ; ($FD1B).  OTHERWISE, KSW POINTS
                                ; TO $CS00 (WHERE S = SLOT #).

CMDIN           LDA A5L         ; GET SLOT NUMBER.
                JMP INPORT      ; USE MONITOR ROM TO SET INPUT HK.
                                ; RTN 2 THE CALLER OF THE IN# CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)



                                ; ======================================
                                ; THE MON AND NOMON COMMAND HANDLERS.
                                ; ======================================

                                ; NOTE:  THE MON & NOMON COMMANDS AND
                                ; THEIR ALPHABETIC ARGUMENTS (C,I,O)
                                ; ARE FIRST DETECTED VIA COMMAND
                                ; PARSING.  CIOCUMUL IS TESTED AT THE
                                ; DSPLYCHR ($9F9F) PORTION OF THE VIDEO
                                ; PARSING ROUTINE TO SEE IF A CHAR
                                ; SHOULD BE SENT TO THE SCREEN OR
                                ; NOT.  IT IS EASY TO BECOME CONFUSED
                                ; OVER THE DISTINCTION BETWEEN
                                ; CIOCUMUL AND MONPRSD.  THE FORMER
                                ; REPRESENTS THE CUMMULATIVE UPDATED
                                ; RECORD OF THE C, I, O ARGUMENTS
                                ; WHEREAS THE LATER DESCRIBES THE
                                ; MOST RECENT ADDITIONS OF THE
                                ; C, I, O ARGUMENTS PRESENT IN THE
                                ; TABLE OF PARSED VALUES.
                                ; THE ALPHABETIC ARUMENTS (C, I, O)
                                ; ARE REPRESENTED BY THE FOLLOWING
                                ; SPECIFIC BITS:
                                ; C = $40 = %01000000
                                ; I = $20 = %00100000
                                ; O = $10 = %00010000
                                ; COMBINATION OF ARGUMENTS ARE SIMPLY
                                ; DESCRIBED BY THE APPROPRIATE BIT
                                ; SETTINGS: EX. CIO = $70 = $01110000

CMDMON          LDA CIOCUMUL    ; GET PREV CUMMULATIVE RECORD AND
                ORA MONPRSD     ; MERGE WITH THE LATEST PARSED VAL
                STA CIOCUMUL    ; TO UPDATE CUMMULATIVE RECORD.
                RTS             ; RTN 2 THE CALLER OF THE MON CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)

CMDNOMON        BIT MONPRSD     ; TEST BIT6 IN PARSED TBL TO SEE IF
                                ; "NOMON C" IS SELECTED.
                BVC CLRMON      ; BRANCH IF "C" NOT INCLUDED.
                JSR CRVIADOS    ; "C" WAS INCLUDED, SO PRT <CR>
                                ; CAUSE CMD (BUT NOT <CR>) WAS
                                ; ALREADY PRINTED.

CLRMON          LDA #%01110000  ; SHUT OFF BITS IN PARSED TABLE
                EOR MONPRSD     ; THAT CORRESPOND 2 THE ALPHABETIC
                                ; ARGUMENTS ISSUED WITH NOMON CMD.
                AND CIOCUMUL    ; NOW MAKE SURE THAT THOSE BITS
                STA CIOCUMUL    ; ARE OFF IN CUMMULATIVE RECORD.
                RTS             ; RTN TO CALLER OF THE NOMON CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; ==================================
                                ; THE MAXFILES COMMAND HANDLER.
                                ; ==================================

                                ; THE MAXFILES COMMAND IS USED TO
                                ; DEFINE THE # OF FILES THAT MAY
                                ; BE OPENED AT ONE TIME (IE. 1-16).
                                ; A DEFAULT VALUE OF 3 IS USED FOR
                                ; COLDSTARTS (IE, WHEN THE DISK IS
                                ; BOOTED) OR WHEN THE FP OR INT
                                ; COMMANDS ARE ISSUED.  THIS VALUE
                                ; CAN BE CHANGED BY ALTERING THE
                                ; CONTENTS OF $AAB1. (THE MAXFILES
                                ; CMD CAN BE TRICKED INTO BUILDING
                                ; ITS BUFFERS AT A LOWER LOCATION
                                ; IN ORDER TO CREATE A SANCTUARY
                                ; WHERE CUSTOM MACHINE LANGUAGE
                                ; ROUTINES CAN'T BE OVERWRITTEN BY
                                ; BASIC.  SEE FORMATTED DIS'MBLY
                                ; OF MAXFILES CMD FOR DETAILS.)

CMDMXFIL        LDA #0          ; SHUT OFF THE EXEC FLG.
                STA EXECFLAG
                LDA A5L         ; GET ARGUMENT ISSUED WITH CMD AND
                PHA             ; SAVE IT ON THE STK.
                                ; NOTE:  ARGUMENT WAS PREVIOUSLY
                                ; SCREENED TO INSURE THAT IS IS
                                ; BTWN 1 AND 16 ($A0AA - $A0C7).
                JSR CLOSEALL    ; CLOSE ALL OPEN FILES.
                PLA             ; RETRIEVE ARGUEMENT ISSUED WITH
                STA MXFILVAL    ; CMD & STORE IT IN THE MAIN
                                ; VARIABLES TABLE.
                JMP BILDBUFS    ; GO BUILD MXFILVAL # OF DOS BUFS.
                                ; RTNS 2 CALLER OF MAXFILES CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; =================================
                                ; THE DELETE COMMAND HANDLER.
                                ; =================================

CMDELETE        LDA #5          ; OPCODE FOR DELETE.
                JSR HNDLCMD1    ; CLOSE THE FILE & RLEASE ITS BUF.
                                ; REASSIGN A DOS BUF TO THE FILE.
                                ; CHNG FILE DESCRP IN DIR SEC BUF.
                                ; WRITE UPDATED DIR SEC BUF 2 DSK.
                                ; FREE UP DATA & T/S LIST SECTORS.
                                ; WRITE UPDATED VTOC TO DISK.
                JSR GETBUFF     ; FIND REASSIGNED DOS BUF.
                LDY #0          ; FREE UP DOS BUF OF FILE BY
                TYA             ; STORING A $00 IN 1RST BYTE OF
                STA (A3L),Y     ; THE DOS FILE NAME BUFFER.
                RTS             ; EXIT 2 CALLER OF THE DELETE CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; ==================================
                                ; THE LOCK AND UNLOCK CMD HANDLERS.
                                ; ==================================

CMDLOCK         LDA #7          ; LOCK OPCODE.
                BNE LOKUNLOK    ; ALWAYS.
CMDUNLOK        LDA #8          ; UNLOCK OPCODE.


                                ; ---------------------------------
                                ; ROUTINE COMMON TO LOCK, UNLOCK
                                ; AND VERIFY COMMAND HANDLERS.
                                ; ---------------------------------

LOKUNLOK        JSR HNDLCMD1    ; CALL PART OF THE MAIN COMMAND
                                ; HANDLER ROUTINE TO LOCK, UNLOCK
                                ; OR VERIFY THE FILE.
                JMP CMDCLOSE    ; EXIT COMMAND VIA CLOSE.
                                ; RTN 2 THE CALLER OF THE COMMAND.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; =================================
                                ; THE VERIFY COMMAND HANDLER.
                                ; =================================

CMDVERFY
                IF DOS31
                JMP VERFY
                DS  1
                ELSE
                LDA #12         ; VERIFY OPCODE.
                BNE LOKUNLOK    ; GO CALL THE CMD HNDLR TO VERIFY
                                ; FILE & THEN EXIT VIA CLOSE CMD.
                ENDIF


                                ; =================================
                                ; THE RENAME COMMAND HANDLER.
                                ; =================================

CMDRENAM        LDA ADRSFNBF    ; COPY ADR OF SECONDARY FILENAME 2
                STA RENAMBUF    ; RENAME BUF IN FM PARAMETER LIST.
                LDA ADRSFNBF+1
                STA RENAMBUF+1
                LDA #9          ; RENAME OPCODE.
                STA TEMPBYT
                JSR CLOSIFOP    ; CLOSE FILE IF IT IS ALREADY OPEN
                                ; AND THEN DO THE RENAME FUNCTION:
                                ; -COPY NEW FILE NAME 2 DIRECTORY
                                ; SECTOR BUFFER & THEN WRITE THE
                                ; UPDATED DIREC SEC BACK 2 DISK.
                JMP CMDCLOSE    ; EXIT RENAME CMD VIA CLOSE CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)


                                ; =================================
                                ; THE APPEND COMMAND HANDLER.
                                ; =================================

CMDAPPND        JSR CMDOPEN     ; GO OPEN THE FILE TO BE APPENDED.
                IF DOS31
                LDA   #6
                CMP   RTNCODFM
                BNE   READ2END
                RTS
                ENDIF

READ2END        JSR RDTXTBYT    ; GO READ A TEXT FILE BYTE.  (USE
                                ; THE READ FUNCTION AND READ-ONE-
                                ; BYTE SUBFUNCTION.)
                BNE READ2END    ; TAKE BRANCH IF DEALING WITH A
                                ; VALID (IE. NON-ZERO) DATA BYTE.
                                ; HAVEN'T ENCOUNTERED AN END-OF-
                                ; FILE MARKER ($00) YET,SO GO BACK
                                ; TO READ THE REST OF THE FILE.
                IF DOS31 || DOS32
                JMP BK2APND
                ELSE
                JMP CKAPFLG     ; FOUND END OF FILE,SO NOW GO BACK
                                ; UP THE FILE POINTER IF NECESSARY
                                ; AND EVENTUALLY EXIT THE APPEND
                                ; CMD HANDLER VIA RSETPTRS ($B6B3)
                                ; AND FMEXIT ($B386).  NOTE THAT
                                ; RSETPTRS RESETS THE SAVED STACK
                                ; POINTER (STKSAV, $B39B) SO WE
                                ; EVENTUALLY RETURN TO THE CALLER
                                ; OF THE APPEND COMMAND. EXECUTION
                                ; OFTEN RETURNS TO AFTRCMD ($A17D)
                                ; LOCATED IN THE COMMAND PARSING
                                ; AND PROCESSING ROUTINES.
                ENDIF


                                ; =================================
                                ; THE OPEN COMMAND HANDLER.
                                ; =================================

CMDOPEN
                IF !DOS31
                LDA #0          ; CODE FOR TEXT FILE.
                JMP OPNCKTYP    ; GO OPEN THE FILE & CHK ITS TYPE.
                                ; RTN 2 THE CALLER OF THE OPEN CMD
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; ASSOCIATED WITH THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)
                ENDIF


                                ; ====================================
                                ; COMMON FILE MANAGER CMD HNDLR CODE.
                                ; ====================================

HNDLCMD         LDA #1          ; OPEN OPCODE.
HNDLCMD1        STA TEMPBYT     ; STORE OPCODE IN TEMPBYT.
                LDA LENPRSD     ; GET L-PARAMETER FROM PARSED TBL.
                BNE SAVLENFM    ; CHECK IF A NON-ZERO L-PARM WAS
                                ; ISSUED WITH THE COMMAND.
                LDA LENPRSD+1
                BNE SAVLENFM
                LDA #1          ; LNGTH WAS 0 SO MAKE IT 1 INSTEAD
                STA LENPRSD
SAVLENFM        LDA LENPRSD     ; PUT LENGTH IN FM PARAMETER LIST.
                STA RECLENFM    ; NOTE:  RECORD LENGTH = 1 FOR
                LDA LENPRSD+1   ; SEQUENTIAL FILES, ELSE PARSED
                STA RECLENFM+1  ; LENGTH FOR RANDOM ACCESS FILES.


                                ; ----------------------------------
                                ; CLOSE FILE IF IT IS ALREADY OPEN.
                                ; ----------------------------------

CLOSIFOP        JSR CMDCLOSE    ; CLOSE IF ALREADY OPEN.
                LDA A5H         ; A5L/H POINTS AT HIGHEST NUMBERED
                                ; (LOWEST IN MEMORY) FREE DOS BUF.
                BNE SAVFNPTR    ; BRANCH IF FOUND A FREE BUFFER.
                JMP NOBUFERR    ; COULDN'T LOCATE A FREE BUFFER SO
                                ; GO ISSUE OUT OF BUF'S MSG.
SAVFNPTR        STA A3H         ; RESET A3L/H TO POINT AT DOS BUF
                LDA A5L         ; THAT WILL USE 4 FILENAME FIELD.
                STA A3L
                JSR CPYPFN      ; REASSIGN A DOS BUFFER 2 THE FILE
                                ; WE WANT TO OPEN.
                JSR BUFS2PRM    ; GET ADDR'S OF THE VARIOUS DOS
                                ; BUFFERS FROM THE CHAIN BUFFER &
                                ; PUT THEM IN THE FM PARM LIST.
                JSR CPY2PARM    ; PUT VOL, DRV, SLOT & ADDR OF THE
                                ; PRIMARY FILENAME BUFFER IN THE
                                ; FM PARAMETER LIST.
                LDA TEMPBYT     ; GET OPCODE BACK FROM TEMPBYT AND
                STA OPCODEFM    ; STICK IT IN THE FM PARM LIST.
                JMP FMDRIVER    ; USE FILE MANAGER TO DO FUNCTION.


                                ; =================================
                                ; THE CLOSE COMMAND HANDLER.
                                ; =================================

CMDCLOSE        LDA PRIMFNBF    ; GET 1RST CHR FRM PRMRY NAME BUF.
                CMP #SP         ; DON'T ALLOW LEADING SPACES.
                BEQ CLOSEALL    ; LEADING SPC = SIGNAL 2 CLOSE ALL
                                ; FILES.  (A CLOSE CMD WAS ISSUED
                                ; WITH NO ACCOMPANYING FILE NAME.)
                JSR GETBUFF     ; LOCATE A DOS BUFFER WITH SAME
                                ; NAME, ELSE LOCATE A FREE BUFFER.

EVENTXIT
                IF DOS31
                BCS CLOSERTSX   ; EVENTUALLY EXIT VIA THIS ROUTE!!
                ELSE
                BCS CLOSERTS    ; EVENTUALLY EXIT VIA THIS ROUTE!!
                ENDIF

                JSR CLOSEONE    ; MATCHING FILENAME WAS FOUND SO
                                ; GO CLOSE THAT FILE.
                JMP CMDCLOSE    ; GO BACK TO POINT A5L/H AT A FREE
                                ; DOS BUFFER & EXIT VIA EVENTXIT
                                ; ($A2F4) AND CLOSERTS ($A330).
                IF DOS31
CLOSERTSX       RTS
                ENDIF

                                ; ---------------------------------
                                ; CLOSE A SPECIFIC FILE
                                ; (& FREE ITS BUFFER).
                                ; ---------------------------------
CLOSEONE        JSR CKEXCBUF    ; CHK IF CURRENT FILENAME BUFFER
                                ; BELONGS TO AN EXEC FILE.
                BNE FREEBUFF    ; BRANCH IF NOT EXECING FROM THIS
                                ; PARTICULAR FILE.  NOTE, ALWAYS
                                ; TAKE BRANCH IF CLOSEONE ($A2FC)
                                ; IS ACCESSED VIA CLOSEALL ($A316)
                LDA #0          ; CLOSING AN EXEC FILE SO SHUT OFF
                STA EXECFLAG    ; THE EXEC FLAG. NOTE:THIS INSTRUC
                                ; IS NEVER CARRIED OUT IF ACCESSED
                                ; VIA CLOSEALL.  (AN ACTIVE EXEC
                                ; FILE WAS ALREADY DETECTED AND
                                ; SKIPPED BY THE "BEQ CHKNXBUF"
                                ; INSTRUCTION AT $A323.)
FREEBUFF        LDY #0          ; FREE UP DOS BUF BY POKING A $00
                TYA             ; IN 1RST BYT OF DOS FILENAME BUF.
                STA (A3L),Y
                JSR BUFS2PRM    ; GET ADDR'S OF THE VARIOUS DOS
                                ; BUFS FROM THE CHAIN BUF & PUT
                                ; THEM IN THE FM PARAMETER LIST.
                LDA #2          ; PUT OPCODE FOR CLOSE FUNCTION
                STA OPCODEFM    ; IN THE FM PARAMETER LIST.
                JMP FMDRIVER    ; GO TO THE FILE MANAGER DRIVER TO
                                ; DO THE CLOSE FUNCTION.


                                ; ---------------------------------------
                                ; CLOSE ALL FILES (EXCEPT AN EXEC FILE).
                                ; ENTER CLOSEALL WHEN IT IS ACCESSED VIA
                                ; A DIRECT CALL OR IF THE FIRST CHAR IN
                                ; THE PRIMAY FILENAME FIELD WAS A SPACE.
                                ; ---------------------------------------

CLOSEALL        JSR GETFNBF1    ; PUT ADR OF 1RST DOS FILENAME BUF
                                ; (LOCATED IN CHAIN OF DOS BUFS)
                                ; IN THE A3L/H POINTER.
                BNE CKIFEXEC    ; ALWAYS.
CHKNXBUF        JSR GETNXBUF    ; GET ADR OF NEXT DOS FILENAME BUF
                                ; FROM DOS CHAIN POINTERS BUFFER
                                ; (OFFSET 37 & 36 BYTES FROM 1RST
                                ; CHR OF PRESENT DOS FILENAME BUF)
                BEQ CLOSERTS    ; LNK ZEROED OUT -ALL FILES CLOSED
                                ; (EXIT CLOSEALL VIA THIS ROUTE.)
CKIFEXEC        JSR CKEXCBUF    ; CHK IF CURRENT DOS FILENAME BUF
                                ; BELONGS TO TO AN EXEC FILE.
                BEQ CHKNXBUF    ; EXEC ACTIVE SO DON'T CLOSE ITS
                                ; BUFFER OUT OR WILL END UP
                                ; IN NEVER-NEVER LAND.  AFTER ALL,
                                ; DON'T WANT TO CLOSE BUFFER IF WE
                                ; ARE USING IT 2 EXEC (IE. WOULD
                                ; BE LIKE BURYING SELVES ALIVE)!!
                JSR GETFNBY1    ; GET 1RST BYTE IN DOS NAME BUF.
                BEQ CHKNXBUF    ; THIS FILE IS ALREADY CLOSED SO
                                ; GO BACK TO CLOSE REST OF FILES.
                JSR CLOSEONE    ; FILE WAS OPEN SO GO CLOSE IT.
                JMP CLOSEALL    ; GO TO CLOSERTS VIA CLOSEALL!!!
CLOSERTS        RTS             ; EXIT TO CALLER OF THE CLOSE CMD.
                                ; (OFTEN EXITS TO AFTRCMD ($A17D)
                                ; LOCATED IN THE COMMAND PARSING &
                                ; PROCESSING ROUTINES.)


                                ; =================================
                                ; THE BSAVE COMMAND HANDLER.
                                ; =================================

CMDBSAVE        LDA #%00001001  ; TEST BITS0 & 3 OF CUMLOPTN 2 SEE
                AND CUMLOPTN    ; IF A(DDR) & L(ENGTH) PARAMETERS
                CMP #%00001001  ; WERE ISSUED WITH THE BSAVE CMD.
                BEQ DOBSAV      ; BOTH A- & L-PARMS PRESENT.
                JMP CKIFCTRL    ; GOT A SYNTAX ERROR.

DOBSAV          LDA #4          ; CODE FOR BINARY FILE.
                JSR OPNCKTYP    ; CLOSE (IF NECESSARY) & THEN OPN.
                LDA ADRPRSD+1   ; PREPARE TO WRITE ADDR TO DISK.
                LDY ADRPRSD
                JSR WRADRLEN    ; CALL WRITE-ONE-BYTE SUBFUNCTION
                                ; TWICE TO PUT A(DDR)-PARAMETER IN
                                ; DATA SEC BUF. (NOTE: LEN2RDWR IS
                                ; USED AS A TEMPORAY BUFFER FOR
                                ; FOR DATA TRANSFER.)

                LDA LENPRSD+1   ; PREPARE TO WRITE FILE LENGTH.
                LDY LENPRSD
                JSR WRADRLEN    ; CALL WRITE-ONE-BYTE SUFUNCTION 2
                                ; WRITE LENGTH AS THE 3RD & 4TH
                                ; BYTES IN THE DATA SEC BUF.
                                ; (LATER BUF WRITTEN AS 1RST SEC
                                ; OF FILE.  LEN2RDWR IS AGAIN USED
                                ; AS A TEMP BUF 4 DATA TRANSFER.)

                                ; NOW PREPARE TO WRITE THE REST
                                ; OF THE BINARY FILE TO THE DISK.

                LDA ADRPRSD+1   ; PUT ADDR OF SOURCE BUFFER IN
                LDY ADRPRSD     ; THE FM PARAMETER LIST.
                JMP RDWRANGE    ; GO TO WRITE-RANGE ROUTINE TO
                                ; WRITE REST OF FILE TO THE DISK.
                                ; (FILE IS ALSO VERIFIED AND THEN
                                ; EXITED VIA THE CLOSE COMMAND.)
                                ; EXECUTION EVENTUALLY RETURNS TO
                                ; THE CALLER OF THE BSAVE COMMAND.
                                ; OFTEN, RETURNS 2 AFTRCMD ($A17D)
                                ; LOCATED IN THE CMD PARSING AND
                                ; PROCESSING ROUTINES.


                                ; =================================
                                ; BLOAD COMMAND HANDLER
                                ; =================================

CMDBLOAD        JSR HNDLCMD     ; CALL THE FM COMMAND HANDLER TO
                                ; OPEN THE FILE.
                IF DOS31
                LDA   #6
                CMP   RTNCODFM
                BNE   LCK4BLOD
                JMP   TONOTFND
                ENDIF
                                ; COMPARE FILE TYPE WANTED
                                ; WITH FILE TYPE FOUND.

LCK4BLOD        LDA #$7F        ; STRIP LOCK BIT FROM FILE TYPE
                AND FILTYPFM    ; FOUND (VIA OPEN FUNCTION).
                CMP #4          ; WAS FILE FOUND A BINARY FILE?
                BEQ ADR4BLOD    ; YES.
                IF DOS31
                JMP NOTBINARY
                ELSE
                JMP TYPMISM     ; NO - GO ISSUE FILE-MISMATCH MSG.
                ENDIF

                                ; REDUNDANT CODE!  CLOSE (IF NECESSARY)
                                ; AND THEN OPEN THE FILE AGAIN.

ADR4BLOD        LDA #4          ; CODE FOR BINARY FILE.
                JSR OPNCKTYP    ; CLOSE & REOPEN FILE.
                JSR RDADRLEN    ; READ THE BLOAD ADR FROM THE DISK
                                ; INTO LEN2RDWR.
                TAX             ; X=LOW BYTE OF BLOAD ADR FRM DSK
                LDA CUMLOPTN    ; CHK CUMLOPTN TO SEE IF AN A(DDR)
                AND #%00000001  ; WAS ISSUED WITH THE BLOAD CMD.
                BNE LEN4BLOD    ; YES -SO IGNORE ADR READ FROM DSK
                                ; & USE THE ACTUAL PARSED
                                ; A-PARAMETER INSTEAD.
                STX ADRPRSD     ; STORE ADR READ FRM DSK IN PARSED
                STY ADRPRSD+1   ; TABLE.  (THIS WAY CAN ALWAYS USE
                                ; VAL IN TABLE FOR BLOAD ADR.)

LEN4BLOD        JSR RDADRLEN    ; READ THE BLOAD LENGTH OFF DSK.
                                ; (PUT RESULTS IN LEN2RDWR.)
                LDX ADRPRSD     ; SET (X)/(Y) = EITHER ORIG PARSED
                LDY ADRPRSD+1   ; A-PARM ADR OR BLOAD ADR FRM DSK.
                IF DOS31
                JMP READREST
                ELSE
                JMP LODINTFP    ; GO READ THE REST OF THE FILE IN.
                                ; EXITS VIA THE CLOSE COMMAND.
                                ; RETURNS TO CALLER OF THE BLOAD
                                ; CMD. (IF BLOAD CMD NOT CALLED BY
                                ; BRUN, THEN OFTEN RTNS TO AFTRCMD
                                ; ($A17D) LOCATED IN THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)
                ENDIF


                                ; =================================
                                ; BRUN COMMAND HANDLER
                                ; =================================

CMDBRUN         JSR CMDBLOAD    ; BLOAD THE PRGM.
                JSR INITIOHK    ; POINT THE I/O HOOKS AT DOS.
                                ; NOTE:  THIS CAN CREATE SOME
                                ; EXOTIC BUGS IF THE BRUNED PRGM
                                ; PRINTS ANY INFO OR IF "MON" IS
                                ; ACTIVE.  SEE FORMATTED DIS'MBLY
                                ; OF BRUN CMD FOR EXPLANATION.)
                JMP (ADRPRSD)   ; BEGIN EXECUTION OF BINARY PRGM.
                                ; EXECUTION NORMALLY RETURNS TO
                                ; AFTRCMD ($A17D) LOCATED IN THE
                                ; CMD PARSING AND PROCESSING
                                ; ROUTINES.  ALSO NOTE THAT
                                ; THE COMPUTER MAY HANG ON CERTAIN
                                ; OCCASSIONS.  (SEE THE FORMATTED
                                ; DISASSEMBLY OF THE BRUN CMD FOR
                                ; EXPLANATION.)


                                ; =================================
                                ; SAVE COMMAND HANDLER
                                ; =================================

CMDSAVE         LDA ACTBSFLG    ; CHK WHICH BASIC IS ACTIVE.
                BEQ SAVINTGR    ; BRANCH IF USING INTEGER.
                                ; INT=$00, A(ROM)=$40, A(RAM)=$80.
                IF !DOS31
                LDA PROTFLG     ; IF PROTECTION FLAG IS ON (IE. IS
                                ; NEGATIVE), THEN ALL APPLESOFT
                                ; CMDS CAUSE RUN & DOS'S SAVE CMD
                                ; CAUSES A PHONY PROGRAM-TOO-LARGE
                                ; MESSAGE TO BE GENERATED.
                BPL SAVAPSFT    ; BRANCH IF PROTECTION FLG IS OFF.
                JMP TOOLARGE    ; PROTECTED!!! - SPIT OUT PHONY
                                ; PROGRAM-TOO-LARGE MESSAGE & XIT.
                ENDIF


                                ; ---------------------------------
                                ; SAVE AN APPLESOFT FILE
                                ; ---------------------------------

SAVAPSFT        LDA #2          ; CODE FOR APPLESOFT FILE.
                JSR OPNCKTYP    ; GO OPEN THE NAMED FILE & CHECK
                                ; ITS TYPE.
                SEC             ; CALC THE LNGTH OF THE PRGM SO WE
                LDA PRGEND      ; CAN WRITE IT AS 1RST TWO BYTES:
                SBC TXTTAB      ; LENGTH = PRGEND - TXTTAB
                TAY
                LDA PRGEND+1
                SBC TXTTAB+1

                JSR WRADRLEN    ; WRITE THE LENGTH OF THE FP FILE
                                ; BY USING THE WRITE-ONE-BYTE
                                ; SUBFUNCTION TWICE.

                                ; PREPARE TO WRITE REST OF FILE.

                LDA TXTTAB+1    ; PRGM START = START OF OUTPUT BUF
                LDY TXTTAB
                JMP RDWRANGE    ; GO TO THE WRITE-RANGE-OF-BYTES
                                ; ROUTINE 2 WRITE THE REST OF FILE
                                ; AND THEN VERIFY IT.
                                ; AFTER VERIFICATION, THE SAVE CMD
                                ; IS EXITED VIA THE CLOSE CMD.
                                ; EXECUTION THEN RETURNS TO CALLER
                                ; OF THE SAVE CMD.  (OFTEN RTNS TO
                                ; AFTRCMD ($A17D) LOCATED IN THE
                                ; DOS CMD PARSING AND PROCESSING
                                ; ROUTINES.)


                                ; ---------------------------------
                                ; SAVE AN INTEGER FILE
                                ; ---------------------------------

SAVINTGR        LDA #1          ; CODE FOR INTEGER FILE.
                JSR OPNCKTYP    ; GO OPEN THE INTEGER FILE.

                SEC             ; CALC LENGTH OF FILE.
                LDA HIMEM
                SBC INTPGMST
                TAY
                LDA HIMEM+1
                SBC INTPGMST+1

                JSR WRADRLEN    ; WRITE LNGTH 2 DSK BY CALLING THE
                                ; WRITE-ONE-BYTE SUBFUNCTION TWICE
                LDA INTPGMST+1
                LDY INTPGMST
                JMP RDWRANGE    ; WRITE THE REST OF FILE TO DSK.


                                ; =================================
                                ; OPEN NAMED FILE & CHECK ITS TYPE
                                ; =================================

OPNCKTYP        STA FILTYPFM    ; PUT CODE FOR FILE TYPE IN THE
                PHA             ; FM PARAMETER LIST & SAVE ON STK.
                                ; ($00=TXT, $01=INT, $02=FP,
                                ; $04=BIN, $08=S-TYPE, $10=RELOC,
                                ; $20=A-TYPE AND $40=B-TYPE.)
                JSR HNDLCMD     ; USE THE FM CMD HANDLER TO OPEN.
                PLA             ; PULL THE FILE TYPE CODE FRM STK.
                JMP CHKFTYPE    ; GO CHK IF TYPE WNTD = TYPE FOUND


                                ; ============================================
                                ; WRITE TWO BYTES.
                                ; --------------------------------------------
                                ; CODE WHICH WRITES ADDRESS AND LENGTH VALUES
                                ; TO THE DATA SECTOR BUFFER.  (LATER, THE
                                ; DATA SEC BUF IS WRITTEN TO THE DISK.)
                                ; CALLS WRITE-ONE-BYTE SUBFUNCTION TWICE.
                                ; NOTE THAT LEN2RDWR IS USED AS A TEMPORARY
                                ; BUFFER FOR DATA TRANSFER AS SHOWN BELOW:
                                ; - LOW BYTE OF ADR OR LENGTH --> LEN2RDWR
                                ; --> ONEIOBUF --> DATA SECTOR BUFFER.
                                ; - HI BYTE OF ADR OR LENGTH --> LEN2RDWR+1
                                ; --> ONEIOBUF --> DATA SECTOR BUFFER.
                                ; ============================================

WRADRLEN        STY LEN2RDWR    ; PUT LOW BYTE IN FM PARM LIST IN
                                ; CASE THIS IS A L-PARM & WE NEED
                                ; IT AS A COUNTER WHEN LATER WRITE
                                ; RANGE OF BYTES TO DISK.
                STY ONEIOBUF    ; PUT BYTE TO WRITE IN PARM LIST.
                STA LEN2RDWR+1  ; PUT HI BYTE IN FM PARM LIST IN
                                ; CASE THIS IS A L-PARM & WE NEED
                                ; IT AS COUNTER WHEN LATER WRITE
                                ; RANGE OF BYTES TO DISK.
                LDA #4          ; PUT WRITE OPCODE IN FM PARM LIST
                STA OPCODEFM
                LDA #1          ; PUT ONE-BYTE SUBCODE IN PARM LST
                STA SUBCODFM
                JSR FMDRIVER    ; CALL FM DRV TO WRITE 1RST BYTE.
                LDA LEN2RDWR+1  ; PUT HI BYTE TO WRITE IN PARM LST
                STA ONEIOBUF
                JMP FMDRIVER    ; GO WRITE HI BYTE TO FILE.


                                ; =================================
                                ; READ/WRITE A RANGE OF BYTES
                                ; =================================

RDWRANGE        STY CURIOBUF    ; PUT ADR OF OUTPUT BUF IN PRM LST
                STA CURIOBUF+1
                LDA #2          ; SET SUBCODE FOR RANGE OF BYTES.
                IF DOS31 || DOS32
                STA SUBCODFM
                ELSE
                JMP VRFYRWNG    ; GO CALL THE FILE MANAGER TO WRITE
                                ; DATA TO THE DISK.  NEXT VERIFY
                                ; THE INFO & CLOSE THE FILE.
                ENDIF


                                ; =================================
                                ; CALL FM DRIVER & THEN CLOSE FILE
                                ; =================================

CLOSEFM         JSR FMDRIVER    ; CALL THE FM DRIVER 2 READ/WRITE.
                JMP CMDCLOSE    ; GO CLOSE THE FILE.


                                ; ========================================
                                ; GO ISSUE A FILE-TYPE-MISMATCH ERROR MSG
                                ; ========================================

TOTYPMIS        JMP TYPMISM     ; GO HANDLE MISMATCH ERROR.


                                ; =================================
                                ; LOAD COMMAND HANDLER
                                ; =================================

CMDLOAD         JSR CLOSEALL    ; CLOSE ALL FILES (EXCEPT ACTIVE
                                ; EXEC FILE).
OPENLOAD        JSR HNDLCMD     ; GO OPEN THE FILE.

                IF DOS31
                LDA #6
                CMP RTNCODFM
                BNE OPENLOAD2
TONOTFND        JSR CMDELETE
                LDA #6
                JMP ERRHNDLR
OPENLOAD2       LDA #%01111111
                ELSE
                LDA #%00100011  ; SET BITS IN (A) TO RESTRICT LOAD
                                ; CMD 2 APLSFT ($02), INTGR ($01)
                                ; OR A-TYPE ($20) FILES.
                ENDIF
                AND FILTYPFM    ; TYPE FOUND (VIA OPEN FUNCTION).
                BEQ TOTYPMIS    ; ERR -NOT ONE OF THE ABOVE TYPES.
                                ; GO ISSUE TYPE-MISMATCH ERR MSG.
                IF DOS31
                AND #3
                BEQ TOTYPMIS
                ENDIF

                STA FILTYPFM    ; SAVE TYPE WANTED IN FM PARM LIST

                LDA ACTBSFLG    ; CHK WHICH LANG IS ACTIVE:
                                ; INT=$00, FP=$40, A(RAM)=$80)
                BEQ LODINTGR    ; BRANCH IF USING INTEGER.

                LDA #2          ; CODE FOR APPLESOFT (FP).
                JSR SELCTBSC    ; CHK IF TYPE WANTED IS APPLESOFT.

                JSR RDADRLEN    ; READ LENGTH OF THE FP PRGM FROM
                                ; THE 1RST 2 BYTES OF THE FILE.

                                ; CHK TO SEE IF THERE IS ENOUGH ROOM
                                ; BETWEEN PRGM START POS'N & MEMSIZ
                                ; TO ACCOMODATE FILE.

                CLC             ; ADD LNGTH OF FILE 2 START OF PGM
                ADC TXTTAB      ; (NORMALLY, $801).
                TAX             ; SAVE LOW BYTE OF PRGEND IN (X).
                TYA             ; RETRIEVE HI BYTE OF LEN FROM (Y)
                ADC TXTTAB+1

                CMP MEMSIZ+1
                BCS TOTOOLRG    ; BRANCH IF NOT ENOUGH ROOM.
                                ; (GO ISSUE PRGM-TOO-LARGE MSG.)

                                ; PRGM IS SHORT ENOUGH TO BE
                                ; ACCOMODATED IN FREE MEMORY SPACE.
                                ;
                                ; SET ZERO-PAGE POINTERS.

                STA PRGEND+1    ; SET END OF PRGM POINTER.
                STA VARTAB+1    ; SET START OF VARIABLE SPACE.
                STX PRGEND      ; PRGEND: VAL IN TXTTAB + LENGTH.
                STX VARTAB      ; VARTAB: VAL IN TXTTAB + LENGTH.
                LDX TXTTAB
                LDY TXTTAB+1

                IF DOS31
                JMP READREST
                ELSE

                JSR LODINTFP    ; DESIGNATE WHERE IN FREE MEMORY 2
                                ; LOAD PRGM & THEN GO LOAD IT.
                JSR INITIOHK    ; POINT THE I/O HOOKS AT DOS.
                JMP (RLOCNTRY)  ; NORMALLY PTS TO SETLINKS ($D4F2)
                                ; ROUTINE IN BASIC WHICH SETS
                                ; IMPORTANT Z-PAGE POINTERS,
                                ; CLEARS OUT VARIABLES, RESETS STK
                                ; PTR & THEN ADJUSTS LINKS IN EACH
                                ; PROGRAM LINE.
                                ; EVENTUALLY, EXECUTION FLOWS INTO
                                ; BSC'S WRMSTART (RESTART, $D43C).
                                ; IF THE LOAD CMD WAS CALLED VIA
                                ; THE RUN CMD, EXECUTION BRANCHES
                                ; BACK 2 THE RUNFPINT ($A4DC) PART
                                ; OF THE RUN CMD (AFTER ADJUSTING
                                ; THE STACK).
                                ; IF LOAD WAS NOT CALLED FROM RUN,
                                ; THEN THE THE RESTART ($D43C)
                                ; PORTION OF BASIC EVENTUALLY
                                ; REQUESTS FURTHER PRGM OR KEYBRD
                                ; INPUT & ANOTHER CMD IS PARSED.
                ENDIF


                                ; ---------------------------------
                                ; LOAD AN INTEGER PROGRAM
                                ; ---------------------------------

LODINTGR        LDA #1          ; CODE 4 INTEGER BASIC FILE TYPE.
                JSR SELCTBSC    ; CHK IF INTEGER BASIC IS ACTIVE.
                                ; IF NOT, SWTCH FROM FP 2 INTEGER.
                JSR RDADRLEN    ; READ 1RST 2 BYTES OF FILE TO GET
                                ; LENGTH OF PRGM TO LOAD.
                SEC             ; CALC START OF PRGRM.
                LDA HIMEM       ; (HIMEM - LENADRBF.)
                SBC LENADRBF
                TAX
                LDA HIMEM+1
                SBC LENADRBF+1

                BCC TOTOOLRG    ; LENGTH > HIMEM SO ISSUE ERR MSG.
                TAY
                CPY LOMEM+1     ; CHK IF PRGM < = LOMEM.
                BCC TOTOOLRG    ; START OF PRGM TOO LOW, SO GO
                BEQ TOTOOLRG    ; ISSUE PRGM-TOO-LARGE ERROR MSG.

                STY INTPGMST+1  ; SET START-OF-PRGM POINTER.
                STX INTPGMST

                                ; =================================
                                ; GO DO THE ACTUAL LOAD.
                                ; (COMMON LOAD ROUT'N FOR
                                ; FP OR INTEGER LOAD CMDS.)
                                ; =================================

LODINTFP
                IF DOS31
                JMP READREST
                ELSE
                STX CURIOBUF    ; DESIGNATE LOAD ADDR AS I/O BUF
                STY CURIOBUF+1  ; IN THE FM PARAMETER LIST.
                JMP CLOSEFM     ; USE FILE MANAGER TO LOAD PRGM.
                ENDIF

                                ; =================================
                                ; COMMON CODE USED TO READ THE
                                ; BLOAD ADDRESS, BLOAD LENGTH
                                ; OR LOAD LENGTH FROM THE DISK.
                                ; =================================

RDADRLEN        LDA ADLENADR    ; GET ADR OF TWO-BYTE INPUT BUFFER
                STA CURIOBUF    ; (LENADRBF, $AA60) FRM RELOCATBL
                LDA ADLENADR+1  ; CONSTANTS TBL & DESIGNATE IT AS
                STA CURIOBUF+1  ; THE I/O BUF IN THE FM PARM LIST.
                LDA #0          ; PUT LENGTH TO READ = 2 BYTES IN
                STA LEN2RDWR+1  ; THE FM PARM LIST.
                LDA #2
                STA LEN2RDWR
                LDA #3          ; PUT READ OPCODE IN FM PARM LIST.
                STA OPCODEFM
                LDA #2          ; INDICATE WANT 2 READ RNG OF BYTS
                STA SUBCODFM
                JSR FMDRIVER    ; GO READ IN THE ADDR (OR LENGTH).
                LDA LENADRBF+1  ; GET HI BYTE OF ADR (OR LENGTH)
                                ; JUST READ FROM DISK.
                STA LEN2RDWR+1  ; PUT VAL JUST RD IN PARM LIST IN
                                ; CASE JUST READ LENGTH (SO KNOW
                                ; HOW MUCH TO READ WHEN READ MAIN
                                ; BODY OF FILE).
                TAY             ; SAVE HI BYTE IN (Y).
                LDA LENADRBF    ; DO LIKEWISE WITH LOW BYTE.
                STA LEN2RDWR
                RTS

                IF DOS31
READREST        STX   CURIOBUF
                STY   CURIOBUF+1
                JSR   FMDRIVER
                JMP   CMDCLOSE
                ENDIF

                                ; =================================
                                ; CLOSE FILE & ISSUE A PROGRAM-
                                ; TOO-LARGE ERROR MESSAGE.
                                ; =================================

TOTOOLRG        JSR CMDCLOSE    ; CLOSE FILE.
                JMP TOOLARGE    ; ISSUE ERROR MSG.


                                ; =================================
                                ; SELECT DESIRED BASIC
                                ; =================================

                                ; CHK IF DESIRED BASIC IS UP OR NOT
                                ; (SWITCH BASIC IF NECESSARY).

SELCTBSC        CMP FILTYPFM    ; TYPE WANTED = TYPE FOUND?
                BEQ SELBSRTN    ; YES - BASIC WANTED IS ACTIVE.

                LDX NDX2CMD     ; SAVE INDEX 2 PRESENT CMD IN CASE
                STX NEXTCMD     ; WE ARE USING INTEGER & MUST LOAD
                                ; INTEGER FILE CALLED "APPLESOFT"
                                ; IN ORDER TO LOAD A(RAM).
                LSR A           ; SHIFT TYPE WANTED TO SEE WHICH
                                ; BASIC TO SWITCH INTO.
                BEQ SWTCH2FP    ; SWITCH FROM INTEGER 2 APPLESOFT.
                JMP CMDINT      ; SWITCH FROM APPLESOFT 2 INTEGER.


                                ; SWITCHING FROM INT TO APPLESOFT
                                ; SO COPY NAME OF FILE FROM PRIMARY
                                ; TO SECONDARY NAME BUF IN CASE WE
                                ; HAVE TO USE RAM-BASED APPLESOFT.

SWTCH2FP        LDX #29         ; 30 BYTES TO COPY (0 TO 29).
PRIM2SND        LDA PRIMFNBF,X  ; GET BYTE FROM PRIMARY.
                STA SCNDFNBF,X  ; COPY IT TO SECONDARY.
                DEX
                BPL PRIM2SND    ; BRANCH IF MORE BYTES TO COPY.

                JMP CMDFP       ; EXECUTE THE FP COMMAND.

SELBSRTN        RTS             ; DESIRED BASIC WAS ACTIVE.


                                ; =================================
                                ; RUN COMMAND HANDLER
                                ; =================================

CMDRUN
                IF !DOS31
                LDA ACTBSFLG    ; CHK WHICH BASIC IS CURRENT.
                BEQ LOAD4RUN    ; BRANCH IF USING INTEGER BASIC.

                STA RUNTRUPT    ; SET THE RUN INTERCEPT FLAG TO
                                ; SIGNAL THAT WE ARE ABOUT TO
                                ; INTERRUPT THE RUN COMMAND TO DO
                                ; LOAD.  ($40=A(ROM), $80=A(RAM).)
                ENDIF

LOAD4RUN        JSR CMDLOAD     ; GO LOAD THE PROGRAM.
                                ; ************* NOTE ************
                                ; * THE "JSR" IS ACTUALLY A
                                ; * PLACEBO BECAUSE AFTER FILE
                                ; * IS LOADED, EXECUTION GOES IN2
                                ; * BASIC & THEN RE-ENTERS DOS
                                ; * THRU THE DOS INTERCEPTS. ONCE
                                ; * DOS GETS ITS MITTS BACK INTO
                                ; * THINGS, THE RUNTRUPT FLAG IS
                                ; * TESTED & THEN EXECUTION FLOWS
                                ; * TO THE NEXT INSTRUCTION (AT
                                ; * RUNFPINT).  THE MACHINE DOES
                                ; * NOT GET LOST BECAUSE THE STK
                                ; * PTR GETS RESET ACCORDINDLY.
                                ; *******************************

RUNFPINT        JSR CRVIADOS    ; PRINT A <CR>.
                JSR INITIOHK    ; RESET THE I/O HKS TO PT TO DOS.
                JMP (RUNTRY)    ; GO EXECUTE THE PRGM.
                                ; (RUNTRY PTS TO RUNFPROM IF USING
                                ; A(ROM) OR POINTS TO FPRAMRUN
                                ; IF USING A(RAM).)


                                ; =======================================
                                ; INTEGER BASIC'S RUN CMD ENTRY POINT.
                                ; (RUNTRY PTS HERE WHEN INTEGER ACTIVE.)
                                ; =======================================

RUNINTGR        LDA LOMEM       ; CLEAR OUT ALL VARIABLES.
                STA INTVRLND    ; ZERO OUT INTEGER BASIC'S CURRENT
                LDA LOMEM+1     ; VARIABLE POINTER.
                STA INTVRLND+1
                JMP (CHAINTRY)  ; GO INTO INTEGER BASIC 2 EXECUTE.


                                ; =================================
                                ; CHAIN COMMAND HANDLER
                                ; =================================

CMDCHAIN
                IF DOS31
                JSR CMDLOAD
                ELSE
                JSR OPENLOAD    ; LOAD THE INTEGER PRGM.
                ENDIF
                JSR CRVIADOS    ; PRINT A <CR>.
                JSR INITIOHK    ; POINT I/O HOOKS AT DOS.
                JMP (CHAINTRY)  ; GO INTO INTEGER BASIC 2 EXECUTE.


                                ; =================================
                                ; A(ROM)'S RUN ENTRY POINT.
                                ; (RUNTRY POINTS HERE IF A(ROM)
                                ; BASIC IS ACTIVE.)
                                ; =================================

RUNFPROM        JSR SETZPTRS    ; CLEAR OUT ALL VARIABLES.
                IF !DOS31
                STA PROMPT      ; ZERO OUT PROMPT & ON-ERROR FLAG.
                STA ERRFLG
                ENDIF
                JMP NEWSTT      ; JUMP INTO BASIC TO EXECUTE PRGM.


                                ; =================================
                                ; A(RAM)'S RUN ENTRY POINT.
                                ; (RUNTRY POINTS HERE IF A(RAM)
                                ; VERSION OF BASIC IS UP.)
                                ; =================================

FPRAMRUN        JSR CLRFPRAM    ; CLEAR ALL VARIABLES.
                IF !DOS31
                STA PROMPT      ; ZERO OUT PROMPT & ON ERROR FLAG.
                STA ERRFLG
                ENDIF
                JMP RUNFPRAM    ; GO RUN THE PROGRAM.

                                ; =================================
                                ; WRITE COMMAND HANDLER.
                                ; =================================

CMDWRITE        JSR COMRDWR     ; CALL COMMON READ/WRITE ROUTINE.
                                ; FIND NAMED BUF, ELSE A FREE BUF.
                                ; OPEN FILE IF NOT ALREADY OPEN.
                                ; POS'N FILE PTR IF R- OR B-PARMS
                                ; WERE ISSUED.
                LDA #5          ; SET CONDITION 5.
                STA OPUTCOND

                JMP FINSHCMD    ; XIT WITH CONDITION 5 SET SO THAT
                                ; THE NEXT TIME A PRINT STATEMENT
                                ; IS ENCOUNTERED, EXECUTION WILL
                                ; FLOW VIA COUT & THE DOS HKS TO
                                ; SEND CHARS TO THE NAMED FILE.


                                ; =================================
                                ; READ COMMAND HANDLER.
                                ; =================================

CMDREAD         JSR COMRDWR     ; CALL COMMON READ/WRITE ROUTINE.
                                ; FIND NAMED BUF, ELSE FIND A FREE
                                ; BUFFER. OPEN FILE IF NOT ALREADY
                                ; OPEN.  POS'N FILE PTR IF R- OR
                                ; B-PARMS WERE ISSUED WITH CMD.
                LDA #1          ; SET CONDNFLG TO SIGNAL READING.
                STA CONDNFLG
                JMP FINSHCMD    ; XIT WITH OPUTCOND=0 & CONDNFLG=1
                                ; EXECUTION EVENTUALLY FLOWS BACK
                                ; INTO APPLESOFT.  WHEN APPLESOFT
                                ; PICKS UP A SUBSEQUENT "INPUT" OR
                                ; "GET" STATEMENT, IT PRINTS A
                                ; PROMPT.  DOS INTERCEPTS OUTPUT
                                ; VIA OPUTINCP ($9EBD).  WHEN THE
                                ; SETTING OF CONDNFLG IS DETECTED,
                                ; THE MACHINE IS DIRECTED TO TAKE
                                ; DATA FROM THE DISK.


                                ; =================================
                                ; CODE COMMON TO READ/WRITE.
                                ; =================================

COMRDWR         JSR GETBUFF     ; LOCATE A DOS BUF WITH SAME NAME,
                                ; ELSE LOCATE A FREE BUF.
                BCC BUFS4RW     ; BRNCH IF MATCHING BUF WAS FOUND.
                JSR CMDOPEN     ; FILE NOT ALREADY OPN, SO OPEN IT
                JMP CKRBOPTN    ; GO CHK IF R- & B-PARMS ISSUED.

BUFS4RW         JSR BUFS2PRM    ; COPY ADDRS OF THE VARIOUS DOS
                                ; BUFFERS TO THE FM PARAMETER LIST

                                ; CHK IF R- OR B-PARAMETERS
                                ; WERE ISSUED WITH COMMAND.

CKRBOPTN        LDA CUMLOPTN    ; CHK IF R- OR B-PARMS ISSUED.
                AND #%00000110  ; (R=$04, B=$02.)
                BEQ RDWRRTN     ; NO - SKIP POS'NING OF FILE PTR.

                                ; COPY B- & R-PARMS FROM OPTION
                                ; PARSED TABLE TO FM PARM LIST.

                LDX #3
CPYBPARM        LDA RECPRSD,X   ; GET VALUE OF PARAMETER.
                STA RECNMBFM,X  ; STORE IT IN PARM LIST.
                DEX             ; 4 BYTES TO COPY (3 TO 0).
                BPL CPYBPARM

                                ; CALL THE FILEMANAGER
                                ; WITH THE POSITION OPCODE.

BK2APND         LDA #$0A        ; OPCODE FOR POSITION.
                STA OPCODEFM    ; PUT IT IN THE FM PARAMETER LIST.
                JSR FMDRIVER    ; CALL FM 2 DO THE POS'N FUNCTION.
RDWRRTN         RTS


                                ; =================================
                                ; INIT COMMAND HANDLER.
                                ; =================================

CMDINIT         LDA #%01000000  ; CHK TO SEE IF V(OLUME) OPTION
                AND CUMLOPTN    ; WAS ISSUED WITH INIT COMMAND.
                IF DOS31
                BEQ L24FE
                ELSE
                BEQ VOL254      ; NO V-PARM ISSUED, SO USE A DFLT
                                ; VOLUME VALUE OF 254.
                ENDIF
                LDA VOLPRSD     ; A VOL VAL WAS ISSUED, SO USE IT
                IF DOS31
                BEQ L24FE
                ELSE
                BNE OTHRVOL     ; (BUT ONLY IF IT IS NOT ZERO).
VOL254          LDA #$FE        ; USE VOL 254 AS DEFAULT VALUE.
                STA VOLPRSD
                ENDIF
OTHRVOL         LDA ADOSTART+1  ; HI BYTE OF DOS LOAD ADDR FROM
                                ; DOS'S MAIN VARIABLE TABLE.
                STA SUBCODFM
                LDA #11         ; OPCODE FOR INIT COMMAND.
                JSR HNDLCMD1    ; CALL FM COMMAND HANDLER TO DO
                                ; THE INIT COMMAND.
                JMP CMDSAVE     ; GO SAVE THE "HELLO" FILE & THEN
                                ; EXIT TO THE CALLER OF THE INIT
                                ; CMD.  (NORMALLY RTNS TO AFTRCMD
                                ; ($A17D) LOCATED IN THE COMMAND
                                ; PARSING & PROCESSING ROUTINES.)
                IF DOS31
L24FE           JMP CKIFCTRL
                ENDIF

                                ; =================================
                                ; CATALOG COMMAND HANDLER.
                                ; =================================

CMDCATLG        LDA #6          ; CATALOG OPCODE.
                JSR HNDLCMD1    ; CALL CMD HANDLER TO DO CATALOG.
                LDA VOLFM       ; GET VOLUME # FROM FM PARM LIST
                STA VOLPRSD     ; & PUT IT IN THE PARSED TABLE.
                RTS             ; EXIT TO CALLER OF CATALOG CMD.
                                ; (OFTEN RETURNS 2 AFTRCMD ($A17D)
                                ; LOCATED IN THE CMD PARSING AND
                                ; PROCESSING ROUTINES.)


                                ; =================================
                                ; FP COMMAND HANDLER.
                                ; =================================

CMDFP           LDA #$4C        ; (A) = OPCODE FOR "JMP".
                JSR SETROM      ; TEST 2 SEE IF LANGUAGE WANTED IS
                                ; ON CARD OR MOTHERBOARD.
                BEQ TODOSCLD    ; ROM VERSION OF FP WAS PRESENT ON
                                ; EITHER CARD OR MOTHERBOARD SO GO
                                ; DO A COLDSTART.

                                ; USING MACHINE WITH INTEGER IN ROM.
                                ;
                                ; ASSUME USING "SYSTEM MASTER" DISK
                                ; SO TRY TO RUN AN INTEGER PRGM
                                ; CALLED "APPLESOFT".  WHEN RUN, THE
                                ; PRGM CALLED "APPLESOFT" LOADS A
                                ; RAM OR DISK-BASED VERSION OF FP
                                ; BASIC THAT IS CONTAINED IN A BINARY
                                ; FILE CALLED "FPBASIC".  THIS LATTER
                                ; FILE IS ALSO HOUSED ON THE SYSTEM
                                ; MASTER DISK.

                LDA #0          ; SET ACTIVE BASIC FLAG TO DENOTE
                STA ACTBSFLG    ; USING INTEGER.
                LDY #30
                JSR BLNK1RST    ; BLANK OUT THE PRIMARY FILE NAME
                                ; BUFFER (30 BYTES LONG).

                                ; COPY THE NAME OF THE INTEGER FILE
                                ; CALLED "APPLESOFT" INTO THE PRIMARY
                                ; FILE NAME BUFFER.

                LDX #9          ; ONLY 9 CHARS IN NAME "APPLESOFT"
CPYAPPLE        LDA RUNTRUPT,X  ; GET CHARS OF NAME.
                STA PRIMFNBF-1,X
                                ; STORE THEM IN PRIMARY NAME BUF
                DEX             ; REDUCE COUNTER.
                BNE CPYAPPLE    ; MORE CHARS TO COPY.

                LDA #$C0        ; SET CONDNFLG TO DESIGNATE USING
                STA CONDNFLG    ; RAM VERSION OF APPLESOFT.
                JMP CMDRUN      ; GO RUN FILE CALLED "APPLESOFT"
                                ; WHICH LOADS A RAM VERSION OF
                                ; FP BASIC CONTAINED IN A BINARY
                                ; FILE CALLED "FPBASIC".


                                ; =================================
                                ; INT COMMAND HANDLER.
                                ; =================================

CMDINT          LDA #$20        ; OPCODE FOR "JSR".
                JSR SETROM      ; TEST TO SEE IF LANGUAGE WANTED
                                ; IS ON CARD OR MOTHERBOARD.
                IF DOS31
                BNE CMDFP
                ELSE
                BEQ INTPRSNT    ; INTEGER BASIC IS PRESENT (EITHER
                                ; ON CARD OR MOTHERBOARD).

                                ; INTEGER BASIC NOT PRESENT
                                ; ON CARD OR MOTHERBOARD.

NOLNGINT        LDA #1          ; SET ERROR CODE FOR LANGUAGE-NOT-
                JMP ERRHNDLR    ; AVAILABLE MSG & GO EXIT.

                                ; INTEGER BASIC PRESENT ON DEVICE.

INTPRSNT        LDA #0          ; CAUSE DESIRED BASIC IS PRESENT,
                STA RUNTRUPT    ; ZERO OUT THE RUN INTERCEPT FLAG
                                ; CAUSE WE WON'T BE LOADING A LANG
                ENDIF
TODOSCLD        JMP DOSCOLD     ; GO INTO THE COLDSTART ROUTINE.


                                ; =================================
                                ; SELECT DESIRED BASIC
                                ; =================================

                                ; TEST CARD OR MOTHERBOARD TO INSURE
                                ; THAT DEVICE CONTAINING THE ROM
                                ; VERSION WE WANT IS SELECTED.
                                ; BASICCLD ($E000) CONTAINS A "JMP"
                                ; OR "JSR" INSTRUCTION IF DEALING
                                ; WITH FP OR INTEGER ROM RESPECTIVELY.

SETROM          CMP BASICCLD    ; TEST CARD OR MOTHERBOARD.
                                ; (IE.CHK WHICHEVER DEVICE IS UP.)
                BEQ DVICERTN    ; LANG WNTD ON PRESENT ROM DEVICE.

                                ; LANGUAGE WAS NOT ON DEVICE SELECTED
                                ; ABOVE, SO SPECIFICALLY TEST CARD
                                ; IN SLOT 0.  (P.S. COULD CHANGE ADDRS
                                ; IF WANT CARD IN DIFFERENT SLOT.)

                STA RRAMWXXXD2  ; READ ENABLE SLOT0.
                CMP BASICCLD    ; CHECK IDENTIFYING BYTE.
                BEQ DVICERTN    ; BRANCH IF ROM WANTED IS ON CARD.

                                ; ROM WANTED WAS NOT ON CARD.
                                ; WE MAY HAVE JUST TESTED CARD TWICE
                                ; SO NOW SPECIFICALLY TEST MOTHERBOARD.

                STA RROMWRAMD2  ; TEST MOTHERBOARD.
                CMP BASICCLD    ; CHECK IDENTIFYING BYTE.
DVICERTN        RTS             ; EXIT WITH THE SWITCHES POINTING
                                ; AT THE LAST DEVICE TESTED.IF THE
                                ; DESIRED LANGUAGE IS PRESENT, THE
                                ; SWITCHES ARE LEFT WITH THE
                                ; APPROPRIATE DEVICE SELECTED.


                                ; =================================
                                ; EXEC COMMAND HANDLER.
                                ; =================================

CMDEXEC         JSR CMDOPEN     ; GO OPEN THE FILE TO BE EXECED.
                LDA CURFNADR    ; GET ADDR OF CURRENT FILENAME BUF
                STA EXECBUFF    ; & DESIGNATE AS EXEC'S NAME BUF.
                LDA CURFNADR+1
                STA EXECBUFF+1
                LDA PRIMFNBF    ; SET EXEC FLAG TO A NON-ZERO VAL.
                STA EXECFLAG    ; (USE 1RST CHAR OF FILE NAME.)
                BNE POSNCHKR    ; ALWAYS - GO POS'N FILE PTR IF
                                ; NECESSARY.
                                ; NOTE: ACTUAL EXECING OF STATMNTS
                                ; DOES NOT OCCUR UNTIL AFTER THE
                                ; COMPUTER RETURNS TO BASIC'S
                                ; RESTART ($D43C) ROUTINE.  WHEN
                                ; INPUT IS REQUESTED, EXECUTION
                                ; FLOWS VIA DOS HKS INTO OPUTINCP
                                ; ($9EBD).  HERE THE EXECFLAG IS
                                ; TESTED & DISCOVERED TO BE SET.
                                ; AS RESULT, THE READEXEC ($A682)
                                ; ROUTINE IS USED 2 READ DATA FROM
                                ; THE EXEC FILE.  THE STATEMENTS
                                ; ARE INTERPRETED AS IF THEY WERE
                                ; ENCOUNTERED IN THE IMMED MODE.


                                ; =================================
                                ; POSITION COMMAND HANDLER
                                ; =================================

CMDPOSN         JSR GETBUFF     ; LOCATE BUF WITH SAME NAME, ELSE
                                ; LOCATE A FREE BUFFER.

                BCC BUFS4PSN    ; ALREADY OPEN -SKIP NEXT INSTRUC.
                JSR CMDOPEN     ; GO OPEN THE FILE.
                JMP POSNCHKR    ; BYPASS NEXT INSTRUC, CAUSE JUST
                                ; OPENED FILE & PARM LIST ALREADY
                                ; CONTAINS ADRS OF DIF DOS BUFS.

BUFS4PSN        JSR BUFS2PRM    ; GET ADR OF DOS BUFS FROM CHAIN
                                ; BUF & PUT THEM IN FM PARM LIST.

POSNCHKR        LDA CUMLOPTN    ; CHK TO SEE IF A NON-ZERO R-PARM
                AND #%00000100  ; WAS ISSUED WITH CMD.
                BEQ DONEPOSN    ; R-PARM WAS ZERO, SO GO EXIT
                                ; (IE. DON'T MOVE FILE POINTER).

                                ; A NON-ZERO R-PARM WAS ISSUED, SO GO MOVE
                                ; THE FILE POINTER FORWARD BY READING
                                ; ONE BYTE AT A TIME.  WHEN A <CR> IS
                                ; ENCOUNTERED, REDUCE THE COUNT OF THE
                                ; RELATIVE FIELD POSITIONS LEFT TO MOVE.
                                ; WHEN THE COUNT EQUALS ZERO, WE ARE
                                ; DONE POSITIONING.

CKPSNDUN        LDA RECPRSD     ; CHECK COUNT.
                BNE POSNMORE
                LDX RECPRSD+1
                BEQ DONEPOSN    ; R-PRM HAS BEEN COUNTED DWN TO 0,
                                ; SO WE ARE DONE POSITIONING.
                DEC RECPRSD+1   ; REDUCE COUNT OF R-PARM (IE. # OF
POSNMORE        DEC RECPRSD     ; FIELDS MOVED FORWARD) FOR NEXT
                                ; TIME AROUND.
PSNFIELD        JSR RDTXTBYT    ; GO READ A TEXT FILE BYTE.
                BEQ ENDATERR    ; IF BYTE JUST READ = $00,THEN RAN
                                ; OUT OF DATA.  A ZERO BYTE CAN BE
                                ; OBTAINED FROM AN INCOMPLETELY
                                ; FILLED DATA SECTOR.  OR, IF THE
                                ; FILE ENDS ON A SECTOR BOUNDARY,
                                ; A $00 CAN ALSO BE ACQUIRED FROM
                                ; A ZEROED-OUT T/S LINK OR A
                                ; ZEROED-OUT DATA PAIR (TRK/SEC
                                ; VALUES) LISTED IN A T/S LIST.
                CMP #CR        ; WAS BYT A FIELD-DELIMITING <CR>?
                BNE PSNFIELD    ; NO -GO READ THE NEXT BYTE IN THE
                                ; SAME FIELD.
                BEQ CKPSNDUN    ; YES - GOT END-OF-FIELD MARKER SO
                                ; BRANCH BACK TO REDUCE THE FIELD
                                ; COUNT & SEE IF WE'RE DONE
                                ; POSITIONING YET.
DONEPOSN        RTS             ; EXIT - EITHER DONE POSITIONING,
                                ; ELSE R-PARM WAS 0 TO START WITH
                                ; & THERE4 NO POSITIONING NEEDED.
                                ; EXIT 2 CALLER OF COMMAND.  OFTEN
                                ; RETURNS 2 AFTRCMD ($A17D) LOC'D
                                ; IN THE CMD PARSING & PROCESSING
                                ; ROUTINES.


                                ; =================================
                                ; WRITE-ONE-DATA-BYTE SUBROUTINE.
                                ; =================================

WRITEXT         JSR CKBSCRUN    ; CHK IF BASIC IS RUNNING A PRGM.
                IF !DOS31
                BCS CLOSZERO    ; NOT RUNNING, SO GO CLOSE FILE,
                                ; RESET TO CONDITION 0 & THEN DO A
                                ; WARMSTART.  (REMEMBER, WRITE CMD
                                ; IS RESTRICTED TO DEFERRED MODE.)
                ENDIF
                LDA ASAVED      ; RETRIEVE BYTE TO WRITE.
                STA ONEIOBUF    ; PUT IT IN FM PARM LIST.
                LDA #4          ; SET PARM LIST TO WRITE ONE BYTE.
                STA OPCODEFM
                LDA #1
                STA SUBCODFM
                JMP FMDRIVER    ; GO TO FM DRV TO WRITE DATA BYTE.


                                ; =================================
                                ; ROUTINE TO READ A DATA BYTE.
                                ; =================================

READTEXT        JSR CKBSCRUN    ; CHK IF BASIC IS RUNNING A PRGM.
                IF !DOS31
                BCS CLOSZERO    ; BASIC NOT RUNNING SO GO CLOSE
                                ; FILE, RESET 2 CONDITION 0 & DO A
                                ; WARMSTART.  (REMEMBER READ CMD
                                ; IS RESTRICTED 2 DEFERRED MODE.)
                ENDIF
                LDA #6          ; SET COND'N6 -IGNORE INPUT PROMPT

SETCOND         STA OPUTCOND
                JSR RDTXTBYT    ; GO READ TEXT FILE DATA BYTE.
                BNE NOTEND      ; IF BYTE READ <> 0, THEN HAVEN'T
                                ; HIT END-OF-FILE MARKER YET.

                                ; RAN OUT OF DATA.  PICKED UP A $00 BYTE
                                ; EITHER FROM PARTIALLY FULL DATA SECTOR,
                                ; A ZEROED-OUT T/S LINK OR A ZEROED-OUT
                                ; DATA PAIR (TRK/SEC VALUES LISTED IN A
                                ; T/S LIST).

                JSR CLOSEONE    ; RAN OUT OF DATA SO CLOSE FILE.
                LDA #3          ; USING CONDITION 3?
                CMP OPUTCOND    ; IE. HNDLING AN INPUT STATEMENT?
                IF DOS31
                BEQ TOEXIT2
                ELSE
                BEQ DONEPOSN    ; YES - JUST GO TO AN "RTS".
                ENDIF

ENDATERR        LDA #5          ; NO - THERE4 GOT OUT-OF-DATA ERR.
                JMP ERRHNDLR    ; GO HANDLE ERROR.


NOTEND
                IF DOS31
                STA ASAVED
TOEXIT2         JMP DOSEXIT
CKBSCRUN        LDA ACTBSFLG
                BEQ INTBASIC
                LDX CURLIN+1
                JMP L3FD5
                ELSE
                CMP #$E0        ; LOWERCASE?
                BCC SAVIT       ; BRANCH IF UPPERCASE.
                AND #$7F        ; CONVERT LOWER TO UPPER IN ORDER
                                ; 2 FOOL CAPTST ROUTINE ($FD7E)
                                ; IN MONITOR ROM.
SAVIT           STA ASAVED      ; SAVE CHAR READ.
                LDX XSAVED      ; GET INDEX TO INPUT BUFFER.
                BEQ TOEXIT      ; BRANCH IF 1RST CHAR.
                DEX             ; TURN HI BIT ON IN PREVIOUS CHAR
                LDA BUF200,X    ; STORED IN BUF200 TO CONVERT TO
                ORA #$80        ; LOWERCASE IF NECESSARY.
                STA BUF200,X
TOEXIT          JMP DOSEXIT     ; GO TO DOS'S EXIT ROUTINE.


                                ; ==================================
                                ; CHECK IF BASIC IS RUNNING A PRGM.
                                ; ==================================

CKBSCRUN        PHA             ; SAVE (A) ON STK.
                LDA ACTBSFLG    ; WHICH BASIC IS UP?
                BEQ INTBASIC    ; BRANCH IF USING INTEGER.

                                ; USING APPLESOFT SO NOW CHECK IF
                                ; IN IMMEDIATE OR DEFERRED MODE.
                                ; (IF LINE NUMBER BYTES ARE
                                ; GREATER THAN OR EQUAL TO DECIMAL
                                ; 65280 ($FF IN HI BYTE), THEN THE
                                ; COMPUTER ASSUMES THAT WE'RE USING
                                ; THE IMMEDIATE MODE.)

                LDX CURLIN+1    ; CHK HI BYTE OF LINE #.
                INX             ; IF $FF --> $00, THEN # > = 65280
                BEQ IMEDMODE    ; BRANCH IF USING IMMEDIATE MODE.

                                ; FP APPEARS TO BE RUNNING A PRGM
                                ; BUT, MAYBE CURLIN+1 WAS ZAPPED
                                ; (POSSIBLY AS PART OF A PROTECTION
                                ; SCHEME) SO BETTER ALSO CHECK THE
                                ; PROMPT.

                LDX PROMPT
                CPX #"]"|0x80   ; USING AN APPLESOFT PROMPT?
                BEQ IMEDMODE    ; YES - SO MUST BE IN IMMED MODE.

RUNNING         PLA             ; GET SAVED (A) BACK FROM STK.
                CLC             ; SIGNAL PRGM IS RUNNING.
                RTS
                ENDIF

INTBASIC        LDA RUNMODE     ; CHK INTGR BASIC'S RUN MODE FLG.
                IF DOS31
                BMI PT2EXEC2
                ELSE
                BMI RUNNING     ; IF NEG, INT BASIC IN DEFERRED.
                ENDIF


                IF !DOS31
IMEDMODE        PLA             ; GET SAVED (A) BACK FROM STK.
                SEC             ; SIGNAL IN IMMEDIATE MODE.
                RTS
                ENDIF


                                ; ====================================
                                ; CLOSE FILE, SET CONDITION0, & EXIT.
                                ; ====================================

CLOSZERO        JSR CLOSEONE    ; CLOSE OPEN FILE.
                JSR RESTAT0     ; RESET TO CONDITION 0.
                JMP DOSEXIT     ; GO TO DOS'S EXIT ROUTINE.


                                ; =================================
                                ; EXEC'S READ DATA ROUTINE.
                                ; =================================

READEXEC        JSR PT2EXEC     ; POINT THE A3L/H POINTER AT BUF
                                ; THAT WE'RE EXECING IN.
                JSR BUFS2PRM    ; COPY ADDRS OF THE VARIOUS DOS
                                ; BUFS FROM THE CHAIN BUF & PUT
                                ; THEM IN THE FM PARAMETER LIST.
                LDA #3          ; SET CONDITION 3 SO PROCESS DATA
                BNE SETCOND     ; INPUT FROM THE DISK.


                                ; =================================
                                ; READ A TEXT FILE BYTE.
                                ; =================================

RDTXTBYT        LDA #3          ; SET FM PRM LIST 2 READ ONE BYTE.
                STA OPCODEFM
                LDA #1
                STA SUBCODFM
                JSR FMDRIVER    ; CALL FM DRIVER TO READ A BYTE.
                LDA ONEIOBUF    ; LOAD (A) WITH BYTE JUST READ.
                RTS


                                ; =================================
                                ; POINT THE A3L/H POINTER AT
                                ; BUFFER THAT WE'RE EXECING IN.
                                ; =================================

PT2EXEC         LDA EXECBUFF+1  ; GET ADR OF DOS BUF USING 2 EXEC.
                STA A3H         ; PUT IT IN POINTER.
                LDA EXECBUFF
                STA A3L
PT2EXEC2        RTS


                                ; =================================
                                ; THE FILE MANAGER DRIVER.
                                ; =================================

FMDRIVER        JSR FILEMGR     ; CALL FM MANAGER TO DO FUNCTION.

                                ; RETURN HERE AFTER DOING THE FUNCTION.
                                ; (CAUSE, USE STACK TO GET BACK TO
                                ; ORIGINAL CALLER OF FUNCTION.)
                                ; IF WE JUST DID A READ FUNCTION &
                                ; THE LAST BYTE READ WAS FROM A DATA
                                ; SECTOR, THEN ENTER WITH (C)=0.
                                ; (NOTE THAT IT MAKES NO DIFFERENCE
                                ; IF THAT DATA BYTE WAS A $00 OR NOT.)
                                ; HOWEVER, IF WE ARE DEALING WITH A
                                ; ZEROED-OUT T/S LINK OR A ZEROED-OUT
                                ; DATA-PAIR BYTE FROM A T/S LIST,
                                ; THEN ENTER WITH CARRY SET.


                IF DOS31
                BCS AFTRFUNC2
                RTS
                ELSE
AFTRFUNC        BCC FMDRVRTN    ; (C) = 0 = NO ERRORS.
                ENDIF

                IF DOS32
                JSR GETBUFF
                BCS AFTRFUNC2
                LDA #0
                TAY
                STA (A3L),Y
                ENDIF

AFTRFUNC2
                LDA RTNCODFM    ; GET RETURN CODE FRM FM PARM LIST
                CMP #5          ; "END-OF-DATA" ERROR?
                IF DOS31
                BNE FMDRVRTN2

                ELSE
                IF DOS32
                BNE ERRHNDLR
                ELSE
                BEQ TOAPPTCH    ; YES -NOT HANDLED LIKE OTHER ERRS
                                ; FILE ENDS AT A FULL DATA SEC SO
                                ; WE ENCOUNTERED A ZEROED-OUT T/S
                                ; LINK OR A ZEROED-OUT DATA PAIR
                                ; (TRK/SEC VALUES LISTED IN A T/S
                                ; LIST).
                JMP OTHRERR     ; ONLY TAKE IF GOT AN ERROR OTHER
                                ; THAN AN END-OF-DATA ERROR.
TOAPPTCH        JMP APNDPTCH    ; GO HANDLE END-OF-DATA ERROR.

                NOP
                IF DOS33_1986 || DOS33_1983
BK2FMDRV        JSR CKIFAPND    ; <---NOTE: APNDPTCH RETURN HERE!!
                                ; GO CHK IF THE APPEND FLAG IS ON.
                ELSE
                IF DOS33_1980
                NOP
BK2FMDRV        NOP
                NOP
                ENDIF
                ENDIF
                ENDIF
                ENDIF

                LDX #0          ; ZERO-OUT THE ONE-DATA-BYTE BUF
                STX ONEIOBUF    ; IN THE FM PARAMETER LIST.  (ALSO
                                ; REFERRED TO AS THE LOW BYTE OF
                                ; CURIOBUF.)
FMDRVRTN        RTS             ; RETURN TO CALLER OF FM DRIVER.
                IF DOS31
BK2FMDRV
FMDRVRTN2       JMP ERRHNDLR
                ENDIF

                                ; =================================
                                ; SELECTED ERROR PROCESSING.
                                ; =================================
                                ; NOTE: PROGRAMMERS WHO ACCESS DOS
                                ; FROM ASSEMBLY LANGUAGE PROGRAMS
                                ; SHOULD TAKE SPECIAL NOTE OF THE
                                ; THE FORMATTED DISASSEMBLY TITLED
                                ; "DISASSEMBLY OF ERRORS".


SYNTXERR        LDA #11
                BNE ERRHNDLR    ; ALWAYS.
NOBUFERR        LDA #12
                BNE ERRHNDLR    ; ALWAYS.
TOOLARGE        LDA #14
                BNE ERRHNDLR    ; ALWAYS.
TYPMISM         LDA #13

                IF DOS31
                BNE ERRHNDLR    ; ALWAYS.
NOTBINARY       LDA #15
                ENDIF

                                ; =================================
                                ; DOS'S MAIN ERROR-HANDLER ROUTINE
                                ; =================================

ERRHNDLR        STA ASAVED      ; SAVE RETURN CODE FOR LATER USE.
                IF DOS31
                JSR RESTAT0
                ELSE
                JSR RESTATIN    ; RESET THE FOLLOWING FLAGS TO 0:
                                ; OPUTCOND, CONDNFLG & RUNTRUPT.
                ENDIF
                LDA ACTBSFLG    ; CHK IF INT OR FP BASIC ACTIVE.
                BEQ WASINT      ; BRANCH IF USING INTEGER.
                                ; (ONERR FLAG NOT APPLIC TO INT.)
                LDA ERRFLG      ; CHK IF BASIC'S ONERR FLAG IS ON.
                IF DOS31
                BMI ONERRACT2
                ELSE
                BMI ONERRACT    ; YES - SKIP PRINTING OF ERROR MSG
                                ; CAUSE WE EVENTUALLY WANT 2 GO 2
                                ; OUR OWN CUSTOMIZED ERROR-HNDLING
                                ; ROUTINE.
                ENDIF
WASINT          LDX #0          ; INITIALIZE INDEX TO TABLE OF
                                ; OFFSETS TO ERRORS.
                JSR PRDOSERR    ; GO PRINT <RTN>, BELL, <RTN>.
                LDX ASAVED      ; GET SAVED RETURN CODE.
                JSR PRDOSERR    ; GO PRINT THE ERROR MESSAGE.
                IF DOS31
                LDX #$10
                ELSE
                JSR CRVIADOS    ; PRINT A <CR>.
                ENDIF
ONERRACT
                IF DOS31
                JSR PRDOSERR
                ELSE
                JSR INITIOHK    ; RESET I/O HKS TO POINT TO DOS.
                ENDIF
ONERRACT2
                IF DOS31
                JSR INITIOHK
                ELSE
                JSR CKBSCRUN    ; CHK IF BASIC IS RUNNING A PRGM:
                                ; (C) = 0 IF RUNNING.
                                ; (C) = 1 IF IMMEDIATE.
                ENDIF
                LDX ASAVED      ; GET SAVED RETURN CODE.
                LDA #3          ; SET (A) = 3 IN CASE FALL THRU TO
                                ; GO TO BASIC'S ERROR HANDLING
                                ; ROUTINE. THE MAGIC # OF 3 ALLOWS
                                ; BSCERHLR ($D865) TO CONDITION
                                ; (C) = 0 AND (Z) = 1 IN ORDER TO
                                ; COMPLY WITH THE BASIC ROUTINE
                                ; THAT IS RESPONSIBLE FOR PRINTING
                                ; BASIC'S ERROR MESSAGES.
                IF !DOS31
                BCS DOWRM       ; BASIC IS NOT RUNNING.
                ENDIF

TOBSCERR        JMP (ADBSCERR)  ; 2 BASIC'S ERROR HANDLING ROUTINE
                                ; (BSCERHLR, $D865).

                IF !DOS31
DOWRM           JMP (TOWRMVEC)  ; TO BASIC'S WARMSTART ROUTINE
                                ; (RESTART, $D43C).
                ENDIF


                                ; =================================
                                ; PRINT THE DOS ERROR MESSAGE.
                                ; =================================

PRDOSERR        LDA OFF2ERR,X   ; USE ERROR CODE TO GET OFFSET TO
                                ; ERROR MESSAGE.
                TAX             ; (X) = OFFSET INTO THE TABLE
                                ; CONTAINING THE TEXT OF THE DOS
                                ; ERROR MESSAGES.
MORERMSG        STX TEMPBYT     ; SAVE OFFSET INTO TXT TABLE.
                LDA ERRTXTBL,X  ; GET CHAR OF ERROR MESSAGE.
                PHA             ; SAVE IT ON STACK.
                ORA #$80        ; TURN HI BIT ON 2 SATISFY MONITOR
                JSR GODSPLY     ; GO PRINT VIA TRUE OUTPUT HANDLER
                LDX TEMPBYT     ; RESET OFFSET TO TABLE OF TEXT.
                INX             ; KICK INDEX UP FOR NXT CHR OF MSG
                PLA             ; GET ORIG CHAR BACK IN (A).
                BPL MORERMSG    ; BRANCH IF MORE CHRS IN MSG 2 PRT
                RTS             ; ALL BUT LAST CHR IN MSG ARE POS.


                                ; =================================
                                ; PUT VOL, DRV, AND SLOT VALUES
                                ; PLUS THE ADR OF THE PRIMARY FILE
                                ; NAME BUFFER IN FM PARAMETER LIST
                                ; =================================

CPY2PARM        LDA VOLPRSD     ; FROM PARSED TABLE.
                STA VOLFM
                LDA DRVPRSD     ; FROM PARSED TABLE.
                STA DRVFM
                LDA SLOTPRSD    ; FROM PARSED TABLE.
                STA SLOTFM
                LDA ADRPFNBF    ; GET THE ADR OF THE PRIMARY FILE
                STA FNAMBUFM    ; NAME BUF FROM THE CONSTANTS TBL
                LDA ADRPFNBF+1  ; AND PUT IT IN THE FM PARM LIST.
                STA FNAMBUFM+1
                LDA A3L         ; SAVE ADR OF CURRENT DOS FILENAME
                STA CURFNADR    ; BUF IN TABLE OF DOS VARIABLES.
                LDA A3H
                STA CURFNADR+1
                RTS


                                ; ===================================
                                ; COPY NAME OF FILE FROM THE PRIMARY
                                ; FILENAME BUFFER TO THE APPROPRIATE
                                ; DOS NAME BUFFER LOCATED IN THE
                                ; CHAIN OF DOS BUFFERS.
                                ; THIS ASSIGNS (OR RE-ASSIGNS) A DOS
                                ; BUFFER TO THE FILE WE WANT TO OPEN.
                                ; THE HIGHEST NUMBERED (LOWEST IN
                                ; MEMORY) FREE DOS BUFFER IS USED.
                                ; ===================================

CPYPFN          LDY #29         ; 30 BYTES TO COPY (0 TO 29).
CPYPRIM         LDA PRIMFNBF,Y  ; GET CHAR FROM PRIMARY.
                STA (A3L),Y     ; STORE IT IN DOS NAME BUF.
                DEY             ; REDUCE COUNTER.
                BPL CPYPRIM     ; MORE CHARS TO COPY.
                RTS


                                ; ====================================
                                ; GET THE ADDRS OF THE VARIOUS DOS
                                ; BUFS FROM THE CURRENT DOS CHAIN
                                ; BUF & PUT THEM IN THE FM PARM LIST.
                                ; ====================================

BUFS2PRM        LDY #30         ; GET ADR OF FM WORK BUF, T/S LIST
ADRINPRM        LDA (A3L),Y     ; BUF, DATA SECTOR BUF & NEXT
                STA WRKBUFFM-30,Y
                                ; DOS FILE NAME BUF FROM CHAIN
                INY             ; PTRS BUF & PUT IN FM PARM LIST.
                CPY #38         ; (PS. ADDR OF NEXT DOS FILE NAME
                BNE ADRINPRM    ; BUF IS NOT USED BY DOS.)
                RTS


                                ; =================================
                                ; RESET CONDNFLG & OPUTCOND TO 0.
                                ; =================================

RESTAT0         LDY #0
                STY CONDNFLG
                STY OPUTCOND
                RTS


                                ; ==================================
                                ; LOCATE BUFFER WITH SAME NAME.
                                ; IF THAT FAILS, LOCATE A FREE BUF.
                                ; ==================================

GETBUFF         LDA #0          ; DEFAULT HI BYTE OF PTR TO 0.
                STA A5H         ; (IE. ASSUME NO FREE BUFS AVAIL.)
                JSR GETFNBF1    ; PT A3L/H AT 1RST DOS FILE NAME
                                ; BUFFER IN THE DOS BUFFER CHAIN.
                JMP FNCHAR1     ; GO GET 1RST CHR OF NAME FRM BUF.
GETFNLNK        JSR GETNXBUF    ; GET ADR OF NXT NAME BUF IN CHAIN
                                ; FROM CHAIN POINTERS BUF(WHICH IS
                                ; OFFSET 37 & 36 BYTES FROM 1RST
                                ; CHAR OF PRESENT FILE NAME BUF).
                BEQ NOFNMTCH    ; LINK ZEROED OUT=END OF BUF CHAIN
FNCHAR1         JSR GETFNBY1    ; GET 1RST CHR OF NAME FRM NAM BUF
                BNE NXFNBUF     ; TAKE BRANCH IF BUF NOT FREE.
                LDA A3L         ; BUF WAS FREE, THERE4 POINT THE
                STA A5L         ; A5L/H POINTERS AT THE FREE BUF.
                LDA A3H
                STA A5H
                BNE GETFNLNK    ; ALWAYS.

NXFNBUF         LDY #29         ; BUF WASN'T FREE SO CMP NAME OF
CMPFNCHR        LDA (A3L),Y     ; OWNER WITH NAME OF FILE IN
                CMP PRIMFNBF,Y  ; PRIMARY FILE NAME BUF.  (START
                                ; WITH LAST CHAR FIRST.)
                BNE GETFNLNK    ; CHAR DIDN'T MATCH, SO LOOK FOR
                                ; ANOTHER BUF THAT MIGHT HAS SAME
                                ; FILE NAME.
                DEY             ; THAT CHAR MATCHED.  HOW ABOUT
                                ; REST OF CHARS IN NAME?
                BPL CMPFNCHR    ; 30 CHARS IN NAME (IE. 0 TO 29).
                CLC             ; (C)=0 TO SIGNAL NAMES MATCHED.
                RTS

NOFNMTCH        SEC             ; LINK ZEROED OUT.
                RTS


                                ; ===================================
                                ; POINT THE A3L/H POINTER AT THE
                                ; FIRST DOS FILE NAME BUFFER IN
                                ; THE DOS BUFFER CHAIN.  (IE. LOWEST
                                ; NUMBERED BUFFER, BUT HIGHEST IN
                                ; MEMORY.)
                                ; ===================================

GETFNBF1        LDA ADOSFNB1    ; GET 1RST LINK TO CHAIN OF BUFS.
                LDX ADOSFNB1+1
                BNE SETNXPTR    ; ALWAYS.


                                ; =================================
                                ; GET ADR OF NXT FILENAME BUF IN
                                ; CHAIN FROM THE CURRENT CHAIN
                                ; POINTERS BUF (WHICH IS OFFSET
                                ; 37 & 36 BYTES FROM 1RST CHAR
                                ; IN PRESENT DOS FILE NAME BUF).
                                ; ---------------------------------

GETNXBUF        LDY #37         ; OFFSET TO CHAIN BUF.
                LDA (A3L),Y     ; PICK UP ADR OF NEXT NAME BUF.
                BEQ GETNXRTN    ; IF HI BYTE=$00, LINK ZEROED OUT.
                TAX             ; SAVE HI BYTE IN (X).
                DEY             ; OFFSET FOR LOW BYTE.
                LDA (A3L),Y     ; PUT ADR OF FILE NAME BUF IN PTR.
SETNXPTR        STX A3H         ; PUT HI BYTE IN POINTER.
                STA A3L         ; PUT LOW BYTE IN POINTER.
                TXA             ; GET HI BYTE BACK IN (A).
GETNXRTN        RTS


                                ; =================================
                                ; GET 1RST CHAR OF FILE NAME
                                ; FROM DOS FILE NAME BUFFER.
                                ; =================================

GETFNBY1        LDY #0          ; BUF IS FREE IF 1RST BYTE = $00.
                LDA (A3L),Y     ; ELSE 1RST BYTE = 1RST CHAR OF
                RTS             ; NAME OF FILE WHICH OWNS BUF.


                                ; =================================
                                ; CHECK IF THE CURRENT FILE NAME
                                ; BUFFER BELONGS TO AN EXEC FILE.
                                ; (AFTER ALL, WE DON'T WANT TO
                                ; PREMATURELY CLOSE A FILE IF WE
                                ; ARE USING IT TO EXEC - WOULD BE
                                ; LIKE BURYING OURSELVES ALIVE).
                                ; =================================

CKEXCBUF        LDA EXECFLAG    ; CHK TO SEE IF EXECING.
                BEQ NOTEXCBF    ; BRANCH IF NOT EXECING.
                LDA EXECBUFF    ; WE ARE EXECING, THERE4 CHK IF BUF
                CMP A3L         ; BELONGS TO THE EXEC FILE.
                BNE CKEXCRTN    ; NO.
                LDA EXECBUFF+1  ; MAYBE - LOW BYTES MATCHED SO
                CMP A3H         ; CHK HI BYTES OF ADR.
                BEQ CKEXCRTN    ; YES, EXEC BUF = CURRENT BUF.
NOTEXCBF        DEX             ; NOT EXECING, SO REDUCE (X) TO
                                ; MAKE SURE THAT Z-FLAG IS OFF.
                                ; (PS. (X) WAS ORIG CONDITIONED TO
                                ; A LARGE NON-ZERO VAL ON ENTRY
                                ; TO GETFNBF1, THERE4, IF NOW DEX,
                                ; THEN INSURE Z-FLAG OFF.)
CKEXCRTN        RTS             ; EXIT WITH:
                                ; Z-FLAG = 1 IF EXECING.
                                ; = 0 IF NOT EXECING.


                                ; ======================================
                                ; CHK IF FILE TYPE WANTED = TYPE FOUND.
                                ; ======================================

CHKFTYPE        EOR FILTYPFM    ; TYPE FOUND (VIA OPEN FUNCTION).
                BEQ CKTYPRTN    ; BRNCH IF TYPE WANTED=TYPE FOUND.
                AND #%01111111  ; MAYBE MATCHED-DISREGARD LOCK BIT
                BEQ CKTYPRTN    ; BRANCH IF MATCHED.
                JSR CMDCLOSE    ; NAMED FILE IS WRONG TYPE, SO GO
                JMP TYPMISM     ; CLOSE FILE & EXIT WITH A TYPE-
                                ; MISMATCH ERROR MESSAGE.
CKTYPRTN        RTS             ; TYPE WANTED = TYPE FOUND.


                                ; =================================
                                ; BUILD THE DOS BUFFERS.
                                ; =================================

                                ; POINT A3L/H AT FILENAME FIELD
                                ; IN THE LOWEST NUMBERD (HIGHEST
                                ; IN MEMORY) DOS BUFFER.

BILDBUFS        SEC             ; IRREL, MIGHT AS WELL BE A "NOP".
                LDA ADOSFNB1    ; GET ADDR OF 1RST FILE NAME FIELD
                STA A3L         ; & PUT IT IN A3L/H POINTER.
                LDA ADOSFNB1+1
                STA A3H

                                ; GET # OF MAXFILES WANTED & STORE
                                ; IT IN THE COUNTER (TEMPBYT).

                LDA MXFILVAL
                STA TEMPBYT

                                ; FREE BUFFER BY ZEROING OUT THE
                                ; FIRST BYTE OF THE DOS BUFFER'S
                                ; FILE NAME FIELD.

ZDOSBUFN        LDY #0
                TYA
                STA (A3L),Y


                                ; POINT LINK IN CHAIN POINTERS BUF
                                ; AT FM WORK AREA BUFFER.

                LDY #30         ; SET (Y) TO INDEX 1RST LINK IN
                                ; CHAIN POINTERS BUFFER.
                SEC
                LDA A3L         ; SUBT 45 FROM LOW BYTE OF ADDR
                SBC #45         ; OF NAME BUF TO CALC LOW BYTE OF
                STA (A3L),Y     ; ADDR OF FM WORK BUF & PUT IT IN
                PHA             ; THE CHAIN PTR BUF & ON THE STK.
                LDA A3H         ; SUBT (C) FROM HIGH BYTE OF ADR
                SBC #0          ; OF NAME BUF TO GET HI BYTE OF
                                ; FM WRK BUF ADR.
                INY             ; KICK UP (Y) TO INDEX ADDR OF HI
                                ; BYTE OF LINK IN CHAIN POINTERS.
                STA (A3L),Y     ; STORE HI BYTE OF ADR OF FM WRK
                                ; BUF IN THE LINK.
                                ; (NOTE:  ABOVE CALCS EFFECT (A)
                                ; BUT NOT A3L/H.)

                                ; POINT LINK IN CHAIN POINTERS BUFFER
                                ; AT T/S LIST SECTOR BUFFER.

                TAX             ; PUT HI BYTE OF ADDR OF FM WRK BUF
                DEX             ; IN (X) & KICK IT DOWN SO IT
                                ; INDEXES HI BYTE OF T/S LIST BUF.
                                ; (T/S LST BUF = $100 BYTES LONG.)
                PLA             ; GET LOW BYTE OF ADDR OF FM WRK
                PHA             ; BACK FROM STK.
                INY             ; KICK UP INDEX TO LINK IN CHAIN
                                ; POINTERS BUFFER.
                STA (A3L),Y     ; PUT LOW BYTE OF FM WRK BUF ADR
                                ; IN LINK BUFFER'S POINTERS.
                TXA             ; GET HI BYTE T/S LIST BUF IN (A).
                INY             ; KICK UP INDEX IN CHAIN BUF.
                STA (A3L),Y     ; PUT HI BYTE OF LINK IN PTRS BUF.

                                ; POINT LINK IN CHAIN POINTERS BUF
                                ; AT DATA SECTOR BUFFER.

                TAX             ; PUT HI BYTE OF ADDR OF T/S LIST
                DEX             ; BUF IN (X) & KICK IT DOWN TO
                                ; CORRESPOND TO HI BYTE OF ADDR
                                ; OF DATA SEC BUF.
                PLA             ; GET LOW BYTE OF T/S LIST SEC BUF
                PHA             ; FROM STACK & USE IT FOR LOW BYTE
                                ; OF DATA SEC BUF (CAUSE THEY ARE
                                ; EXACTLY 1 PAGE APART).
                INY             ; KICK UP INDEX TO CHAIN BUF.

                STA (A3L),Y     ; PUT LOW BYTE OF DATA SEC BUF
                                ; IN LINK.
                INY             ; KICK UP INDEX TO CHAIN BUF.
                TXA             ; GET HI BYTE OF ADR OF T/S LIST
                STA (A3L),Y     ; BUF & DESIGN8 AS HI BYT OF LINK.

                                ; REDUCE COUNTER FOR # OF BUFS TO BUILD.

                DEC TEMPBYT     ; IF COUNTER GOES TO 0, THEN JUST
                BEQ ZLNK2NXT    ; DID LAST BUF & SHOULD 0 OUT LNK.

                                ; NOT DONE ALL BUFS YET SO POINT
                                ; LINK IN CHAIN POINTERS BUFFER
                                ; AT NEXT FILE NAME FIELD.

                TAX             ; SET (X) = LOW BYTE OF ADR OF DATA
                                ; SECTOR BUFFER.
                PLA             ; GET LOW BYTE OF ADDR OF DATA
                                ; SECTOR BUF BACK OFF STK.
                SEC             ; SUBT 38 FROM LOW BYTE OF DATA SEC
                SBC #38         ; ADR TO INDEX NEXT NAME BUF.
                INY             ; KICK UP INDEX TO CHAIN BUF.
                STA (A3L),Y     ; STORE LOW BYTE OF ADR OF NEXT
                PHA             ; NAME BUF IN LINK & THEN SAVE
                                ; IT ON STK.
                TXA             ; GET HI BYTE OF ADR OF DATA SEC
                SBC #0          ; BUF FROM (X) & SUBT (C) (IN CASE
                                ; CROSS PAGE BOUNDARY) TO GET
                                ; (A) = HI BYTE OF NEXT NAME BUF.
                INY             ; KICK INDEX UP TO CHAIN PTRS BUF
                STA (A3L),Y     ; & STORE HI BYTE OF NEXT NAME BUF
                                ; IN LINK.

                                ; POINT A3L/H AT NEXT NAME BUF.

                STA A3H
                PLA
                STA A3L
                JMP ZDOSBUFN    ; GO BACK TO FREE NEXT NAME BUF
                                ; & BUILD MORE DOS BUFFERS.

                                ; NO MORE BUFS TO BUILD SO ZERO OUT
                                ; THE LINK THAT WOULD NORMALLY POINT
                                ; TO THE NEXT NAME BUFFER.

ZLNK2NXT        PHA             ; SAVE LOW BYTE OF ADR OF DATA BUF
                                ; ON STK.
                LDA #0          ; ZERO OUT LINK TO NEXT NAME BUF.
                INY
                STA (A3L),Y
                INY
                STA (A3L),Y

                                ; CHK WHICH BASIC IS ACTIVE.

                LDA ACTBSFLG    ; CHK IF ACTV BASIC IS FP OR INT.
                BEQ SETINTPT    ; BRANCH IF INTEGER.

                                ; USING APPLESOFT, SO INITIALIZE
                                ; MEMSIZ & FRETOP (STRING STORAGE)
                                ; TO A VALUE 1 BYTE GREATER THAN
                                ; HIGHEST MEMORY LOCATION AVAILABLE
                                ; TO BASIC PROGRAM.

                PLA
                STA MEMSIZ+1
                STA FRETOP+1
                PLA
                STA MEMSIZ
                STA FRETOP
                RTS             ; EXIT TO CALLER OF MAXFILES CMD.
                                ; (USUALLY EXITS 2 AFTRCMD ($A17D)
                                ; LOCATED IN THE DOS CMD PARSING
                                ; AND PROCESSING ROUTINES.)

                                ; USING INTEGER, SO SET HIMEM AND
                                ; PROGRAM POINTER (INTPGMST).

SETINTPT        PLA
                STA HIMEM+1
                STA INTPGMST+1
                PLA
                STA HIMEM
                STA INTPGMST
                RTS             ; EXIT TO CALLER OF MAXFILES CMD.
                                ; (USUALLY EXITS 2 AFTRCMD ($A17D)
                                ; LOCATED IN THE DOS CMD PARSING
                                ; AND PROCESSING ROUTINES.)

                                ; ===================================
                                ; INITIALIZE THE I/O HOOKS SO THAT
                                ; DOS INTERCEPTS ALL INPUT & OUTPUT.
                                ; ===================================

                                ; FOR INSTANCE, IF A ROUTINE ACCESSES
                                ; "COUT: JMP (CSW)" THEN EXECUTION
                                ; WILL ACTUALLY FLOW TO DOS'S
                                ; OUTPUT ROUTINE (OPUTINCP, $9EBD).
                                ; SIMILARLY, ANY ROUTINE THAT REFERS
                                ; TO "RDKEY: JMP (KSW)" WILL ACTUALLY
                                ; JUMP TO DOS'S INPUT ROUTINE
                                ; (INPTINCP, $9E81).
                                ;
                                ; THE TRUE (IE. NORMAL) HOOKS ARE SAVED,
                                ; EX.  KSW: KEYIN --> KSWTRUE: KEYIN.
                                ; CSW: COUT1 --> CSWTRUE: COUT1.
                                ; THEN THE INTERCEPTS ARE SET AS FOLLOWS:
                                ; ADINPTCP: INPTINCP --> KSW: INPTINCP.
                                ; ADOPUTCP: OPUTINCP --> CSW: OPUTINCP.

                                ; CHECK IF INPUT HOOK NEEDS TO BE RESET.
INITIOHK        LDA KSW+1
                CMP ADINPTCP+1
                BEQ CKOUTHK     ; INPUT HK ALREADY POINTS 2 DOS'S
                                ; INPUT HNDLER SO GO CHK OUTPUT HK

                                ; RESET INPUT HOOK TO POINT TO DOS.

                STA KSWTRUE+1   ; KSW: KEYIN --> KSWTRUE: KEYIN.
                LDA KSW
                STA KSWTRUE
                LDA ADINPTCP    ; ADINPTCP:INPTINCP-->KSW:INPTINCP
                STA KSW
                LDA ADINPTCP+1
                STA KSW+1

                                ; CHECK IF OUTPUT HOOK NEEDS TO BE RESET.

CKOUTHK         LDA CSW+1
                CMP ADOPUTCP+1
                BEQ SETHKRTN    ; OUTPUT HK ALREADY PTS TO DOS'S
                                ; OUTPUT HANDLER, SO EXIT.

                                ; RESET OUTPUT HOOK TO POINT TO DOS.

                STA CSWTRUE+1   ; CSW: COUT1 --> CSWTRUE: COUT1.
                LDA CSW
                STA CSWTRUE
                LDA ADOPUTCP    ; ADOPUTCP:OPUTINCP-->CSW:OPUTINCP
                STA CSW
                LDA ADOPUTCP+1
                STA CSW+1
SETHKRTN        RTS



                                ; ========================================
                                ; DOS COMMAND TEXT TABLE ($A884 - $A908).
                                ; ========================================
                                ; THE NAMES OF THE DIFFERENT DOS COMMANDS
                                ; CAN READILY BE CHANGED BY ALTERING THE
                                ; INFORMATION IN THIS TABLE.  IF YOU
                                ; DECIDE TO MESS AROUND WITH THIS TABLE,
                                ; BE SURE TO:
                                ; - LET THE 1RST CMD CREATE A NEW FILE.
                                ; (FOR EXPLANATION, SEE FMXTNTRY
                                ; ROUTINE ($AAFD) IN LINEAR DIS'MBLY.)
                                ; - AVOID CREATING NEW DOS CMD NAMES
                                ; THAT DUPLICATE BASIC CMD NAMES.
                                ; - USE POSITIVE ASCII CHARS FOR ALL BUT
                                ; THE LAST CHAR OF EACH NAME.
                                ; - ENTER THE LAST CHAR IN EACH NAME IN
                                ; NEGATIVE ASCII FORM.
                                ; - SHIFT SUBSEQUENT NAMES TO KEEP ALL
                                ; CHARS CONTIGUOUS IF YOU CREATE
                                ; SHORTER NAMES.
                                ; - DON'T EXPAND THE TABLE BEYOND $A908.
                                ; - END THE TABLE WITH A $00 BYTE.
                                ; ========================================

CMDTXTBL        DB "INI","T"|0x80
                DB "LOA","D"|0x80
                DB "SAV","E"|0x80
                DB "RU","N"|0x80
                DB "CHAI","N"|0x80
                DB "DELET","E"|0x80
                DB "LOC","K"|0x80
                DB "UNLOC","K"|0x80
                DB "CLOS","E"|0x80
                DB "REA","D"|0x80
                DB "EXE","C"|0x80
                DB "WRIT","E"|0x80
                DB "POSITIO","N"|0x80
                DB "OPE","N"|0x80
                DB "APPEN","D"|0x80
                DB "RENAM","E"|0x80
                DB "CATALO","G"|0x80
                DB "MO","N"|0x80
                DB "NOMO","N"|0x80
                DB "PR","#"|0x80
                DB "IN","#"|0x80
                DB "MAXFILE","S"|0x80
                DB "F","P"|0x80
                DB "IN","T"|0x80
                DB "BSAV","E"|0x80
                DB "BLOA","D"|0x80
                DB "BRU","N"|0x80
                DB "VERIF","Y"|0x80
                DB $00          ; $00 BYTE DENOTES END OF TABLE.


                                ; ========================================
                                ; TABLE OF ATTRIBUTES & VALID OPTIONS
                                ; THAT ARE ASSOCIATED WITH EACH COMMAND.
                                ; ($A909 - $A940)
                                ; ========================================

                                ; NOTE:  ANY ALTERATIONS TO THIS TABLE
                                ; SHOULD BE DONE WITH A DEGREE OF CAUTION
                                ; BECAUSE SEVERAL PARAMETERS ACQUIRE
                                ; CERTAIN DEFAULT VALUES IN THE ACTUAL
                                ; COMMAND-HANDLING ROUTINES.  WITH JUST
                                ; A BIT OF INSPECTION OF THE HANDLING
                                ; ROUTINES HOWEVER, YOU SHOULD BE ABLE TO
                                ; SAFELY MAKE EXTENSIVE CHANGES IF YOU SO
                                ; DESIRE.
                                ;
                                ; THIS TABLE IS INDEXED BY A VALUE
                                ; CORRESPONDING TO THE PARSED DOS
                                ; COMMAND.  TWO BYTES OF INFORMATION
                                ; ARE ASSOC WITH @ CMD.  A SET BIT
                                ; DENOTES THE FOLLOWING:
                                ;
                                ; LO BYTE
                                ; 7  6  5  4  3  2  1  0
                                ; .  .  .  .  .  .  .  .
                                ; .  .  .  .  .  .  .  ...CMD CAN CREATE NEW FILE IF FILE
                                ; .  .  .  .  .  .  .     NOT FOUND.
                                ; .  .  .  .  .  .  ......CMD RESTRICTED TO DEFERRED MODE.
                                ; .  .  .  .  .  .........VALUE FOR MAXFILES REQUIRED.
                                ; .  .  .  .  ............VALUE FOR PR# OR IN# REQUIRED.
                                ; .  .  .  ...............2ND FILENAME NEEDED (RENAME CMD)
                                ; .  .  ..................FILE NAME APPLICABLE TO CMD
                                ; .  .                    (EXPECTED BUT NOT NECESSARILY
                                ; .  .                    REQUIRED.)
                                ; .  .................... DO DOS CMD EVEN IF NO NAME GIVEN
                                ; ....................... INTERPRET AS BASIC CMD IF NO NAM

                                ; HI BYTE
                                ; 7  6  5  4  3  2  1  0
                                ; .  .  .  .  .  .  .  .
                                ; .  .  .  .  .  .  .  ...A(DDRESS) PARAMETER ALLOWED.
                                ; .  .  .  .  .  .  ......B(YTE) PARAMETER ALLOWED.
                                ; .  .  .  .  .  .........R(ECORD) # OR R(EL FIELD POS'N)
                                ; .  .  .  .  .           PARAMETER ALLOWED.
                                ; .  .  .  .  ............L(ENGTH) PARAMETER ALLOWED.
                                ; .  .  .  ...............S(LOT) PARAMETER ALLOWED.
                                ; .  .  ..................D(RIVE) PARAMETER ALLOWED.
                                ; .  .....................V(OLUME) PARAMETER ALLOWED.
                                ; ........................C, I, OR O PARAMETER ALLOWED.

CMDATTRB
                IF DOS31
                DW %0111000000100000 ; INIT
                ELSE
                DW %0111000000100001 ; INIT
                ENDIF
                DW %0111000010100000 ; LOAD
                IF DOS31
                DW %0111000010100000 ; SAVE
                ELSE
                DW %0111000010100001 ; SAVE
                ENDIF
                DW %0111000010100000 ; RUN
                DW %0111000000100000 ; CHAIN
                DW %0111000000100000 ; DELETE
                DW %0111000000100000 ; LOCK
                DW %0111000000100000 ; UNLOCK
                DW %0000000001100000 ; CLOSE
                IF DOS31
                DW %0000011000100000 ; READ
                ELSE
                DW %0000011000100010 ; READ
                ENDIF
                DW %0111010000100000 ; EXEC
                IF DOS31
                DW %0000011000100000 ; WRITE
                DW %0000010000100000 ; POSITION
                DW %0111100000100000 ; OPEN
                DW %0111100000100000 ; APPEND
                ELSE
                DW %0000011000100010 ; WRITE
                DW %0000010000100010 ; POSITION
                DW %0111100000100011 ; OPEN
                DW %0111000000100010 ; APPEND
                ENDIF
                DW %0111000000110000 ; RENAME
                DW %0111000001000000 ; CATALOG
                DW %1000000001000000 ; MON
                DW %1000000001000000 ; NOMON
                DW %0000000000001000 ; PR#
                DW %0000000000001000 ; IN#
                DW %0000000000000100 ; MAXFILES
                DW %0111000001000000 ; FP
                DW %0000000001000000 ; INT
                IF DOS31
                DW %0111100100100000 ; BSAVE
                ELSE
                DW %0111100100100001 ; BSAVE
                ENDIF
                DW %0111000100100000 ; BLOAD
                DW %0111000100100000 ; BRUN
                DW %0111000000100000 ; VERIFY




                                ; =================================
                                ; OPTION CHARACTER SYMBOL TABLE.
                                ; ($A941 - $A94A)
                                ; THESE CHARACTERS ARE FREQUENTLY
                                ; CHANGED AS PART OF A PROTECTION
                                ; SCHEME.
                                ; =================================

                CMAP     " ",160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
                CMAP     "@",192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
                CMAP     "`",224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
OPTNTXT         DB "VDSLRBACIO"
                CMAP


                                ; =================================
                                ; OPTIONS ISSUED TABLE
                                ; ($A94B - $A954)
                                ; A SET BIT IN THE FOLLOWING BIT
                                ; POSITIONS (OF CUMLOPTN) DENOTE
                                ; THE OPTIONS THAT WERE ISSUED
                                ; WITH THE COMMAND.
                                ; =================================

OPTNISSD        DB %01000000          ; V(OLUME) PARAMETER.
                DB %00100000          ; D(RIVE) PARAMETER.
                DB %00010000          ; S(LOT) PARAMETER.
                DB %00001000          ; L(ENGTH) PARAMETER.
                DB %00000100          ; R(ECORD # OR R(EL FIELD POS'N).
                DB %00000010          ; B(YTE) PARAMETER.
                DB %00000001          ; A(DDRESS) PARAMETER.
                DB %11000000          ; C(OMMAND).
                DB %10100000          ; I(NPUT).
                DB %10010000          ; O(UTPUT).

                                ; =================================
                                ; TABLE OF VALID RANGES ASSOCIATED
                                ; WITH EACH OPTION CHARACTER.
                                ; ($A955 - $A970)
                                ; (THESE VALUES ARE FREQUENTLY
                                ; CHANGED IN AN EFFORT TO
                                ; "ENHANCE" DOS OR IMPLEMENT
                                ; A PROTECTION SCHEME.  FOR
                                ; EXAMPLE, THE UPPER RANGE ASSOCIATED
                                ; WITH THE L-PARAMETER IS OFTEN
                                ; CHANGED TO ALLOW DOS TO HANDLE
                                ; LARGER FILES.
                                ; =================================

OPTNRNG
                DW 0,$100-2     ; ($A955 - $A958)  V: (0 - 254).
                DW 1,2          ; ($A959 - $A95C)  D: (1 - 2).
                DW 1,$8-1       ; ($A95D - $A960)  S: (1 - 7).
                DW 1,$8000-1    ; ($A961 - $A964)  L: (1 - 32767).
                DW 0,$8000-1    ; ($A965 - $A968)  R: (0 - 32767).
                DW 0,$8000-1    ; ($A969 - $A96C)  B: (0 - 32767).
                IF DOS31
                DW 0,$C000      ; ($A96D - $A970)  A: (0 - 49152).
                ELSE
                DW 0,$10000-1   ; ($A96D - $A970)  A: (0 - 65535).
                ENDIF


                                ; ==================================
                                ; TEXT TABLE OF DOS ERROR MESSAGES.
                                ; ($A971 - $AA3E)
                                ; NOTE THAT ONLY THE LAST CHARACTER
                                ; OF EACH TEXT MESSAGE IS WRITTEN
                                ; IN NEGATIVE ASCII FORM.  (THESE
                                ; MESSAGES ARE FREQUENTLY ALTERED
                                ; IN COMMERCIAL PROGRAMS.)
                                ; ==================================

ERRTXTBL
ERR00           DB $0D,$07
                IF DOS31
                DB "***DISK:"," "|0x80
                ELSE
                DB CR
                ENDIF


                IF DOS31
ERR01
ERR02
ERR03
                DB "SY","S"|0x80
                ELSE
ERR01           DB "LANGUAGE NOT AVAILABL","E"|0x80
ERR02
ERR03           DB "RANGE ERRO","R"|0x80
                ENDIF

ERR04
                IF DOS31
                DB "WRITE PROTEC","T"|0x80
                ELSE
                DB "WRITE PROTECTE","D"|0x80
                ENDIF


ERR05           DB "END OF DAT","A"|0x80
ERR06           DB "FILE NOT FOUN","D"|0x80
ERR07           DB "VOLUME MISMATC","H"|0x80

ERR08
                IF DOS31
                DB "DISK I/","O"|0x80
                ELSE
                DB "I/O ERRO","R"|0x80
                ENDIF

ERR09           DB "DISK FUL","L"|0x80
ERR10           DB "FILE LOCKE","D"|0x80

                IF DOS31
ERR11           DB "CMD SYNTA","X"|0x80
ERR12           DB "NO FILE BUFFS AVAI","L"|0x80
ERR13           DB "NOT BASIC PROGRA","M"|0x80
                ELSE
ERR11           DB "SYNTAX ERRO","R"|0x80
ERR12           DB "NO BUFFERS AVAILABL","E"|0x80
ERR13           DB "FILE TYPE MISMATC","H"|0x80
                ENDIF

ERR14           DB "PROGRAM TOO LARG","E"|0x80

                IF DOS31
ERR15           DB "NOT BINARY FIL","E"|0x80
ERR16           DB " ERROR"
                ELSE
ERR15           DB "NOT DIRECT COMMAN","D"|0x80
                ENDIF

                DB CR


                                ; =================================
                                ; TABLE OF OFFSETS TO THE ERROR
                                ; MSG TEXT TABLE ($AA3F - $AA4E).
                                ; (HACKERS OFTEN SWAP THESE BYTES
                                ; AROUND SO ERRONEOUS ERROR MSGS
                                ; WILL BE USED.)
                                ; =================================

OFF2ERR         DB ERR00-ERRTXTBL
                DB ERR01-ERRTXTBL
                DB ERR02-ERRTXTBL
                DB ERR03-ERRTXTBL
                DB ERR04-ERRTXTBL
                DB ERR05-ERRTXTBL
                DB ERR06-ERRTXTBL
                DB ERR07-ERRTXTBL
                DB ERR08-ERRTXTBL
                DB ERR09-ERRTXTBL
                DB ERR10-ERRTXTBL
                DB ERR11-ERRTXTBL
                DB ERR12-ERRTXTBL
                DB ERR13-ERRTXTBL
                DB ERR14-ERRTXTBL
                DB ERR15-ERRTXTBL
                IF DOS31
                DB ERR16-ERRTXTBL
                ENDIF
                                ; =================================
                                ; DOS MAIN ROUTINE VARIABLES.
                                ; ($AA4F - $AA65)
                                ; =================================

CURFNADR        DS 2            ; PTS TO CURRENT FILENAME BUF
                                ; (USUALLY PRIMFNBF, $AA75).
                                ; (NORMALLY LOADED FROM FNAMBUFM
                                ; $B5C3, IN FM PARM LIST).
CONDNFLG        DS 1            ; STATUS FLAG:
                                ; $00 = WARMSTART, $01 = READ
                                ; $80 = COLDSTART, $C0 = A(RAM).
OPUTCOND        DS 1            ; CHAR SWITCH OUTPUT CONDITION FLG
                                ; $00 = EVALUATE START OF INPUT
                                ; LINE.
                                ; $01 = GOT A DOS CTRL CHAR SO
                                ; COLLECT DOS COMMAND.
                                ; $02 = NOT A DOS CMD, SO JUST
                                ; PRT CHAR & RTN TO CALLER.
                                ; $03 = HANDLING INPUT OR GET
                                ; STATMENTS WHILE READING.
                                ; $04 = WRITING DATA TO DISK.
                                ; $05 = EVALUATE 1RST CHAR OF
                                ; DATA LINE READ FROM DSK.
                                ; $06 = IGNORE "?" PRMPT & RESET
                                ; TO CONDITION 0.
CSWTRUE         DW COUT1        ; ADR OF TRUE OUTPUT HANDLER.
KSWTRUE         DW KEYIN        ; ADR OF TRUE INPUT HANDLER.
MXFILVAL        DB $03,$03      ; CURRENT # OF DOS BUFS IN CHAIN
                                ; (SECOND BYTE IS IRRELEVANT).
STKSAVED        DS 1            ; ($AA59) 1RST STACK PTR SAV AREA.
                                ; (P.S.  DON'T CONFUSE WITH THE
                                ; 2ND STK POINTER SAVE AREA KNOWN
                                ; AS "STKSAV" ($B39B).
XSAVED          DS 1            ; (X) SAVE AREA.
YSAVED          DS 1            ; (Y) SAVE ARE.
ASAVED          DS 1            ; (A) SAVE AREA.
NDX2INBF        DS 1            ; INDEX TO CMD LINE IN INPUT BUF.
CIOCUMUL        DS 1            ; MON/NOMON FLAG.
                                ; CUMMULATIVE UPDATED RECORD OF
                                ; C/I/O ARGUMENTS:
                                ; C=$40, I=$20, O=$10, IO=$30,
                                ; CO=$50, CI=$60, CIO=$70.
NDX2CMD         DS 1            ; INDEX TO COMMAND.
LENADRBF        DS 2            ; 2-BYTE BUF USED 2 HOLD BLOAD ADR
                                ; & LENGTH READ FROM DISK.
                                ; (LEFT WITH LNGTH OF LAST BLOAD.)
NEXTCMD         DS 1            ; CODE FOR PENDING COMMAND.
TEMPBYT         DS 1            ; TEMPORARY STORAGE AREA.
NDX2OPTN        DS 1            ; INDEX TO OPTION (USED TO INDEX
                                ; OPTNTXT, OPTNISSD & OPTNRNG).
CUMLOPTN        DS 1            ; HOLDS CUMMULTIVE RECORD OF
                                ; OPTIONS PARSED ON CMD LINE.

                                ; =================================
                                ; OPTION PARSED VALUES TABLE.
                                ; ($AA66 - $AA74)
                                ; (CONTAINS A RECORD OF THE OPTION
                                ; VALUES THAT WERE ISSUED WITH THE
                                ; COMMAND.  SOME OF THESE BYTES
                                ; ARE DEFAULTED TO NON-ZERO VALS.)
                                ; =================================
                IF DOS31 || DOS32
VOLPRSD
                DS 1            ; PARSED VOLUME NUMBER.
                DS 1
DRVPRSD         DS 1            ; PARSED DRIVE NUMBER.
                DS 1
SLOTPRSD        DS 1            ; PARSED SLOT NUMBER.
                DS 1
VOLPRSD2
LENPRSD         DS 1            ; PARSED LENGTH VALUE.
                DS 1
RECPRSD         DS 1            ; PARSED RECORD OR RELATIVE FIELD
                                ; POSITION NUMBER.
                DS 1
BYTPRSD         DS 1
                DS 1
ADRPRSD         DS 1            ; PARSED ADDRESS PARAMETER.
                DS 1
MONPRSD         DS 1            ; PARSED MON/NOMON CHR CODE VALS.
                ELSE


VOLPRSD         DS 2            ; PARSED VOLUME NUMBER.
DRVPRSD         DS 2            ; PARSED DRIVE NUMBER.
SLOTPRSD        DS 2            ; PARSED SLOT NUMBER.
LENPRSD         DS 2            ; PARSED LENGTH VALUE.
RECPRSD         DS 2            ; PARSED RECORD OR RELATIVE FIELD
                                ; POSITION NUMBER.
BYTPRSD         DS 2            ; PARSED BYTE VALUE.
ADRPRSD         DS 2            ; PARSED ADDRESS PARAMETER.
MONPRSD         DS 1            ; PARSED MON/NOMON CHR CODE VALS.
                ENDIF


                                ; ==================================
                                ; NON-CHAIN FILE NAME BUFFERS.
                                ; (PS.  DON'T CONFUSE WITH THE
                                ; VARIOUS FILENAME BUFS ASSOC
                                ; WITH THE CHAIN OF DOS BUFFERS.)
                                ; ==================================

                                ; PRIMARY FILE NAME BUFFER.

PRIMFNBF        DS 30           ; ($AA75 - $AA92)

                                ; SECONDARY FILE NAME BUFFER.

SCNDFNBF        DS 30           ; ($AA93 - $AAB0)


                                ; ====================================
                                ; MAIN ROUTINE CONSTANTS & VARIABLES.
                                ; ($AAB1 - $AAB7)
                                ; ====================================

MAXDFLT         DB 3            ; DEFAULT VALUE FOR # OF DOS BUFS. (mosher: was DS 1)
                                ; (OFTEN ALTERED N COM'CIAL PRGMS)
DCTRLCHR        DB $84          ; DOS'S CTRL CHAR:
                                ; NORMALLY = CTRL-D, $84.
                                ; (OFTEN CHNGD IN COM'CIAL PRGMS)
EXECFLAG        DS 1            ; EXEC FLAG: $00 = NOT EXECING,
                                ; (ELSE CONTAINS 1RST CHAR OF NAME
                                ; OF EXEC FILE).
EXECBUFF        DS 2            ; PTS TO EXEC FILE'S BUFFER.

ACTBSFLG                        ; ACTIVE BASIC FLAG (INT=$00,
                                ; A(ROM)=$40, A(RAM)=$80).
                IF !DOS31
                DS 1
                ENDIF

RUNTRUPT        DS 1            ; RUN INTERCEPTED FLAG:
                                ; $00 = RUN NOT INTECEPTED.
                                ; NON-ZERO = RUN INTERCEPTED TO DO
                                ; A LOAD.


                                ; =================================
                                ; TEXT OF THE WORD "APPLESOFT".
                                ; ($AAB8 - $AAC0)
                                ; =================================

                CMAP     " ",160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
                CMAP     "@",192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
                CMAP     "`",224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
APLSFTXT        DB "APPLESOFT"
                CMAP

                                ; =================================
                                ; FILE MANAGER'S CONSTANTS TABLE.
                                ; ($AAC1 - $AAC8)
                                ; =================================

ADRIOB          DW IBTYPE       ; PTS TO RWTS'S IOB. NOTE:THE $3E3
                                ; VECTOR LOADS FROM ADRIOB.
ADRVTOC         DW VTOCBUFF     ; PTS TO VTOC SECTOR BUFFER.
ADRDIRBF        DW DIRECBUF     ; PTS TO DIRECTORY SECTOR BUFFER.
DOSNDPL1        DW DOSLIM       ; PTS TO LAST BYTE OF DOS PLUS 1.


                                ; ======================================
                                ; FILE MANAGER'S FUNCTION HNDLR ENTRY
                                ; POINT TABLE ($AAC9 - $AAE4).
                                ; (ALL ADDRS ARE 1 LESS THAN THE ACTUAL
                                ; ENTRY POINT BECAUSE THE THE FUNCTIONS
                                ; ARE ENTERED VIA A "STACK JUMP".)
                                ; ======================================

FMFUNCTB        DW GOODFMXT-1   ; NULL - EXIT WITH NO ERRORS.
                DW FNOPEN-1
                DW FNCLOSE-1
                DW FNREAD-1
                DW FNWRITE-1
                DW FNDELETE-1
                DW FNCATLOG-1
                DW FNLOCK-1
                DW FNUNLOCK-1
                DW FNRENAME-1
                DW FNPOSN-1
                DW FNINIT-1
                DW FNVERIFY-1
                DW GOODFMXT-1   ; NULL - EXIT WITH NO ERRORS.


                                ; ====================================
                                ; FILE MANAGER READ-SUBFUNCTION ENTRY
                                ; POINT TABLE ($AAE5 - $AAF0).
                                ; (P.S.  SUBFUNCTIONS EMPLOYING THE
                                ; POSITION OPTION ARE AVAILABLE TO
                                ; THE USER BUT NEVER CALLED BY DOS.)
                                ; ====================================

                                ; SUBFUNCTION INDEX.
RDSUBTBL        DW GOODFMXT-1   ; (0), EXIT.
                DW READONE-1    ; (1), READ ONE BYTE.
                DW READRNG-1    ; (2), READ A RANGE OF BYTES.
                DW PSNRDONE-1   ; (3), POSITION & READ ONE BYTE.
                DW PSNRDRNG-1   ; (4), POS'N & READ RNGE OF BYTES.
                DW GOODFMXT-1   ; (5), EXIT.


                                ; =====================================
                                ; FILE MANAGER WRITE SUBFUNCTION ENTRY
                                ; POINT TABLE ($AAF1 - $AAFC).
                                ; (P.S.  SUBFUNCTIONS EMPLOYING THE
                                ; POSITION OPTION ARE AVAILABLE TO
                                ; THE USER BUT NEVER CALLED BY DOS.)
                                ; =====================================

                                ; SUBFUNCTION INDEX.
WRSUBTBL        DW GOODFMXT-1   ; (0), EXIT.
                DW WRITEONE-1   ; (1), WRITE ONE BYTE.
                DW WRITERNG-1   ; (2), WRITE A RANGE OF BYTES.
                DW PSNWRONE-1   ; (3), POSITION & WRITE ONE BYTE.
                DW PSNWRRNG-1   ; (4), POS'N & WRITE RNG OF BYTES.
                DW GOODFMXT-1   ; (5), EXIT.


                                ; =========================================
                                ; FILE MANAGER EXTERNAL ENTRY POINT.
                                ; -NOTE: THE $3D6 VECTOR LOADS FROM HERE!!
                                ; -ENABLES USER TO ACCESS FILE MANAGER
                                ; FROM CUSTOM ASSEMBLY LANGUAGE ROUTINES.
                                ; =========================================

FMXTNTRY
                IF !DOS31
                CPX #0
                BEQ FMXTCMD     ; ALLOW NEW FILE-SIMUL8 AN "INIT".
                LDX #02         ; REQUIRES OLD FILE (SIMUL8 LOAD).
FMXTCMD         STX NDX2CMD     ; SET INDEX TO COMMAND.
                ENDIF


                                ; =================================
                                ; FILE MANAGER PROPER.
                                ; ---------------------------------

FILEMGR         TSX             ; SAVE STK PTR SO WE CAN LATER RTN
                STX STKSAV      ; TO AFTRFUNC ($A6AB) LOCATED IN
                                ; THE FMDRIVER ROUTINE ($A6A8).
                                ; (NOTE THAT APPEND CMD EMPLOYS
                                ; THE RSETPTRS ROUTINE ($B6B3) TO
                                ; RE-ADJUST STKSAV ($B39B) SO THAT
                                ; EXECUTION ACTUALLY RETURNS TO
                                ; AFTRCMD ($A6AB) LOCATED IN THE
                                ; DOS CMD PARSING AND PROCESSING
                                ; ROUTINES.)
                JSR RSTRFMWA    ; COPY FM WRK BUF (IN DOS CHAIN) 2
                                ; FM WRK AREA (NOT IN DOS CHAIN).
                LDA OPCODEFM    ; CHK IF OPCODE IS LEGAL.
                CMP #13         ; (MUST BE LESS THAN 13.)
                BCS TOERROP     ; OPCODE TOO LARGE - RANGE ERROR.
                ASL A           ; DOUBLE VAL OF OPCODE & PUT IT IN
                TAX             ; (X) SO IT INDEXES TABLE OF ADRS.
                LDA FMFUNCTB+1,X
                                ; STICK ADDRESS (MINUS 1) OF THE
                PHA             ; FUNCTION HANDLER ON THE STACK
                LDA FMFUNCTB,X  ; (HI BYTE FIRST).
                PHA
                RTS             ; DO A STACK JMP TO THE FUNCTION'S
                                ; ENTRY POINT.

TOERROP         JMP RNGERROP    ; GO HANDLE RANGE ERROR.


                                ; =================================
                                ; OPEN FUNCTION HANDLER.
                                ; =================================

FNOPEN          JSR COMNOPEN    ; OPEN PREEXISTING FILE OR CREATE
                                ; NEW FILE IF CMD ALLOWS NEW FILES
                JMP GOODFMXT    ; EXIT CLEANLY. EVENTUALLY RTNS TO
                                ; AFTRFUNC ($A6AB) LOCATED IN THE
                                ; FM DRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; COMMON OPEN ROUTINE.
                                ; =================================

COMNOPEN        JSR ZWRKAREA    ; INITIALIZE THE FM WORK AREA WITH
                                ; DEFAULT VALUES.
                                ; (DON'T CONFUSE WITH FM WRK BUF
                                ; WHICH IS IN DOS BUF CHAIN.)
                LDA #1          ; DESCRIBE SECTOR LENGTH AS 256
                STA SECSIZWA+1  ; BYTES (IN FM WORK AREA).

                                ; GET RECORD LENGTH FROM FM PARM
                                ; LIST & PUT IT IN FM WORK AREA.
                                ; (DON'T ALLOW A 0 LENGTH.  IF
                                ; ZERO, CHANGE IT TO ONE.)

                LDX RECLENFM+1
                LDA RECLENFM
                BNE STRECLEN    ; NON-ZERO REC LENGTH IS OK.
                CPX #0
                BNE STRECLEN
                INX             ; WAS ZERO, MAKE IT ONE INSTEAD.
STRECLEN        STA RECLENWA    ; PUT LENGTH IN FM WORK AREA.
                STX RECLENWA+1
                JSR GETFNTRY    ; TRY 2 FIND DIRECTORY SEC 4 FILE.
                BCC FILLINWA    ; BRNCH IF FOUND DIR SEC WITH SAME
                                ; NAME IN FILE DESCRIPTION ENTRY.

                                ; THE NAMED FILE WAS NOT FOUND IN
                                ; THE DIRECTORY, SO PREPARE A NEW
                                ; FILE ENTRY IN CASE THE CMD CAN
                                ; LEGALLY CREATE A NEW FILE.
                IF !DOS31
                STX CURDIRNX    ; OFFSET TO NEW DESCRIP ENTRY IN
                                ; CASE WANT TO CREATE A NEW FILE.

                                ; CHECK TO SEE IF CMD CAN
                                ; LEGALLY CREATE A NEW FILE.

                LDX NDX2CMD     ; (X) = INDEX REPRESENTING CMD.
                LDA CMDATTRB,X  ; GET 1RST BYTE CONTAINING DESCRIP
                                ; OF THE COMMAND'S ATTRIBUTES.
                LDX CURDIRNX    ; (X)=INDEX FOR A NEW FILE DESCRIP
                                ; ENTRY INTO DIRECTORY SEC.
                LSR A           ; (C)=BIT0 OF 1RST ATTRIBUTE BYTE.
                BCS CREATNEW    ; IF (C)=1 CMD CAN MAKE NEW FILE.

                                ; COMMAND CAN'T CREATE NEW FILE.
                                ; SEE WHICH LANGUAGE WE'RE USING
                                ; & EXIT WITH APPROPRIATE ERROR.

NEWILLGL        LDA CONDNFLG    ; $00=WARMSTART, $01=READING,
                                ; $40=A(RAM), $80=COLDSTART,
                                ; $C0=INTEGER.
                CMP #$C0        ; IS INTEGER IN ROM?
                BNE TOFILNOT    ; NO.
                JMP LNGNOTAV    ; HANDLE LANGUAGE-NOT-AVAIL ERROR.

TOFILNOT        JMP FILENOT     ; HANDLE FILE-NOT-FOUND ERROR.
                ENDIF


                                ; ---------------------------------
                                ; CREATE A NEW FILE:
                                ; - INIT FILE SIZE = 1 SEC LONG.
                                ; - ALLOCATE SECS FOR DATA SECS
                                ; & UPDATE FILE SIZE.
                                ; - WRITE UPDATED VTOC TO DISK.
                                ; - PUT LINK IN FILE DESCRIPTION
                                ; ENTRY & UPDATE FILE SIZE.
                                ; - WRITE UPDATED VTOC TO DISK.
                                ; - WRITE NEW T/S LIST TO DISK.
                                ; --------------------------------

CREATNEW        LDA #0          ; INITIALIZE FILE SIZE = 1 SECTOR.
                STA FIL1SIZE+1,X
                                ; (CAUSE AT 1RST, ONLY STARTING
                LDA #1          ; OUT WITH A T/S LIST SECTOR.)
                STA FIL1SIZE,X
                STX CURDIRNX    ; SAVE BYTE OFFSET INTO DIR SEC
                                ; FOR FILE DESCRIPTION.
                IF DOS31
                STX BYTNXD1R
                ENDIF
                JSR ASGNTKSC    ; FIND TRK/SEC VALS FOR NEW FILE.

                                ; FINISH SETTING UP PARAMETERS
                                ; IN THE FILE MANAGER'S WORK AREA.
                                ; (P.S. DON'T CONFUSE FM WORK AREA
                                ; WITH THE VARIOUS WORK BUFFERS
                                ; LOCATED IN THE DOS BUFFER CHAIN.)

                LDX CURDIRNX    ; OFFSET IN DIR SEC 4 NEW DESCRIP
                STA FIL1TSSC,X  ; PUT SEC VAL IN DIRECTORY SECTOR.
                STA FIRTSSEC    ; PUT SEC VALUE OF 1RST T/S LIST
                                ; SECTOR IN THE FM WORK AREA.
                STA CURTSSEC    ; PUT CUR SEC VAL IN FM WRK AREA.
                LDA ASIGNTRK    ; DO THE SAME FOR TRACK VALUE.
                STA FIL1TSTK,X
                STA FIRSTSTK
                STA CURTSTRK
                LDA FILTYPFM    ; (FROM FM PARM LIST.)
                STA FIL1TYPE,X  ; PUT FILE TYPE IN DIREC SEC BUF.

                                ; WRITE DIRECTORY SECTOR BUFFER.

                JSR WRDIRECT    ; WRITE DIRECTORY SEC BUF IN CAT.

                                ; WRITE T/S LIST SECTOR BUFFER.

                JSR SELTSBUF    ; GET ADR OF T/S LIST SEC BUF FROM
                                ; THE FM PARM LIST.
                JSR ZCURBUF     ; ZERO OUT T/S LIST SECTOR BUF.
                JSR WRITETS     ; WRITE ZEROED OUT T/S LIST SEC.
                                ; (IF THE WRITE SUBFUNCTION IS
                                ; LATER ENTERED TO WRITE NEW DATA
                                ; TO THE DISK, THE ZERO BYTES ARE
                                ; DETECTED & USED AS SIGNALS THAT
                                ; NEW DATA PAIR SHOULD BE WRITTEN
                                ; INTO THE T/S LIST SECTOR.)
                LDX CURDIRNX    ; OFFSET IN DIREC SEC 4 NEW FILE.
                LDA #6          ; DEFAULT RETURN CODE VALUE 2 THAT
                STA RTNCODFM    ; FOR A FILE-NOT-FOUND ERROR.

                                ; FILL IN THE FM WORK AREA BUFFER.
                                ; (ROUTINE COMMON TO OPENING A
                                ; NEW OR PRE-EXISTING FILE.)

FILLINWA        LDA FIL1TSTK,X  ; T/S LIST TRK (FRM DIRECTORY SEC)
                STA FIRSTSTK
                LDA FIL1TSSC,X  ; T/S LIST SEC (FRM DIRECTORY SEC)
                STA FIRTSSEC
                LDA FIL1TYPE,X  ; FILE TYPE (FROM DIRECTORY SEC).
                STA FILTYPFM
                STA FILTYPWA
                LDA FIL1SIZE,X  ; FILE SIZE (FROM DIRECTORY SEC).
                STA FILENSEC
                LDA FIL1SIZE+1,X
                STA FILENSEC+1

                IF !DOS31
                STX BYTNXD1R    ; INDEX IN2 DIREC SEC FOR DESCRIP.
                ENDIF
                LDA #$FF        ; PRETEND THAT THE LAST DATA SEC
                STA RELPREV     ; USED HAD A RELATIVE SECTOR #
                STA RELPREV+1   ; (IN RELATION TO THE ENTIRE FILE)
                                ; OF #$FFFF.  NOTE: THIS VALUE IS
                                ; LATER USED TO TRICK THE READ AND
                                ; WRITE SUBFUNCTIONS INTO IGNORING
                                ; THE DATA SECTOR CURRENTLY IN
                                ; MEMORY.
                LDA MXIN1TSL    ; DICTATE THAT A T/S LIST CAN ONLY
                STA MXSCURTS    ; DESCRIBE $7A (#122) DATA SECS.
                                ; NOTE: THIS VAL IS LATER USED BY
                                ; THE READ AND WRITE SUBFUNCTIONS
                                ; TO DECIDE WHETHER OR NOT THE T/S
                                ; LIST CURRENTLY IN MEMORY SHOULD
                                ; BE USED.

                                ; READ FIRST T/S LIST SECTOR TO
                                ; THE T/S LIST SEC BUFFER.
                                ; (EVENTHOUGH IT IS NOT NEEDED BY
                                ; THE RENAME, LOCK OR UNLOCK
                                ; FUNCTIONS, THE FIRST T/S LIST IS
                                ; AUTOMATICALLY READ INTO THE T/S
                                ; LIST BUFFER IF THE FILE WAS
                                ; FOUND.)

                CLC             ; (C)=0 =SIGNAL 1RST T/S LIST SEC.
                JMP READTS      ; GO READ IN THE T/S LIST SEC.


                                ; ==================================
                                ; INITIALIZE (IE. ZERO OUT) THE FM
                                ; WORK AREA SO IT CAN BE CUSTOMIZED
                                ; IN ACCORDANCE WITH THE CALLING
                                ; FUNCTION.  (ALTHOUGH SOME WORK
                                ; BYTES MAY NOT BE SUBSEQUENTLY
                                ; ALTERED, DON'T BE LULLED INTO
                                ; THINKING THAT THEY ARE NOT
                                ; IMPORTANT.  ZERO VALUES ARE JUST
                                ; AS RELEVANT AS NON-ZERO VALUES.
                                ; ALSO BE CAUTIONED NOT TO CONFUSE
                                ; THE FM WORK AREA WITH ITS IMAGE
                                ; (DOS WORK BUFFER) THAT IS HOUSED
                                ; IN THE CHAIN OF DOS BUFFERS.)
                                ; ==================================

                                ; ZERO OUT THE FM WORK AREA.

ZWRKAREA        LDA #0
                TAX             ; INITIALIZE X-INDEX.
ZEROWRKA        STA FMWKAREA,X  ; PUT $00 BYTE IN WORK AREA.
                INX
                CPX #45         ; WORK AREA IS 45 BYTES LONG.
                BNE ZEROWRKA

                                ; BEGIN CUSTOMIZING THE WORK AREA.
                                ; GET VOL, DRV, SLOT & CATALOG TRK
                                ; VALUES FROM THE FM PARM LIST.
                                ; PUT DRV, SLOT*16, CAT TRK AND
                                ; COMPLEMENTED VOL # IN THE WORK
                                ; AREA.

                LDA VOLFM       ; VOLUME #.
                EOR #$FF        ; CALC 1'S COMPLEMENT OF VOL #.
                STA VOLWA
                LDA DRVFM       ; DRIVE #.
                STA DRVWA
                LDA SLOTFM      ; GET SLOT #.
                ASL A           ; CALC SLOT * 16.
                ASL A
                ASL A
                ASL A
                TAX             ; SET (X) = SLOT*16.
                STX SLOT16WA
                LDA #$11        ; NORMAL CAT TRK = #17.
                STA TRKWA
                RTS


                                ; =================================
                                ; CLOSE FUNCTION HANDLER.
                                ; =================================

FNCLOSE         JSR CKDATUP     ; WRITE DATA SEC BUF IF NECESSARY.
                JSR CKTSUPDT    ; WRITE T/S LIST SEC BUF IF NEC.
                JSR FIXMAP      ; FREE UP SECS THAT WERE ALLOCATED
                                ; BUT NOT USED. WHENEVER SOMETHING
                                ; IS WRITTEN 2 THE DISK, THE WHOLE
                                ; TRK IS ALLOCATED IN THE VTOC
                                ; WHETHER IT IS NEEDED OR NOT.
                                ; THERE4, ONCE DONE WRITING, GO
                                ; BACK & FREE UP UNNEEDED SECS.

                                ; WAS LAST OPERATION A WRITE?

                LDA #%00000010  ; IF BIT 1 SET, THEN WAS WRITE.
                AND UPDATFLG
                BEQ TOGDFMXT    ; WASN'T A WRITE SO CAN JUST EXIT
                                ; CAUSE NO NEED TO UPDATE DIR SEC.

                                ; LAST OPERATION WAS A WRITE, SO
                                ; BETTER PREPARE TO FIX UP THE
                                ; FILE-SIZE BYTES AND T/S LINKS
                                ; IN DIRECTORY SECTORS, ETC.

                JSR READVTOC    ; READ VOLUME TABLE OF CONTENTS.

                                ; READ IN ALL DIR SECS UP TO THE
                                ; ONE CONTAINING THE FILE DESCRIP
                                ; ENTRY FOR THE FILE WE ARE CLOSING.

                LDA #0
                CLC             ; (C)=0=SIGNAL 2 READ 1RST DIR SEC
PURGEDIR        JSR RDDIRECT    ; GO READ A DIRECTORY SEC.
                SEC             ; (C)=1, 1RST DIR SEC ALREADY READ
                DEC SECNXD1R    ; INDEX FOR # OF DIRECTORY SECS.
                BNE PURGEDIR    ; IF 0, THEN JUST READ DIREC SEC
                                ; PERTAINING TO THE FILE WANTED.

                                ; UPDATE THE FILE SIZE & WRITE THE
                                ; DIRECTORY SECTOR TO THE DISK.

                LDX BYTNXD1R    ; (X) = OFFSET OF FILE DESCRIPTION
                                ; IN THE DIRECTORY SECTOR.
                LDA FILENSEC    ; # SECS IN FILE (FRM FM WRK AREA)
                STA FIL1SIZE,X
                LDA FILENSEC+1
                STA FIL1SIZE+1,X
                JSR WRDIRECT    ; WRITE UPDATED DIRECTORY SECTOR.

TOGDFMXT        JMP GOODFMXT    ; CLEAN EXIT.  EVENTUALLY RTNS TO
                                ; AFTRFUNC ($A6AB) LOCATED IN THE
                                ; FMDRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; RENAME FUNCTION HANDLER.
                                ; =================================

FNRENAME        JSR COMNOPEN    ; LOCATE FILE WITH SAME NAME & OPN
                                ; IT IF ITS NOT ALREADY OPEN.
                LDA FILTYPWA    ; GET FILE TYPE (FROM WORK AREA).
                BMI TOFILOCK    ; ERROR-CAN'T RENAME A LOCKED FILE
                LDA RENAMBUF    ; GET ADR OF SECONDARY NAME BUFFER
                STA A4L         ; FROM FM PARM LIST & PUT IN A4L/H
                LDA RENAMBUF+1
                STA A4H
                LDX CURDIRNX    ; (X) = INDEX INTO CURRENT DIR SEC.
                JSR NWDESCRP    ; COPY NEW NAME TO DIREC SEC BUF.
                JSR WRDIRECT    ; WRIT MODIFIED DIR SEC BUF 2 DSK.
                JMP GOODFMXT    ; TAKE THE GOOD ROUTE HOME.
                                ; EVENTUALLY RETURNS TO AFTRFUNC
                                ; LOCATED IN FMDRIVER RTN ($A6A8).

                                ; =================================
                                ; READ FUNCTION HANDLER.
                                ; =================================

FNREAD          LDA SUBCODFM    ; CHK IF SUBCODE IS LEGAL.
                CMP #5          ; (MUST BE < = 5.)
                BCS TOERRSUB    ; RANGE ERROR - ILLEGAL SUBCODE.

                ASL A           ; SUBCODE*2, CAUSE 2 BYTES/ADR.
                TAX             ; INDEX TABLE OF SUBFUNCTION ADRS.
                LDA RDSUBTBL+1,X
                                ; GET ADDR (MINUS 1) OF SUBFUNCT
                PHA             ; ENTRY POINT & PUT IT ON THE STK
                LDA RDSUBTBL,X  ; (HI BYTE FIRST). THEN DO A STACK
                PHA             ; JUMP TO EXECUTE THE GIVEN READ
                RTS             ; SUBFUNCTION.

TOERRSUB        JMP RNGERRSB    ; GO HANDLE RANGE ERROR.

TOFILOCK        JMP FILELOKD    ; GO HANDLE LOCKED FILE ERROR.


                                ; =================================
                                ; WRITE FUNCTION HANDLER.
                                ; =================================

FNWRITE         LDA FILTYPWA    ; CHK IF FILE IS LOCKED.
                BMI TOFILOCK    ; ERROR - CAN'T WRITE 2 LCKD FILE.

                LDA SUBCODFM    ; CHK IF SUBCODE IS LEGAL.
                CMP #5          ; (MUST BE < = 5.)
                BCS TOERRSUB    ; ERROR - ILLEGAL SUBCODE.

                ASL A           ; SUBCODE*2, CAUSE 2 BYTES/ADR.
                TAX             ; INDEX TABLE OF SUBFUNCTION ADRS.
                LDA WRSUBTBL+1,X
                                ; GET ADR (MINUS 1) OF SUBFUNCT
                PHA             ; ENTRY POINT & STICK ON THE STACK
                LDA WRSUBTBL,X  ; (HI BYTE FIRST). THEN DO A STACK
                PHA             ; JUMP TO EXECUTE THE GIVEN WRITE
                RTS             ; SUBFUNCTION.


                                ; =================================
                                ; POSITION AND READ-ONE-BYTE
                                ; SUBFUNCTION HANDLER.
                                ; =================================

PSNRDONE        JSR CALCFPTR    ; USING R-, L- & B-PARAMETERS,CALC
                                ; THE POS'N OF FILE PTR WANTED.


                                ; ==================================
                                ; READ-ONE-BYTE SUBFUNCTION HANDLER
                                ; ==================================

READONE         JSR RDDATA      ; GET DATA BYTE FROM DATA SEC BUF.
                                ; (IF DESIRED DATA SECTOR IS NOT
                                ; ALREADY IN MEMORY, THEN READ IT
                                ; IN. HOWEVER, 1RST CHK IF PRESENT
                                ; INFO IN DATA SEC NEEDS TO BE
                                ; UPDATED SO DON'T OVERWRITE DATA
                                ; IN BUF & LOOSE INFO.)

                STA ONEIOBUF    ; PUT BYTE READ IN THE 1-BYTE BUF
                                ; CONTAINED IN THE FM PARM LIST.
                JMP GOODFMXT    ; EXIT THE FILE MGR.  EVENTUALLY
                                ; RTNS TO AFTRFUNC ($A6AB) LOCATED
                                ; IN THE FMDRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; POSITION & READ-A-RANGE-OF-BYTES
                                ; SUBFUNCTION HANDLER.
                                ; =================================

PSNRDRNG        JSR CALCFPTR    ; USING R-, L- & B-PARMS, CALC THE
                                ; POS'N OF FILE POINTER WANTED.


                                ; =================================
                                ; READ-RANGE-OF-BYTES
                                ; SUBFUNCTION HANDLER.
                                ; =================================

READRNG         JSR DECRWLEN    ; DECREMENT THE # OF BYTES 2 READ.
                                ; (DONE READING WHEN LEN2RDWR=0.)
                JSR RDDATA      ; GET DATA BYTE FROM DATA SEC BUF.
                                ; (IF DESIRED DATA SECTOR IS NOT
                                ; ALREADY IN MEMORY, THEN READ IT
                                ; IN. HOWEVER, 1RST CHK IF PRESENT
                                ; INFO IN DATA SEC NEEDS TO BE
                                ; UPDATED SO DON'T OVERWRITE DATA
                                ; IN BUF & LOOSE INFO.)
                PHA             ; SAVE SINGLE BYTE READ ON STK.
                JSR INCIOBUF    ; INC THE CUR'NT TARGET RAM MEMORY
                                ; LOCATION (BYTRNG) & POINT A4L/H
                                ; AT TARGET LOCATION IN I/O BUF.
                LDY #0          ; INITIALIZE (Y) INDEX.
                PLA             ; RETRIEVE BYTE READ.
                STA (A4L),Y     ; PUT SINGLE BYTE READ INTO THE
                                ; TARGET MEMORY LOCATION.
                JMP READRNG     ; GO BK TO READ NEXT BYTE OF DATA.


                                ; =================================
                                ; SUBROUTINE TO READ A DATA BYTE.
                                ; =================================

RDDATA          JSR NXTDATRD    ; CHK IF DATA SEC WE WANT TO READ
                                ; IS ALREADY IN MEMORY.  IF NOT,
                                ; READ DATA SEC INTO DATA SEC BUF.
                                ; HOWEVER, 1RST CHK IF DAT SEC BUF
                                ; NEEDS UPDATING SO DON'T OVRWRITE
                                ; DATA SEC BUF & LOSE INFO.
                BCS NDATERR     ; BRANCH IF RAN OUT OF DATA SECS
                                ; WHILE READING.
                LDA (A4L),Y     ; GET SINGLE BYTE FRM DATA SEC BUF
                PHA             ; SAVE IT ON STK.
                JSR INCREC      ; EITHER INC REC # OR BYTE OFFSET
                                ; INTO RECORD.
                JSR INCFILPT    ; INC BYTE OFFSET INTO CURRENT
                                ; DATA SEC OR, IF AT END OF SEC,
                                ; INC THE SECTOR OFFSET INTO THE
                                ; ENTIRE FILE.
                PLA             ; GET DATA BYTE RD (BACK OFF STK).
                RTS

NDATERR         JMP ENDOFDAT    ; RAN OUT OF DATA WHILE READING.


                                ; =================================
                                ; POSITION & WRITE-ONE-BYTE
                                ; SUBFUNCTION HANDLER.
                                ; =================================

PSNWRONE        JSR CALCFPTR    ; USING R-, L- & B-PARMS, CALC
                                ; POS'N OF FILE POINTER WANTED.


                                ; =================================
                                ; WRITE-ONE-BYTE SUBFUNCTION HNDLR
                                ; =================================

WRITEONE        LDA ONEIOBUF    ; GET BYTE TO WRITE FROM ONE-BYTE
                                ; BUFFER IN FM PARAMETER LIST.
                JSR WRTDATA     ; STORE DATA TO WRITE IN THE DATA
                                ; SECTOR BUFFER.  IF DATA SEC BUF
                                ; IS FULL, THEN WRITE IT TO DISK
                                ; AND UPDATE T/S LIST BUF.
                JMP GOODFMXT    ; EXIT FILE MANAGER.  EVENTUALLY
                                ; RTNS TO AFTRFUNC ($A6AB) LOCATED
                                ; IN THE FMDRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; POSITION & WRITE-RANGE-OF-BYTES
                                ; SUBFUNCTION HANDLER.
                                ; =================================

PSNWRRNG        JSR CALCFPTR    ; USING R-, L- & B-PARMS, CALC
                                ; POS'N OF FILE POINTER WANTED.


                                ; =================================
                                ; WRITE RANGE-OF-DATA-BYTES
                                ; SUBFUNCTION HANDLER.
                                ; =================================

WRITERNG        JSR INCIOBUF    ; POINT A4L/H AT SOURCE BYTE.
                LDY #0          ; SET (Y) TO INDEX SOURCE BUF.
                LDA (A4L),Y     ; GET BYTE TO WRITE.
                JSR WRTDATA     ; PUT DATA BYTE IN DATA SEC BUF.
                                ; (WRITE DATA SEC BUF TO DISK IF
                                ; NECESSARY.  )
                JSR DECRWLEN    ; CHECK IF DONE WRITING.  IF NOT,
                                ; REDUCE COUNTER FOR # OF BYTES
                                ; LEFT TO WRITE.
                JMP WRITERNG    ; GO BACK TO WRITE NEXT DATA BYTE.


                                ; =================================
                                ; SUBROUTINE WHICH WRITES BYTE.
                                ; =================================

WRTDATA         PHA             ; SAVE BYTE TO WRITE ON STK.
                JSR NXTDATRD    ; READ NXT DATA SEC BUF IF NEEDED.
                PLA             ; GET DATA BYTE TO WRITE OFF STK.
                STA (A4L),Y     ; PUT DATA BYTE IN DATA SEC BUF.
                LDA #%01000000  ; SET BIT6 TO SIGNAL DATA SEC BUF
                ORA UPDATFLG    ; HAS CHANGED & THEREFOR, THE DISK
                STA UPDATFLG    ; REQUIRES UPDATING.
                JSR INCREC      ; EITHER INC THE RECORD NUMBER OR
                                ; INC THE BYTE OFFSET INTO RECORD.
                JMP INCFILPT    ; INC THE BYTE OFFSET INTO THE
                                ; CURRENT DATA SECTOR.  IF AT THE
                                ; END OF SECTOR, INC THE OFFSET
                                ; INTO THE ENTIRE FILE INSTEAD.


                                ; =================================
                                ; LOCK & UNLOCK FUNCTION HANDLERS.
                                ; =================================

FNLOCK          LDA #$80        ; SET HI BIT IN LOCK/UNLOCK MASK.
                STA LOKUNMSK
                BNE COMNLOCK    ; ALWAYS.


FNUNLOCK        LDA #0          ; MAKE SURE HI BIT CLR IN LOKUNMSK
                STA LOKUNMSK

COMNLOCK        JSR COMNOPEN    ; LOCATE THE FILE WITH THE SAME
                                ; NAME & OPEN IT.
                LDX CURDIRNX    ; (X) = INDEX TO FILE DESCRIPTION
                                ; ENTRY IN THE DIRECTORY SEC BUF.
                LDA FIL1TYPE,X  ; GET OLD FILE TYPE.
                AND #$7F        ; SHUT HI BIT OFF.
                ORA LOKUNMSK    ; MERGE WITH LOKUNMSK 2 SET OR CLR
                                ; (LOCK OR UNLOCK) HI BIT.
                STA FIL1TYPE,X  ; STICK MODIFIED FILE TYPE BACK IN
                                ; FILE DESCRIP PART OF DIR SEC BUF
                JSR WRDIRECT    ; WRITE UPDATED DIREC SEC TO DISK.

TOOKFMXT        JMP GOODFMXT    ; EXIT FM CLEANLY. EVENTUALLY RTNS
                                ; TO AFTRFUNC ($A6AB) LOCATED IN
                                ; THE FMDRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; POSITION FUNCTION HANDLER.
                                ; =================================

FNPOSN          JSR CALCFPTR    ; USE R-, B- & L-PARAMETERS 2 CALC
                                ; POSITION OF FILE POINTER WANTED.
                JMP GOODFMXT    ; EXIT FILE MANAGER CLEANLY.
                                ; EVENTUALLY RETURNS TO AFTRFUNC
                                ; ($A6AB) LOCATED IN THE FMDRIVER
                                ; ROUTINE ($A6A8).


                                ; =================================
                                ; VERIFY FUNCTION HANDLER.
                                ; =================================

FNVERIFY        JSR COMNOPEN    ; LOCATE FILE WITH SAME NAME
                                ; & OPEN IT.
VRFYREAD        JSR NXTDATRD    ; READ NEXT DATA SEC IN.  (ASSUME
                                ; DATA SEC WE WANT NOT PRESENTLY
                                ; IN MEMORY.)
                IF DOS31
                BCS TOOKFMXT2
                ELSE
                BCS TOOKFMXT    ; END OF FILE DETECTED - EXIT FM.
                                ; EVENTUALLT RETURNS TO AFTRFUNC
                                ; ($A6AB) LOCATED IN THE FMDRIVER
                                ; ROUTINE ($A6A8).
                ENDIF
                INC FILPTSEC    ; KICK UP FILE POINTER POS'N
                BNE VRFYREAD    ; AND THEN GO BACK TO READ NEXT
                INC FILPTSEC+1  ; DATA SECTOR UNTIL ENCOUNTER END
                JMP VRFYREAD    ; OF FILE MARKER.


                IF DOS31
TOOKFMXT2       JMP GOODFMXT
                ENDIF
                                ; =================================
                                ; DELETE FUNCTION HANDLER.
                                ; =================================

FNDELETE        JSR COMNOPEN    ; LOCATE FILE WITH SAME NAME AND
                                ; THEN OPEN IT.
                LDX CURDIRNX    ; (X) = INDEX TO FILE DESCRIPTION
                                ; IN DIRECTORY SECTOR BUFFER.
                LDA FIL1TYPE,X  ; GET FILE TYPE FROM DIR SEC BUF.
                BPL ALTRNTRY    ; BRANCH IF FILE NOT LOCKED.
                JMP FILELOKD    ; ERR - CAN'T DELETE A LOCKED FILE
                                ; SO GO HANDLE ERR & EXIT.

                                ; GET TRK # OF FILES 1RST T/S LIST
                                ; FROM FILE DESCRIP ENTRY IN DIR
                                ; SEC BUF.  PUT IT IN THE WRK AREA
                                ; & WRITE IT OVER THE LAST CHAR
                                ; POS'N IN THE APPROPRIATE FILE
                                ; NAME FIELD IN DIRECTORY SECTOR.

ALTRNTRY        LDX CURDIRNX    ; (X) = INDEX TO FILE DESCRIPTION
                                ; ENTRY IN DIRECTORY SEC BUFFER.
                LDA FIL1TSTK,X  ; GET TRK # OF 1RST T/S LIST SEC.
                STA FIRSTSTK    ; COPY IT IN2 WORK AREA & LAST CHR
                STA FIL1NAME+29,X
                                ; POS'N OF FILE NAME FLD DSCRP
                LDA #$FF        ; REPLACE ORIG TRK # OF T/S LIST
                STA FIL1TSTK,X  ; WITH $FF TO SIGNAL FILE DELETED.
                LDY FIL1TSSC,X  ; PUT SEC # OF FILE'S 1RST T/S LST
                STY FIRTSSEC    ; IN THE WORK AREA.
                JSR WRDIRECT    ; WRITE MODIFIED DIREC SEC 2 DISK.

                                ; READ T/S LIST SEC INTO T/S LIST BUF.
                                ; (NEED THIS INFO SO KNOW WHAT SECS
                                ; TO RELEASE.)

                CLC             ; (C)=0, SIGNAL 1RST T/S LIST SEC.
RDTS4DEL        JSR READTS      ; GO READ IN T/S LIST.
                BCS DONEDEL     ; BRNCH IF JUST READ LAST T/S LIST
                                ; SEC ASSOCIATED WITH THIS FILE.
                JSR SELTSBUF    ; POINT A4L/H AT T/S LIST SECTOR
                                ; BUFFER.(GET ADR FRM FM PRM LST.)

                                ; FREE ALL SECS LISTED IN THE T/S
                                ; LIST THAT CURRENTLY OCCUPIES THE
                                ; T/S LIST BUFFER.

                LDY #12         ; 1RST DATA SEC PAIR LISTED IS
                                ; OFFSET 12 BYTES FROM START OF
                                ; T/S LIST BUFFER.
DELFREE         STY CURDIRNX    ; SET (Y) = INDEX TO THE DATA PAIR
                                ; LISTED IN THE T/S LIST BUFFER.
                LDA (A4L),Y     ; GET TRK # OF DATA SEC.
                BMI BYPASDEL    ; NEG TRK # ILLEGAL. (CAN USE AS
                                ; A PROTECTION SCHEME.)
                BEQ BYPASDEL    ; TRK # OF 0 = NO MORE DATA SECS
                                ; LISTED IN CURRENT T/S LIST.
                PHA             ; SAVE TRK # OF DATA SEC ON STK.
                INY             ; GET SEC # OF DATA SEC.
                LDA (A4L),Y
                TAY             ; CONDITION (Y)=SEC & (A)=TRK FOR
                PLA             ; ENTRY IN2 ROUT'N 2 FREE UP SECS.
                JSR FREESEC     ; FREE UP SECTOR FROM DELETED FILE
BYPASDEL        LDY CURDIRNX    ; SET (Y) 2 INDEX START DATA PAIR.
                INY             ; KICK UP (Y) 2 PT AT NXT DATA PR.
                INY
                BNE DELFREE     ; IF (Y) < > 0, THEN NEVER RAN OFF
                                ; END OF T/S LIST SEC BUF YET, SO
                                ; GO CHK IF MORE DATA PRS TO DO.

                                ; FREE UP SECTOR CONTAINING THE
                                ; T/S LIST.

                LDA CURTSTRK    ; TRK # OF CURRENT T/S LIST SEC.
                LDY CURTSSEC    ; SEC # OF CURRENT T/S LIST SEC.
                JSR FREESEC     ; GO FREE UP THE T/S LIST SEC.
                SEC
                BCS RDTS4DEL    ; ALWAYS.

                                ; DONE FREEING UP ALL SECTORS
                                ; ASSOCIATED WITH THIS FILE, SO
                                ; NOW WRITE MODIFIED VTOC BACK
                                ; TO THE DISK.

DONEDEL         JSR WRITVTOC    ; WRITE UPDATED VTOC TO DISK.
                JMP GOODFMXT    ; GO EXIT FM CLEANLY.  EVENTUALLY
                                ; RTNS TO AFTRFUNC ($A6AB) LOCATED
                                ; IN THE FMDRIVER ROUTINE ($A6A8).


                                ; =================================
                                ; SUBROUTINE TO FREE UP A SECTOR
                                ; IN A TRKMAP OF THE VTOC.
                                ; =================================

FREESEC         SEC             ; SET CARRY SO FREE UP PRESENT SEC
                                ; WHEN START ROTATING ASSIGNMENT
                                ; MAP.
                JSR SUB2FREE    ; ADJUST ASSIGNMENT MAP TO FREE UP
                                ; SEC BY SETTING BIT CORRESPONDING
                                ; TO SEC #.  NEXT, MERGE ASIGNMAP
                                ; WITH THE APPROP BIT MAP IN VTOC.
                LDA #0          ; ZERO OUT ASIGNSEC, ASIGNTRK
                IF DOS31 || DOS32
                LDX #3
                ELSE
                LDX #5          ; & ASIGNMAP (6 BYTES) IN WRK AREA
                ENDIF
RELEASEC        STA ASIGNSEC,X
                DEX
                BPL RELEASEC
                RTS


                                ; =================================
                                ; CATALOG FUNCTION HANDLER.
                                ; =================================

FNCATLOG        JSR ZWRKAREA    ; INITIALISE THE FM WORK AREA.
                LDA #$FF        ; ALLOW ANY VOL TO BE CATALOGED.
                STA VOLWA       ; (WHEN RWTS LATER ENTERED, THIS
                                ; VALUE IS EORED WITH  #$FF TO
                                ; SIMULATED A COMPLEMENTED VOL #
                                ; OF 0 (IE. #$FF EOR #$FF = #$00).
                                ; AFTER RWTS READS THE ADDRESS
                                ; CHECKSUM, IT CHECKS 2 SEE IF THE
                                ; CORRECT VOL # WAS READ OFF THE
                                ; DISK.  IF THE COMPLEMENT OF THE
                                ; VOL # IS 0, OR IF IT MATCHES THE
                                ; VOL # READ OFF DSK, EXECUTION
                                ; PROCEEDS AS IF THE CORRECT VOL
                                ; WAS FOUND.)
                JSR READVTOC    ; READ VOLUME TABLE OF CONTENTS.
                LDA #22         ; SET INDEX TO ALLOW 22 SCREEN
                STA SCRNSRCH    ; LINES BETWEEN PAUSES.

                                ; PRINT 2 <CR>'S & THE WORDS
                                ; "DISK VOLUME".
                JSR CRCATLOG    ; PRT <CR> & TEST IF PAUSE NEEDED.
                JSR CRCATLOG    ; DO IT AGAIN.
                LDX #11         ; 12 CHARS TO PRT (11 TO 0).
PRDSKVOL        LDA DSKVOLUM,X  ; GET CHAR OF REVERSE STRING.
                JSR COUT        ; PRINT CHAR.
                DEX
                BPL PRDSKVOL    ; MORE CHARS IN STRING.
                STX A5H         ; NONSENSE INSTRUCTION (BECAUSE THE
                                ; HI BYTE IS NOT USED IN THE
                                ; PRVOLNMB ROUTINE ($AE42).)
                LDA IBSMOD      ; GET VOL# FOUND (FROM RWTS'S IOB)
                STA A5L         ; AND PUT IT IN A5L.
                JSR PRVOLNMB    ; GO PRINT VOL # (BUGGY ROUTINE).
                JSR CRCATLOG    ; PRT <CR> & TEST IF PAUSE NEEDED.
                JSR CRCATLOG    ; DO IT AGAIN.

                                ; READ DIRECTORY SECTOR INTO THE
                                ; DIRECTORY SECTOR BUFFER.

                CLC             ; (C)=0, READ 1RST DIR SEC.
                                ; (C)=1, READ NEXT DIR SEC.
RDDIRSEC        JSR RDDIRECT    ; GO READ DIRECTORY SECTOR.
                BCS TOFMXTOK    ; RAN OUT OF DIR SECS SO GO EXIT.
                LDX #0          ; INITIALIZE INDEX INTO DIR SEC.

                                ; ANALYZE THE TRACK NUMBER.

DESCRPTK        STX CURDIRNX    ; SAVE NDEX TO ENTRIES IN DIR SEC.
                LDA FIL1TSTK,X  ; TRK # OF FILE'S 1RST T/S LIST
                                ; (FROM THE FILE'S DESCRIPTION IN
                                ; THE DIRECTORY SECTOR).
                BEQ TOFMXTOK    ; TRK # = 0, SO NO MORE ENTRIES IN
                                ; CURRENT DIRECTORY BUFFER.
                BMI NXDESCRP    ; TRK#=$FF=DELETED FILE SO SKIP IT

                                ; CHK FILE STATUS & PRINT LOCKED
                                ; SYMBOL ("*") OR SPACE.

                LDY #SP         ; DEFAULT (Y)=<SPC> N CASE NOT LCK
                LDA FIL1TYPE,X  ; GET FILE TYPE.
                BPL PRLOCODE    ; HI BIT CLR SO FILE UNLOCKED.
                LDY #"*"|0x80   ; RESET (Y) = LOCKED SYMBOL.
PRLOCODE        TYA             ; EITHER PRINT "*" OR <SPC>.
                JSR COUT

                                ; PRINT CHAR CODE FOR FILE TYPE &
                                ; A TRAILING <SPC>.

                LDA FIL1TYPE,X  ; GET FILE TYPE AGAIN & MAKE SURE
                IF DOS31
                AND #%00000111
                LDY #3
CHRTYPIX        LSR A
                ELSE
                AND #%01111111  ; HI BYTE IS OFF SO CAN INDEX TBL
                                ; THAT CONTAINS SYMBOLS FOR TYPES.
                LDY #7          ; SET (Y) TO INDICATE 7 RELEVANT
                                ; BITS AFTER SHIFT OUT HI BIT.
                ASL A           ; THROW AWAY HI BIT.
CHRTYPIX        ASL A           ; SHIFT REST OF BITS UNTIL HI SET.
                ENDIF
                BCS PRTFTYPE    ; # OF SHIFTS 2 SET (C) DESIGNATES
                                ; INDEX TO TYPE CHAR TABLE.
                DEY             ; REDUCE COUNT OF SHIFTS.
                BNE CHRTYPIX    ; NO SET BITS ENCOUNTERED YET, SO
                                ; GO BACK TO DO MORE SHIFTS.
PRTFTYPE        LDA FTYPETBL,Y  ; GOT A SET BIT SO NOW GET CHAR
                                ; FROM TABLE OF TYPE SYMBOLS.
                JSR COUT        ; PRINT TYPE SYMBOL.
                LDA #SP         ; PRINT TRAILING <SPC>.
                JSR COUT

                                ; PRINT FILE SIZE (EXPRESSED IN
                                ; TERMS OF SECTORS).

                LDA FIL1SIZE,X  ; GET LOW & HI BYTES OF FILE SIZE
                STA A5L         ; (IN SECTORS) FROM FILE DESCRIP
                LDA FIL1SIZE+1,X
                                ; IN CUR DIR SEC & STICK THEM IN
                STA A5H         ; IN A5L/H.
                JSR PRVOLNMB    ; PRINT FILE SIZE.
                                ; *** NOTE *** - ROUTINE IS BUGGY.
                                ; (DOESN'T USE HI BYTE, SO FILES
                                ; > 255 SECS LONG ARE EXPRESSED
                                ; AS 256 MOD.)
                LDA #SP         ; PRINT <SPC> AFTER SIZE.
                JSR COUT

                                ; PRINT THE FILE NAME.

                INX             ; KICK (X) UP CAUSE NAME STARTS AT
                INX             ; 4TH BYTE FROM START OF FILE
                INX             ; DESCRIPTION ENTRY.
                LDY #29         ; COUNTER FOR 30 CHRS/NAME (0-29).
PRTFNAME        LDA FIL1TSTK,X  ; GET CHR 4 FILE NAME & PRINT IT.
                JSR COUT        ; (P.S.  BECAUSE THE OUTPUT HOOK
                                ; STILL PTS TO DOS'S OUTPUT HNDLR,
                                ; CTRL-D AND A SUBSUBSEQUENT DOS
                                ; CMD CAN BE EMBEDDED IN THE FILE
                                ; NAME AS A PROTECTION SCHEME.)
                INX             ; KICK UP INDEX INTO FILE DESCRIP.
                DEY             ; REDUCE THE CHARACTER COUNTER.
                BPL PRTFNAME    ; BRANCH IF MORE CHARS TO PRT.
                JSR CRCATLOG    ; PRT <CR> AFTR NAME, TEST 4 PAUS.

                                ; KICK UP INDEX INTO CURRENT DIRECTORY
                                ; SECTOR BUF TO PT AT START OF NEXT
                                ; FILE DESCRIPTION ENTRY.

NXDESCRP        JSR NXPLUS35    ; ADD 35 BYTES TO INDEX SO IT PTS
                                ; TO NEXT ENTRY IN CURRENT DIR SEC.
                BCC DESCRPTK    ; (C) = 0, SO GO LOOK FOR MORE
                                ; ENTRIES IN THIS PARTICULAR
                                ; DIRECTORY SECTOR.
                BCS RDDIRSEC    ; (C) = 1, SO THERE AREN'T MORE
                                ; ENTRIES IN THIS DIRECT SECTOR.
                                ; THERE4, GO BACK TO READ IN
                                ; ANOTHER DIRECTORY SECTOR.


                                ; =================================
                                ; EXIT FILE MANAGER CLEANLY.
                                ; =================================

TOFMXTOK        JMP GOODFMXT    ; EVENTUALY RETURNS TO AFTRFUNC
                                ; ($A6AB) LOCATED IN THE FMDRIVER
                                ; ROUTINE ($A6A8).


                                ; =================================
                                ; PRINT <CR> & CHK FOR PAUSE.
                                ; =================================

CRCATLOG        LDA #CR        ; PRINT A <CR>.
                JSR COUT
                DEC SCRNSRCH    ; DEC INDEX 2 SEE IF PAUSE NEEDED.
                BNE CRCATRTN    ; PAUSE NOT REQUIRED.
                JSR RDKEY       ; PAUSE SO INFO CAN BE ABSORBED
                LDA #21         ; BEFORE SCROLLED OFF SCRN.
                STA SCRNSRCH    ; RESET INDEX FOR FRESH SCRN INFO.
CRCATRTN        RTS


                                ; =================================
                                ; CONVERT 1 HEX BYTE TO 3-DIGIT
                                ; DECIMAL (WITH LEADING ZEROES IF
                                ; APPLICABLE).
                                ; =================================

                                ; NOTE:  THIS IS A BUGGY ROUTINE
                                ; - DOESN'T USE HI BYTE SO NUMBERS
                                ; GREATER THAN 255 ARE EXPRESSED
                                ; AS 256 MOD.
                                ;
                                ; (PS. TO USE AS A STAND-ALONE
                                ; ROUTINE, LOAD A5L WITH HEX & CALL
                                ; PRVOLNMB.  DESTROYS (A) & (Y) REGS.
                                ; CONVERSION DONE BY SIMULATING
                                ; DIVISION VIA SUCCESSIVE SUBTRACTIONS
                                ; OF POWERS OF 10.)

PRVOLNMB        LDY #2          ; INDEX TO # OF CONVERSION FACTORS
                                ; AND DIGITS.
ZONSTK          LDA #0          ; INIT COUNT OF # OF SUBTR'S DONE.
                PHA             ; SAVE COUNT ON STACK.
GETVNMB         LDA A5L         ; GET LOW BTE HEX AND CMP IT TO
                CMP BASETEN,Y   ; TABLE OF CONVERSION FACTORS.
                                ; CONVERSION TABLE CONTAINS POWERS
                                ; OF 10: 10^2=100, 10^1=10, 10^0=1
                BCC TONEGASC    ; BRANCH IF # < CONVERSION FACTOR.
                SBC BASETEN,Y   ; SUBTRACT THE CONVERSION FACTOR.
                STA A5L         ; STORE THE REMAINDER.
                LDA A5H         ; NONSENSE - NOT USED.
                SBC #0          ; NONSENSE - NOT USED.
                STA A5H         ; NONSENSE - NOT USED.
                PLA             ; GET COUNTER OF # OF SUBT'S AND
                ADC #0          ; ADD (C). IF REMAIN. > CONVERSION
                PHA             ; FACTOR, ADD 1, ELSE ADD NOTHING.
                JMP GETVNMB     ; GO BACK TO DO MORE SUBT'S WITH
                                ; SAME CONVERSION FACTOR.
TONEGASC        PLA             ; GET RESULT OF DIV (IE. WHOLE #
                                ; OF SUBTRACTIONS).
                ORA #$B0        ; CONVERT COUNT TO NEG ASCII CHAR.
                JSR COUT        ; PRT CHAR.
                DEY             ; 3 CHARS/VOL# (IE. 2 TO 0).
                BPL ZONSTK      ; (3 CONVERSION FACTORS.)
                RTS


                                ; =================================
                                ; COPY CONTENTS OF FM WORK BUFFER
                                ; (IN DOS CHAIN) TO FM WORK AREA
                                ; (NOT IN DOS CHAIN).
                                ; =================================

RSTRFMWA        JSR SELWKBUF    ; PT A4L/H AT FM WORK BUF.
                                ; (GET ADR FRM FM PARAMETER LIST.)
                LDY #0          ; ZERO OUT RETURN CODE IN FM PARM
                STY RTNCODFM    ; LIST TO SIGNAL NO ERORS.
STORFMWK        LDA (A4L),Y     ; COPY FM WORK BUF 2 FM WORK AREA.
                STA FMWKAREA,Y
                INY
                CPY #45         ; 45 BYTES TO COPY (0 TO 44).
                BNE STORFMWK
                CLC             ; WHY?????
                RTS


                                ; =================================
                                ; COPY FM WORK AREA TO FM WORK BUF
                                ; (LOCATED IN CHAIN OF DOS BUFS).
                                ; =================================

CPYFMWA         JSR SELWKBUF    ; PT A4L/H AT FM WORK BUF (CHAIN).
                                ; (GET ADR FROM FM PARM LIST.)
                LDY #0          ; INITIALIZE INDEX.
STORWRK         LDA FMWKAREA,Y  ; COPY WORK AREA ----->  WORK BUF.
                STA (A4L),Y
                INY
                CPY #45         ; 45 BYTES TO COPY (0 TO 44).
                BNE STORWRK
                RTS


                                ; =================================
                                ; INIT FUNCTION HANDLER.
                                ; =================================

FNINIT          JSR ZWRKAREA    ; INIT THE FM WRK AREA (NON-CHAIN)
                LDA #4          ; OPCODE FOR FORMAT.

                                ; GO FORMAT THE DISK.

                JSR RWTSDRV1    ; CALL RWTS DRIVER TO FORMAT DISK.

                                ; PUT VOL#, # OF NEXT TRK TO BE
                                ; ASSIGNED & ASSIGNMENT DIRECTION
                                ; IN THE VTOC SECTOR BUFFER.

                LDA VOLWA       ; COMPLEMENTED VOL# (FRM WRK AREA)
                EOR #$FF        ; UNCOMPL. IT & PUT VOL# IN VTOC.
                STA VOLUSED
                LDA #$11        ; USE TRK # 17 FOR CATALOG TRK.
                STA NXTRKUSE    ; SET CAT TRK AS NXT TRK TO ALLOC.
                                ; (NXTRKUSE IS LOCATED IN VTOC.)
                LDA #1          ; ALLOCATION DIRECTION = FORWARD.
                STA DRECTION

                                ; ZERO OUT VTOC FROM FRESECMAP TO
                                ; END OF SECTOR.  (NOTE:  THIS
                                ; ASSIGNS ALL TRACKS.)

                LDX #FRESECMAP-VTOCBUFF ; OFFSET INTO VTOC TO FRESECMAP.
                LDA #0
ZVTOC           STA VTOCBUFF,X  ; ZERO OUT A TRKMAP BYTE.
                INX
                BNE ZVTOC

                                ; FREE UP ALL TRKS EXCEPT TRKS 0,
                                ; 1, 2 & CAT TRK (#17).
                                ;
                                ; NOTE: DOS ONLY OCCUPIES SECTORS
                                ; 0 TO 4 ON TRK 2, BUT ROUTINE
                                ; TAKES REST OF SECS ON TRK 2 OUT
                                ; OF CIRCULATION.

                LDX #$03*4      ; OFFSET TO START OF TRKMAP3.
FREETRK         CPX #$23*4      ; OFFSET 1 PAST END OF TRKMAP34.
                BEQ FREEDTKS    ; DONE UP TO END OF TRKMAP34.
                LDY #3          ; INIT INDEX TO END OF FRETKMSK.
FREEIT          LDA FRETKMSK,Y  ; FREE MOST TRKMAPS.  (STARTING
                                ; WITH TRKMAP3).
                                ; NOTE:  NOT FREEING UP VTOC SEC
                                ; OR TRKS USED BY DOS.
                STA FRESECMAP,X   ; FREE TRKS BY PLACING FOLLOWING
                                ; BYTES IN @ TRKMAP:  "FF FF 00 00"
                INX             ; KICK UP INDEX TO BYTE IN TRKMAP.
                DEY             ; REDUCE INDEX TO FRETKMSK CAUSE
                                ; LOADING FROM END OF FRETKMSK:
                                ; "00 00 FF FF".
                BPL FREEIT      ; (4BYTES/TRKMAP & 4BYTS/FRETKMSK)
                CPX #$11*4      ; OFFSET TO START OF TRKMAP17
                                ; (IE. CATALOG TRACK).
                BNE FREETRK     ; HAVE WE FREED TRKS 3 TO 16 YET?
                                ; IF NOT - BRANCH.
                LDX #$12*4      ; OFFSET TO TRK 18 (IE. SKIP THE
                                ; CATALOG TRACK).
                BNE FREETRK     ; ALWAYS - GO FREE TRKS 18 TO 34.
FREEDTKS        JSR WRITVTOC    ; WRITE FREED UP VTOC TO DISK.

                                ; CLEAR OUT THE DIRECTORY SEC BUF.

                LDX #0
                TXA
CLRDIREC        STA DIRECBUF,X
                INX
                BNE CLRDIREC
                JSR PT2DIRBF    ; DESIGNATE DIR SEC BUF AS I/O BUF
                LDA #$11        ; (A) = # OF CAT TRK.
                LDY SECPERTK    ; # OF SECS/TRK = 16.
                DEY
                DEY
                STA IBTRK       ; PUT CAT TRK IN IOB.

                                ; WRITE DIRECTORY SECS (TRK17,
                                ; SECS 15 TO 1) TO DISK.

SETLNKTK        STA DIRLNKTK    ; SET TRK/SEC VALS FOR LINK 2 NEXT
SETLNKSC        STY DIRLNKSC    ; DIRECTORY SECTOR.
                INY             ; GET SEC # TO WRITE & PUT IT IN
                STY IBSECT      ; RWTS'S IOB.
                LDA #2          ; WRITE OPCODE.
                JSR RWTSDRV1    ; WRITE DIRECTORY SEC TO DISK.
                LDY DIRLNKSC    ; SEC VAL OF NEXT DIR SEC 2 WRITE.
                DEY             ; KICK IT DWN (WILL INC IT LATER).
                BMI DOIMAGE     ; DON'T DO SEC 0 CAUSE THAT'S VTOC
                BNE SETLNKSC    ; GO WRITE SECS 2 TO 15.
                TYA
                BEQ SETLNKTK    ; GO BACK TO WRITE SEC 1 AND ZERO
                                ; OUT THE DIRECTORY SECTOR LINKS.

                                ; ROUTINE TO WRITE THE DOS
                                ; IMAGE ON TRACKS 0 TO 2.

DOIMAGE         JSR PRPWRDOS    ; GET READY TO WRITE DOS IMAGE.
                JSR WRDOSIMG    ; WRITE DOS IMAGE TO DISK.
                JMP GOODFMXT    ; EXIT FM CLEANLY. EVENTUALLY RTNS
                                ; TO AFTRFUNC ($A6AB) LOCATED IN
                                ; THE FMDRIVER ROUTINE ($A6A8).
                IF DOS31
PRPWRDOS        LDA SUBCODFM
                STA   IBBUFP+1
                LDA   #0
                STA   IBBUFP
                LDA   VOLWA
                EOR   #$FF
                STA   IBVOL
                RTS
                ENDIF

                                ; =================================
                                ; POINT A4L/H AT A SPECIFIC
                                ; SECTION OF A DOS BUFFER.
                                ; =================================

SELWKBUF        LDX #0          ; SELECT WORK BUFFER.
                BEQ PT2FMBUF    ; ALWAYS.
SELTSBUF        LDX #2          ; SELECT T/S LIST BUFFER.
                BNE PT2FMBUF    ; ALWAYS.
SELDABUF        LDX #4          ; SELECT DATA BUFFER.
PT2FMBUF        LDA WRKBUFFM,X  ; GET ADDR OF SELECTED BUF FROM
                STA A4L         ; FM PARM LST & PUT IT IN POINTER.
                LDA WRKBUFFM+1,X
                STA A4H
                RTS

                IF DOS31
ZCURBUF         LDA #0
                TAY
L2E53           STA (A4L),Y
                INY
                BNE L2E53
                RTS
                ENDIF

                                ; =================================
                                ; CHK IF DATA SEC BUF HAS CHANGED
                                ; SINCE LAST READ OR WRITE.
                                ; =================================

CKDATUP         BIT UPDATFLG    ; CHK BIT6 SO SEE IF CHANGED.
                BVS WRITDATA    ; TAKE BRANCH IF CHANGED.
                RTS


                                ; =================================
                                ; WRITE PRESENT DATA SECTOR BUFFER
                                ; TO THE DISK.  (UPDATES DISK SO
                                ; CAN READ IN NEXT DATA SEC WITH-
                                ; OUT OVERWRITING AND THEREFORE
                                ; LOSING PREVIOUS DATA.)
                                ; ---------------------------------

WRITDATA        JSR PRPDAIOB    ; PREPARE RWTS'S IOB FOR WRITING
                                ; DATA SEC BUF TO DISK.
                LDA #2          ; OPCODE FOR WRITE CMD.
                JSR RWTSDRVR    ; CALL DRIVER 2 WRT DATA SEC BUF.
                LDA #%10111111  ; SHUT BIT6 OFF IN UPDATE FLAG TO
                AND UPDATFLG    ; SIGNAL THAT THE DATA SECTOR BUF
                STA UPDATFLG    ; IS UP TO DATE.
                RTS


                                ; ===================================
                                ; CHK IF T/S LIST REQUIRES UPDATING.
                                ; (HAS T/S LIST BUF CHANGED SINCE
                                ; LAST READ OR WRITE?)
                                ; ===================================

CKTSUPDT        LDA UPDATFLG
                BMI WRITETS     ; IF BIT7 SET, UPDATING REQUIRED.
                RTS


                                ; =================================
                                ; UPDATE T/S LIST SEC BUF ON DISK.
                                ; ---------------------------------

WRITETS         JSR SETTSIOB    ; PREPARE RWTS'S IOB FOR WRITING
                                ; T/S LIST BUFFER TO DISK.
                LDA #2          ; RWTS'S WRITE OPCODE.
                JSR RWTSDRVR    ; CALL RWTS DRIVER 2 WRITE T/S LST
                LDA #$7F        ; CLR BIT7 OF UPDATE FLAG 2 SIGNAL
                AND UPDATFLG    ; THAT T/S LIST IS UP TO DATE.
                STA UPDATFLG
                RTS


                                ; =================================
                                ; PREPARE RWTS'S IOB FOR READING
                                ; OR WRITING T/S LIST SEC.
                                ; =================================

SETTSIOB        LDA TSBUFFM     ; GET ADR OF T/S LIST BUF FROM
                STA IBBUFP      ; FM PARM LIST & DESIGNATE AS I/O
                LDA TSBUFFM+1   ; BUF IN RWTS'S IOB.
                STA IBBUFP+1
                LDX CURTSTRK    ; SET (X)/(Y) = TRK/SEC OF CURRENT
                LDY CURTSSEC    ; T/S LIST SECTOR.
                RTS


                                ; =================================
                                ; READ T/S LIST SEC TO BUFFER.
                                ; =================================

READTS          PHP             ; SAVE CARRY ON STK.
                                ; (C)=0=READ 1RST T/S LIST SEC.
                                ; (C)=1=READ NEXT T/S LIST SEC.
                JSR CKTSUPDT    ; WRITE T/S LIST SEC BUF IF
                                ; UPDATING REQUIRED.  (IF T/S LST
                                ; BUF HAS CHANGED SINCE LAST READ
                                ; OR WRITE, THEN WRITE IT BACK TO
                                ; DISK SO DON'T OVERWRITE BUF AND
                                ; LOSE INFO WHEN RD NEW T/S LIST.)
                JSR SETTSIOB    ; PREP RWTS'S IOB FOR READING T/S
                                ; LIST SEC.
                JSR SELTSBUF    ; POINT A4L/H AT T/S LIST BUF.
                                ; (GETS ADR FROM FM PARM LIST.)
                PLP             ; GET SAVED (C) BACK FROM STK.
                BCS RDNXTTS     ; IF (C)=1, ALREADY READ 1RST T/S
                                ; LIST SEC, SO GO READ NEXT ONE.

                                ; READ 1RST T/S LIST SEC.
                                ; (CARRY WAS CLR.)

RDFIRSTS        LDX FIRSTSTK    ; SET (X)/(Y)=TRK/SEC OF 1RST T/S
                LDY FIRTSSEC    ; LIST SECTOR.
                JMP RDTSLST     ; GO READ T/S LIST SEC INTO BUF.
                                ; ---

                                ; READ NEXT T/S LIST SEC.
                                ; (CARRY WAS SET.)

RDNXTTS         LDY #1          ; INDEX INTO T/S LIST BUF.
                LDA (A4L),Y     ; TRK FOR LNK 2 NEXT T/S LIST SEC.
                BEQ TSLNKZRO    ; LINK ZEROED OUT SO NO MORE
                                ; T/S LIST SECS FOR FILE.
                TAX             ; (X) = NEXT T/S LIST TRK.
                INY
                LDA (A4L),Y     ; SEC# FOR LNK 2 NXT T/S LIST SEC.
                TAY             ; (Y) = NEXT T/S LIST SEC.
                JMP RDTSLST     ; GO READ NEXT T/S LIST SEC IN.
                                ; ---

                                ; T/S LINK ZEROED OUT SO
                                ; DECIDE IF ERROR OR NOT.

TSLNKZRO        LDA OPCODEFM    ; CHK R/W STATUS TO SEE IF WANT TO
                CMP #4          ; ADD ANOTHER T/S LIST.
                BEQ UPDATETS    ; WRITING - GO UPDATE LINK.
                SEC             ; WERE READING & LNK ZEROED OUT,
                RTS             ; SO RTN WITH (C)=1 SO GENERATE AN
                                ; ===             ;ERROR. (REMEMBER, PREVIOUSLY SET
                                ; RTN CODE TO A DEFAULT VALUE FOR
                                ; FILE-NOT-FOUND.) HOWEVER, IF
                                ; READING IS BEING DONE FOR AN
                                ; APPEND OR VERIFICATION, THEN THE
                                ; SET (C) JUST DENOTES THAT HAVE
                                ; REACHED THE END OF THE FILE.

                                ; WRITING & LNK ZEROED OUT SO MUST
                                ; ALLOCATE A NEW T/S LIST SECTOR.

UPDATETS        JSR ASGNTKSC    ; FIND & RESERVE TRK/SEC VALS FOR
                                ; A NEW T/S LIST SECTOR.

                                ; LINK THE NEW T/S LIST SECTOR TO
                                ; THE LAST T/S LIST SECTOR AND
                                ; THEN WRITE THE UPDATED VERSION
                                ; OF THE LAST T/S LIST SECTOR TO
                                ; THE DISK.

LNKOLDNW        LDY #2          ; OFFSET TO SEC# LINK BYTE.
                STA (A4L),Y     ; PUT NEW SEC VAL IN LINK AND THEN
                PHA             ; SAVE IT ON STK.
                DEY             ; OFFSET TO TRK BYTE OF LINK.
                LDA ASIGNTRK    ; PUT NEW TRK VAL IN LINK.
                STA (A4L),Y
                PHA             ; SAVE TRK VAL ON STK.
                JSR WRITETS     ; WRITE UPDATED T/S LIST TO DISK.

                                ; SET UP A BRAND NEW T/S LIST
                                ; SECTOR & WRITE IT TO DISK.

ZOUTTS          JSR ZCURBUF     ; ZERO OUT T/S LIST BUF.
                LDY #5          ; AT OFFSETS 5 & 6 IN2 THE NEW T/S
                LDA RELASTP1    ; LIST, PUT REL SEC # PLUS 1 (IN
                STA (A4L),Y     ; RELATION TO THE ENTIRE FILE) OF
                INY             ; THE 1RST DATA PAIR THAT WILL BE
                LDA RELASTP1+1  ; DESCRIBED IN THIS NEW T/S LIST.
                STA (A4L),Y     ; (POSSIBLE VALUES ARE:  $007A,
                                ; 2*$007A, 3*$007A AND 4*$007A.
                PLA             ; GET (X)/(Y)=TRK/SEC VALS 4 THIS
                TAX             ; NEW T/S LIST SEC OFF STACK.
                PLA
                TAY
                LDA #2          ; WRITE OPCODE FOR RWTS.
                BNE RDWRTS      ; ALWAYS - GO WRITE T/S LIST SEC.
                                ; ---

                                ; SUBROUTINE TO READ T/S LIST SEC.

RDTSLST         LDA #1          ; READ OPCODE FOR RWTS.

                                ; COMMON TO READ/WRITE T/S LIST.

RDWRTS          STX CURTSTRK    ; NEW T/S LIST SECTOR TRK/SEC VALS
                STY CURTSSEC    ; BECOME CURRENT TRK/SEC VALS.
                JSR RWTSDRVR    ; CALL RWTS DRIVER 2 READ OR WRITE
                                ; THE CURRENT T/S LIST SECTOR.

                                ; UPDATE FM WORK AREA BUF (NON-CHAIN).

                LDY #5          ; OFFSET IN2 CURRENT T/S LIST BUF.
                LDA (A4L),Y     ; STORE REL SEC # OF 1RST DAT PAIR
                STA RELFIRST    ; THAT CAN BE DESCRIBED IN THIS
                                ; T/S LIST. (POSSIBLE VALUES ARE:
                                ; $0000, $007A, 2*$007A, 3*$007A
                                ; AND 4*$007A.)
                CLC             ; ADD THE MAXIMUM # OF DATA SECS
                ADC MXSCURTS    ; THAT CAN POSSIBLY BE DESCRIBED
                                ; IN THIS T/S LIST.
                STA RELASTP1    ; STORE THE MAXIMUM RELATIVE SEC #
                INY             ; (PLUS 1) OF THE LAST DATA PAIR
                                ; THAT CAN POSSIBLY BE DESCRIBED
                                ; IN THIS T/S LIST.
                LDA (A4L),Y
                STA RELFIRST+1
                ADC MXSCURTS+1
                STA RELASTP1+1  ; (RELASTP1/+1 IS ALWAYS SET TO
                                ; $007A BY FNOPEN.  (POSSIBLE VALS
                                ; ARE:  $007A, 2*$007A, 3*$007A,
                                ; 4*$007A OR 5*$007A.)
                CLC             ; RETURN WITH NO ERRORS SIGNAL.
                RTS


                                ; =================================
                                ; READ DATA SEC TO DATA SEC BUF.
                                ; =================================

READDATA        JSR PRPDAIOB    ; SET UP RWTS'S IOB 2 RD DATA SEC.
                LDA #1          ; READ OPCODE FOR RWTS.
                JMP RWTSDRVR    ; CALL RWTS DRIVER 2 READ DAT SEC.


                                ; =================================
                                ; PREP RWTS'S IOB TO READ
                                ; OR WRITE THE DATA SECTOR.
                                ; ==================================

PRPDAIOB        LDY DATBUFFM    ; GET ADR OF DATA SEC BUF FROM THE
                LDA DATBUFFM+1  ; FM PARM LIST & DESIGNATE IT AS
                STY IBBUFP      ; THE I/O BUF FOR RWTS'S IOB.
                STA IBBUFP+1
                LDX CURDATRK    ; ENTER RWTS DRIVER WITH (X)/(Y)
                LDY CURDATSC    ; CONTAINING THE TRK/SEC VALUES OF
                RTS             ; THE DATA SECTOR.

                                ; =================================
                                ; READ THE VOLUME TABLE
                                ; OF CONTENTS (VTOC).
                                ; =================================

READVTOC        LDA #1          ; READ OPCODE FOR RWTS.
                BNE RDWRVTOC    ; ALWAYS.


                                ; =================================
                                ; WRITE VOLUME TABLE
                                ; OF CONTENTS (VTOC).
                                ; ---------------------------------

WRITVTOC        LDA #2          ; WRITE OPCODE FOR RWTS.

                                ; COMMON TO READ/WRITE VTOC.

RDWRVTOC        LDY ADRVTOC     ; GET ADR OF VTOC FRM FM CONSTANTS
                STY IBBUFP      ; TABLE & DESIGNATE IT AS THE I/O
                LDY ADRVTOC+1   ; BUF IN RWTS'S IOB.
                STY IBBUFP+1
                LDX TRKWA       ; ENTER RWTS DRIVER WITH (X)/(Y)
                LDY #0          ; EQUAL TO TRK/SEC VALS OF VTOC.
                JMP RWTSDRVR    ; CALL DRIVER TO READ/WRITE VTOC.


                                ; =================================
                                ; READ A DIRECTORY SECTOR.
                                ; =================================

RDDIRECT        PHP             ; SAVE (C) ON STK:
                                ; (C) = 0 = READ 1RST DIR SEC.
                                ; (C) = 1 = READ NEXT DIR SEC.

                JSR PT2DIRBF    ; DESIGNATE DIR SEC BUF AS I/O BUF
                                ; IN RWTS'S IOB.
                PLP             ; CHK IF DEALING WITH 1RST DIR SEC
                BCS RDNXTDIR    ; NO - GO READ NEXT DIR SEC.

                                ; READ THE FIRST DIRECTORY SECTOR.
                                ; (C) = 0

RDFIRDIR        LDY FIRDIRSC    ; (Y)/(X)=TRK/SEC VALS OF 1RST
                LDX FIRDIRTK    ; DIRECTORY SEC (FROM VTOC BUF).
                BNE DODIRRD     ; ALWAYS - GO READ IN DIREC SEC.

                                ; READ THE NEXT DIRECTORY SECTOR.
                                ; (C) = 1

RDNXTDIR        LDX DIRLNKTK    ; GET TRK OF NXT DIR SEC FROM LINK
                                ; IN CURRENT DIRECTORY SECTOR.
                BNE GETDIRLK    ; LINK NOT ZEROED OUT.
                SEC             ; LINK ZEROED OUT -EXIT WITH (C)=1
                RTS             ; TO SIGNAL NO MORE DIREC SECS.
                                ; ===

GETDIRLK        LDY DIRLNKSC    ; GET SEC OF NEXT DIR SEC FRM LINK
                                ; BYTES IN CURRENT DIRECTORY SEC.

                                ; CALL TO READ IN DIRECTORY SECTOR.

DODIRRD         STX CURDIRTK    ; SAV TRK/SEC VALS OF DIRECTORY WE
                STY CURDIRSC    ; ARE ABOUT 2 READ SO THEY WILL BE
                                ; THE CURRENT DIRECTORY SEC VALS
                                ; FOR THE NEXT TIME AROUND.
                LDA #1          ; READ OPCODE FOR RWTS.
                JSR RWTSDRVR    ; CALL RWTS DRIVER TO DO THE READ.
                CLC             ; LINK DIDN'T ZERO OUT SO SIGNAL
                RTS             ; MORE DIREC SECS EXIST & THEN XIT


                                ; =================================
                                ; WRITE THE DIRECTORY BUFFER.
                                ; =================================

WRDIRECT        JSR PT2DIRBF    ; DESIGNATE DIREC SEC BUF AS I/O
                                ; BUF IN RWTS'S IOB.
                LDX CURDIRTK    ; ENTER RWTS DRIVER WITH (X)/(Y)
                LDY CURDIRSC    ; EQUAL TO THE TRK/SEC VALS OF THE
                                ; DIRECTORY SECTOR.
                LDA #2          ; WRITE OPCODE FOR RWTS.
                JMP RWTSDRVR    ; CALL DRIVER TO WRITE DIREC SEC.


                                ; ==================================
                                ; DESIGNATE DIRECTORY SECTOR BUFFER
                                ; AS I/O BUFFER IN RWTS'S IOB.
                                ; ==================================

PT2DIRBF        LDA ADRDIRBF    ; GET ADDR OF DIREC SEC BUF FROM
                STA IBBUFP      ; FM CONSTANTS TBL & DESIGNATE IT
                LDA ADRDIRBF+1  ; AS I/O BUFFER IN RWTS'S IOB.
                STA IBBUFP+1
                RTS


                                ; ==================================
                                ; READ/WRITE TRACK/SECTOR DRIVERS.
                                ; ==================================

RWTSDRVR        STX IBTRK       ; ENTER WITH (X) = TRK WANTED.
                STY IBSECT      ; (Y) = SEC WANTED.
RWTSDRV1        STA IBCMD       ; (A) = OPCODE FOR RWTS
                                ; RWTSDRV1 = ENTRY PT USED BY INIT
                                ; FUNCTION HNDLR WHEN FORMATTING.
                CMP #2          ; IS CMD A WRITE?  NOTE: THE "CMP"
                                ; CONDITIONS THE CARRY AS FOLLOWS:
                                ; (C)=0 =SEEK ($00) OR READ ($01)
                                ; (C)=1 =WRITE($02) OR FORMAT($03)
                BNE SKPWRSET    ; BRANCH IF NOT WRITING.
                ORA UPDATFLG    ; CONDITION UPDATE FLG 2 DESIGNATE
                STA UPDATFLG    ; LAST OPERATION WAS A WRITE (FOR
                                ; NEXT TIME AROUND).

                                ; FINISH SETTING UP RWTS'S
                                ; INPUT/OUTPUT BLOCK (IOB).

SKPWRSET        LDA VOLWA       ; PUT COMPLEMENTED VOL IN IOB.
                EOR #$FF
                STA IBVOL
                LDA SLOT16WA    ; PUT SLOT*16 IN IOB.
                STA IBSLOT
                LDA DRVWA       ; PUT DRIVE # IN IOB.
                STA IBDRVN
                LDA SECSIZWA    ; PUT SEC LENGTH IN IOB  (STANDARD
                STA IBSECSZ     ; SIZE OF #256 OR $0100 BYTES).
                LDA SECSIZWA+1
                STA IBSECSZ+1
                LDA #1
                STA IBTYPE
                LDY ADRIOB      ; SET (Y) & (A) TO POINT AT
                LDA ADRIOB+1    ; RWTS'S IOB.


                                ; =================================
                                ; CALL RWTS
                                ; =================================

                IF DOS31
                JSR RWTS
                ELSE
                JSR ENTERWTS    ; SAV STATUS,SET INTERRUPT DISABLE
                                ; FLAG & CALL RWTS TO PERFORM TASK
                ENDIF
                                ; (SEEK, READ, WRITE, FORMAT).
                LDA IBSMOD      ; GET VOL FOUND (FRM IOB) & PUT IT
                STA VOLFM       ; IN THE FM PARAMETER LIST.
                LDA #$FF        ; PUT VOL WANTED IN IOB.
                STA IBVOL       ; (USE 255 AS DEFAULT VAL FOR NEXT
                                ; TIME.  ACTUALLY USING 0 CAUSE
                                ; #$FF EOR #$FF = $00).
                BCS ERRWTSDR    ; OPERATION WAS UNSUCCESSFUL.
                RTS             ; ABOVE BRANCH NEVER TAKEN WHEN
                                ; USING SEEK CMD, CAUSE NO ERROR
                                ; CHKING ROUTINES ARE ENCOUNTERED
                                ; BY A LONE SEEK OPERATION.


                                ; =================================
                                ; OPERATION WAS NOT SUCCESSFUL.
                                ; =================================

ERRWTSDR        LDA IBSTAT      ; GET RWTS'S ERROR CODE.

                                ; TRANSLATE RWTS ERROR CODE (A)
                                ; TO FM ERROR CODE (Y).  (DOS LATER
                                ; EMPLOYS FM ERROR CODE IN ROUTINE
                                ; USED TO PRINT ERROR MESSAGES.)

                LDY #7          ; SET (Y) FOR FM ERROR CODE.
                CMP #$20        ; VOL MISMATCH?
                BEQ SETFMERR    ; YES.
                LDY #4          ; NO.
                CMP #$10        ; WRITE PROTECTED?
                BEQ SETFMERR    ; YES.
                LDY #8          ; NO - MUST HAVE BEEN OTHER SO
SETFMERR        TYA             ; DESIGNATE IT AS GENERAL I/O ERR.
                JMP BADFMXIT    ; GO HANDLE ERROR.
                                ; ANY ERR ENCOUNTERED WHEN FORMAT-
                                ; TING IS TREATED AS AN I/O ERROR.


                                ; ==========================================
                                ; READ DATA SEC IF NECESSARY.
                                ; ==========================================

                                ; CHECK IF NEED TO READ THE NEXT DATA
                                ; SECTOR INTO THE DATA SECTOR BUFFER.
                                ;
                                ; - IS DATA SEC WE WANT ALREADY IN MEMORY?
                                ; - IF SO, DOES IT REQUIRE UPDATING?

                                ; IF THE SECTOR OFFSET INTO FILE (FILPTSEC)
                                ; EQUALS THE RELATIVE  SECTOR NUMBER OF THE
                                ; LAST SECTOR READ OR WRITTEN (RELPREV),
                                ; THEN THE SECTOR WE WANT IS PRESENTLY IN
                                ; MEMORY.  IF IT IS NOT IN MEMORY, READ IN
                                ; THE DATA SECTOR WANTED.  HOWEVER, FIRST
                                ; CHECK IF THE DATA SECTOR HAS CHANGED
                                ; SINCE THE LAST READ OR WRITE.  IF IT HAS,
                                ; THE DISK MUST BE UPDATED BEFORE WE READ
                                ; IN THE NEW DATA SECTOR SO WE DON'T OVER-
                                ; WRITE THE DATA SECTOR BUFFER AND LOOSE
                                ; INFORMATION.
                                ; NOTE: - IF THIS SUBROUTINE IS CALLED
                                ; FROM A WRITE SUBFUNCTION AND
                                ; FILPTSEC IS NOT EQUAL TO RELPREV,
                                ; THEN THE DATA SECTOR BUFFER MUST
                                ; BE FULL AND SHOULD BE WRITTEN
                                ; TO THE DISK BEFORE ANY MORE
                                ; INFORMATION IS READ IN.
                                ; - IF THE FILE WAS JUST OPENED, THE
                                ; OPEN SUBFUNC SET FILPTSEC=#$0000
                                ; AND RELPREV=#$FFFF SO ALWAYS
                                ; FORCE READING OF A NEW DATA SEC
                                ; EVEN IF THE CORRECT SECTOR IS
                                ; ALREADY IN MEMORY.

NXTDATRD        LDA FILPTSEC    ; LAST SEC USED VS CUR SEC WNTD.
                CMP RELPREV
                BNE CKWCURDA    ; NOT SAME - WILL EVENTUALLY HAVE
                                ; TO READ NEW DATA SEC IN.
                LDA FILPTSEC+1  ; MAYBE SAME - CHK HI BYTES.
                CMP RELPREV+1
                BEQ XITNXDAT    ; SAME SO GO EXIT.


                                ; =====================================
                                ; WRITE THE DATA SECTOR IF NECESSARY.
                                ; -------------------------------------

                                ; DATA SEC WE WANT IS NOT PRESENTLY IN
                                ; MEMORY.  CHK IF NEED TO WRITE THE
                                ; CURRENT DATA SEC BUF BEFORE WE READ
                                ; IN THE WANTED DATA SECTOR.

CKWCURDA        JSR CKDATUP     ; CHK UPDATE FLG 2 SEE IF DATA SEC
                                ; BUF HAS CHANGED SINCE LAST R/W.
                                ; IF IT HAS, WRITE DATA BUF 2 DSK.

                                ; SHOULD THE CURRENT T/S LIST BE USED?
                                ; (THAT IS, SHOULD THE DATA SECTOR BE
                                ; LISTED IN THE PRESENT T/S LIST SECTOR?
                                ; IF NOT, THEN WILL NEED TO READ IN THE
                                ; CORRECT T/S LIST.)

                                ; IS THE SECTOR OFFSET INTO THE FILE OF
                                ; THE PRESENT DATA SECTOR LESS THAN THE
                                ; RELATIVE SECTOR NUMBER OF THE FIRST
                                ; DATA SECTOR THAT CAN BE DESCRIBED IN
                                ; THE T/S LIST PRESENTLY IN MEMORY?
                                ; (IF LESS, THEN NEED TO READ IN A
                                ; DIFFERENT T/S LIST SECTOR.)

CKCURTS         LDA FILPTSEC+1  ; SEC OFFSET INTO FILE ASSOCIATED
                CMP RELFIRST+1  ; WITH THE PRESENT DATA SECTOR
                                ; VERSUS THE RELATIVE SEC# OF THE
                                ; FIRST DATA SEC DESCRIBED IN THE
                                ; PRESENT T/S LIST.
                BCC NEEDNXTS    ; DATA SEC WANTED REPRESENTS A
                                ; SMALLER OFFSET INTO FILE SO NEED
                                ; A DIFFERENT T/S LIST.
                BNE CKCURTS1    ; SEC OFFSET OF WANTED DATA SEC IS
                                ; LARGER THAN THAT OF THE 1RST DAT
                                ; SEC THAT CAN BE DESCRIBED IN THE
                                ; PRESENT T/S LIST SO IT MAY STILL
                                ; BELONG TO THIS T/S LIST.
                LDA FILPTSEC    ; HI BYTES SAME -SO CMP LOW BYTES.
                CMP RELFIRST
                BCC NEEDNXTS    ; SEC OFFSET OF WNTD FILE IS LESS
                                ; SO READ IN A DIFFERENT T/S LIST.
                                ; (START BY READING THE FILE'S
                                ; FIRST T/S LIST.)

                                ; SECTOR OFFSET ASSOCIATED WITH THE DATA
                                ; SECTOR WE WANT IS EITHER GREATER THAN
                                ; OR EQUAL TO THE RELATIVE SECTOR OFFSET
                                ; ASSOCIATED WITH THE FIRST DATA SECTOR
                                ; THAT CAN BE DESCRIBED IN THIS T/S LIST.
                                ; THEREFORE, COMPARE THE SECTOR OFFSET
                                ; OF THE SECTOR WANTED WITH THE RELATIVE
                                ; SECTOR NUMBER (PLUS 1) OF THE LAST
                                ; SECTOR THAT CAN BE DESCRIBED IN THE
                                ; PRESENT T/S LIST.

CKCURTS1        LDA FILPTSEC+1  ; SEC OFFSET OF DATA SEC WANTED
                CMP RELASTP1+1  ; VS RELATIVE SEC # OF THE LAST
                                ; DATA SEC THAT CAN POSSIBLY BE
                                ; DESCRIBED IN THE PRES T/S LIST.
                BCC GETDATPR    ; SEC OFFSET ASSOC WITH DATA SEC
                                ; WANTED IS DESCRIBED IN THE
                                ; PRESENT T/S LIST.
                BNE NEEDNXTS    ; SEC OFFSET OF PRESENT DATA SEC
                                ; IS LARGER THAN THAT OF THE LAST
                                ; DATA SECTOR (PLUS 1) THAT CAN
                                ; POSSIBLY BE DESCRIBED IN THE
                                ; PRESENT T/S LIST, SO WE NEED A
                                ; NEW T/S LIST SECTOR.
                LDA FILPTSEC    ; HI BYTES SAME -SO CMP LOW BYTES.
                CMP RELASTP1
                BCC GETDATPR    ; SEC OFFSET ASSOCIATED WITH THE
                                ; DATA SECTOR WE WANT IS LESS THAN
                                ; THE RELATIVE SEC # (PLUS 1) OF
                                ; THE LAST DATA SECTOR THAT CAN
                                ; POSSIBLY BE LISTD IN THE PRESENT
                                ; T/S LIST.  (THERE4, THE WANTED
                                ; DATA SEC SHOULD BE DESCRIBED IN
                                ; THE PRESENT T/S LIST.)

                                ; THE DATA SECTOR WE WANT IS NOT
                                ; LISTED IN THE PRESENT T/S LIST,
                                ; SO WE MUST READ A DIFFERENT T/S
                                ; LIST SECTOR.  (NOTE: ROUTINE IS
                                ; ENTERED WITH (C) = 1 IF NEED A
                                ; HIGHERED NUMBERED T/S LIST.
                                ; IF (C) = 0, THEN THE FILE POINTER
                                ; WAS BACKED UP AND WE NEED A SMALLER
                                ; NUMBERED T/S LIST.)

NEEDNXTS        JSR READTS      ; READ IN THE NEXT (OR FIRST) T/S
                                ; LIST.  HOWEVER, FIRST CHECK THE
                                ; UPDATE FLAG TO SEE IF THE T/S
                                ; LST PRESENTLY IN MEMORY REQUIRES
                                ; UPDATING BEFORE WE READ IN THE
                                ; NEXT (OR FIRST) T/S LIST SECTOR.
                                ; IF UPDATING IS REQUIRED, WRITE
                                ; THE PRESENT T/S LIST.
                BCC CKCURTS     ; GO BACK & CHK IF THIS IS CORRECT
                                ; T/S LIST.
                RTS             ; RTN WITH (C)=1 TO SIGNAL THAT WE
                                ; ===             ;RAN OUT OF T/S LISTS WHILE
                                ; READING  OR TO DO GOOD EXIT IF
                                ; RAN OUT OF DATA WHILE VERIFYING
                                ; OR 2 SIGNAL POSSIBLE ERROR WHILE
                                ; APPENDING.

                                ; KNOW DATA SEC SHOULD BE DESCRIBED
                                ; IN PRESENT T/S LIST SO NOW CALC
                                ; OFFSET INTO T/S LIST WHERE DATA
                                ; PAIR SHOULD BE LOCATED.

GETDATPR        SEC             ; CALC OFFSET TO DATA PAIR:
                LDA FILPTSEC    ; SEC OFFSET OF DATA SEC INTO FILE
                SBC RELFIRST    ; MINUS REL INDEX OF 1RST DATA SEC
                                ; DESCRIBED IN PRES T/S LIST.
                ASL A           ; TIMES 2 CAUSE 2 BYTES USED TO
                                ; DESCRIBE A DATA PAIR.
                ADC #12         ; ADD 12 CAUSE 1RST DATA PAIR IS
                TAY             ; ALWAYS LISTED 12 BYTES FROM THE
                                ; START OF THE T/S LIST BUFFER.
                JSR SELTSBUF    ; POINT A4L/H AT THE T/S LIST BUF.
                LDA (A4L),Y     ; GET TRK # OF DATA SEC PAIR.
                BNE RDDATSEC    ; GO READ IN THE DATA SECTOR.

                                ; THE TRK# PART OF THE DATA SECTOR
                                ; PAIR LISTED IN THE T/S LIST WAS
                                ; ZERO.  THEREFORE, THERE ARE NO
                                ; MORE DATA SECTOR PAIRS DESCRIBED
                                ; IN THIS T/S LIST.

                LDA OPCODEFM    ; CHECK TO SEE IF WRITING OR NOT.
                CMP #4          ; OPCODE FOR WRITE.
                BEQ NEWPAIR     ; BRANCH IF WRITING.
                SEC             ; NOT WRITING & RAN OUT OF DATA
                RTS             ; SECTOR PAIRS DESCRIBED IN THE
                                ; ===             ;PRESENT T/S LIST, SO GO XIT WITH
                                ; CARRY SET 2 SIGNAL NO MORE DATA.

                                ; SINCE WRITING & RAN OUT OF DATA
                                ; PAIRS, MUST ADD A NEW DATA PAIR
                                ; TO THE T/S LIST.

NEWPAIR         JSR NWDATKSC    ; ADD NEW DATA SEC PR TO T/S LIST,
                                ; ZERO OUT DATA SEC BUF & SET
                                ; UPDATE FLAG TO SIGNAL THAT BOTH
                                ; T/S LIST SEC & DATA SEC REQUIRE
                                ; UPDATING.
                JMP SETPREV     ; NOTE:  IF YOU FOLLOW THIS JUMP
                                ; ---             ;THRU, YOU MAY REALIZE THAT SOME-
                                ; TIMES WE EVENTUALLY EXIT THE
                                ; PRESENT FUNCTION WITHOUT WRITING
                                ; THE T/S LIST AND DATA SEC BUFS
                                ; BACK TO THE DISK. HOWEVER, AFTER
                                ; THE SUBFUNCTIONS ARE EXITED, THE
                                ; CLOSE FUNCTION EVENTUALLY TESTS
                                ; THE STATUS OF THE UPDATE FLAG
                                ; (UPDATFLG, $B5D5) & THEN WRITES
                                ; THE T/S LIST & DAT SEC BUFS BACK
                                ; TO THE DISK.

                                ; DATA SECTOR PAIR ASSOCIATED WITH
                                ; THE DATA SECTOR WANTED WAS
                                ; CONTAINED IN THE CURRENT T/S LIST,
                                ; SO NOW READ IN THE DATA SECTOR.

RDDATSEC        STA CURDATRK    ; SAVE TRK/SEC VALS OF CURRENT DATA
                INY             ; SECTOR IN THE WORK AREA.
                LDA (A4L),Y     ; SEC# OF CURRENT DATA SEC.
                STA CURDATSC
                JSR READDATA    ; GO READ IN THE DATA SECTOR.

                                ; SAVE SECTOR OFFSET INTO FILE
                                ; ASSOC WITH DATA SEC JUST READ.

SETPREV         LDA FILPTSEC    ; CURRENT SEC OFFSET INTO FILE.
                STA RELPREV     ; OFFSET IN FILE OF LAST DAT READ.
                LDA FILPTSEC+1
                STA RELPREV+1

                                ; EXIT READ NEXT DATA SECTOR ROUTINE.

XITNXDAT        JSR SELDABUF    ; POINT A4L/H AT DATA SEC BUF.
                LDY FILPTBYT    ; (Y)=BYT OFFSET IN2 CUR DATA SEC.
                CLC             ; EXIT CLEANLY.
                RTS


                                ; =================================
                                ; DESIGNATE TRK/SEC VALS FOR NEW
                                ; DATA SECTOR & ADD THE NEW DATA
                                ; SECTOR PAIR TO THE T/S LIST.
                                ; =================================

NWDATKSC        STY SCRNSRCH    ; SAVE OFFSET 2 DAT PR IN T/S LST.
                JSR ASGNTKSC    ; FIND & DESIGNATE AN AVAIL SEC.
                LDY SCRNSRCH    ; RETRIEVE OFFSET TO DATA PAIR.
                INY
                STA (A4L),Y     ; PUT NEW SEC# IN THE T/S LIST AND
                STA CURDATSC    ; WORK AREA.
                DEY
                LDA ASIGNTRK    ; PUT TRK# IN T/S LST & WORK AREA.
                STA (A4L),Y
                STA CURDATRK
                JSR SELDABUF    ; POINT A4L/H AT DATA SEC BUF.
ZOUTDAT         JSR ZCURBUF     ; ZERO OUT DATA SEC BUF.
                LDA #%11000000  ; SET BOTH BITS 6 & 7 IN FLAG TO
                ORA UPDATFLG    ; SIGNAL THAT BOTH DATA & T/S LIST
                STA UPDATFLG    ; SECTORS REQUIRE UPDATING.
                RTS


                                ; =================================
                                ; ADJUST RECORD # OR BYTE OFFSET
                                ; INTO A GIVEN RECORD.
                                ; =================================

                                ; THIS ROUTINE IS USED BOTH WHEN
                                ; READING AND WRITING. THE PATTERN
                                ; OF EXECUTION VARIES WITH THE
                                ; STRUCTURE OF A FILE.  HOWEVER
                                ; SOME FILES ARE TREATED AS IF
                                ; THEY HAVE ONE TYPE OF STRUCTURE
                                ; WHEN THEY ARE BEING READ AND
                                ; ANOTHER TYPE OF STRUCTURE WHEN
                                ; THEY ARE BEING WRITTEN:
                                ; - RANDOM ACCESS TEXT FILES HAVE
                                ; A FIXED RECORD LENGTH ASSIGNED
                                ; BY THE USER.
                                ; - SEQUENTIAL TEXT & APPLESOFT
                                ; FILES HAVE A RECORD LENGTH OF
                                ; ONE.
                                ; - DURING A LOAD OR BLOAD, BINARY
                                ; & APPLESOFT FILES ARE CONSIDERED
                                ; TO BE COMPOSED OF A COLLECTION
                                ; OF ONE-BYTE LONG RECORDS.
                                ; - WHEN SAVING OR BSAVING HOWEVER,
                                ; THESE FILES ARE TREATED AS IF
                                ; THEY CONSIST OF 1 LONG RECORD.

                                ; COPY THE RECORD NUMBER FROM THE
                                ; WRK AREA TO THE FM PARM LIST.

INCREC          LDX RECNMBWA    ; CURRENT RECORD #.
                STX RECNMBFM    ; RECORD # IN PARAMETER LIST.
                LDX RECNMBWA+1
                STX RECNMBFM+1

                                ; COPY CURRENT BYTE OFFSET INTO
                                ; RECORD FROM THE WORK AREA TO
                                ; THE FM PARAMETER LIST.

                LDX BYTOFFWA    ; GET OFFSET IN2 RECORD (WRK AREA)
                LDY BYTOFFWA+1
                STX BYTOFFFM    ; STORE IT IN FM PARAMETER LIST.
                STY BYTOFFFM+1

                                ; INC THE BYTE OFFSET INTO RECORD.
                                ; IF IT EQUALS THE RECORD LENGTH,
                                ; THEN RESET THE OFFSET TO 0 AND
                                ; KICK UP THE RECORD NUMBER.

                INX
                BNE BYTVSREC
                INY
BYTVSREC        CPY RECLENWA+1  ; FIXED VAL VIA OPEN CMD, ELSE
                                ; L-PARM VIA SAVE OR BSAVE CMD
                                ; (FROM WORK AREA).
KIKOFF1         BNE SETBYTOF
                CPX RECLENWA
KIKOFF2         BNE SETBYTOF
                LDX #0          ; OFFSET INTO RECORD WAS SAME AS
                LDY #0          ; RECORD LENGTH SO PREP TO RESET
                                ; OFFSET INTO RECORD TO ZERO.
                INC RECNMBWA
NOKIKOFF        BNE SETBYTOF
                INC RECNMBWA+1

                                ; ON FALL THRU OR ENTRY FROM NOKIKOFF,
                                ; RESET THE OFFSET INTO THE RECORD
                                ; TO ZERO.  ON BRANCHED ENTRY FROM
                                ; KIKOFF1 OR KIKOFF2, INCREMENT THE
                                ; OFFSET INTO THE RECORD.

SETBYTOF        STX BYTOFFWA
                STY BYTOFFWA+1
                RTS


                                ; =================================
                                ; INCREMENT THE BYTE OFFSET INTO
                                ; THE CURRENT SECTOR.  IF AT THE
                                ; END OF THE SECTOR, INCREMENT THE
                                ; OFFSET INTO THE ENTIRE FILE
                                ; INSTEAD.
                                ; =================================

INCFILPT        INC FILPTBYT    ; KICK UP OFFSET INTO THE SECTOR.
                BNE INCPTRTN    ; NOT AT END OF CURRENT SECTOR.

                INC FILPTSEC    ; OFFSET INTO SEC WRAPPED AROUND,
                BNE INCPTRTN    ; SO AT END OF SEC, SO KICK UP THE
                                ; OFFSET INTO THE ENTIRE FILE.
                INC FILPTSEC+1  ; INC HI BYTE IF NECESSARY.
INCPTRTN        RTS


                                ; =================================
                                ; POINT A4L/H AT CUR DEST'N/SOURCE
                                ; MEMORY LOCATION (CURIOBUF) FOR
                                ; READING/WRITING.
                                ; INC DEST'N/SOURCE ADR FOR NEXT
                                ; TIME AROUND.
                                ; =================================

INCIOBUF        LDY CURIOBUF    ; GET ADR OF DEST'N/SOURCE LOC'N
                LDX CURIOBUF+1  ; FROM FM PARM LIST.
                STY A4L         ; POINT A4L/H AT TARGET.
                STX A4H
                INC CURIOBUF    ; KICK UP ADR OF DEST'N/SOURCE LOC
                BNE INCIORTN
                INC CURIOBUF+1
INCIORTN        RTS


                                ; =================================
                                ; REDUCE COUNT OF THE # OF BYTES
                                ; LEFT TO READ OR WRITE.  WHEN THE
                                ; COUNTER = 0, EXIT FILE MANAGER.
                                ; =================================

DECRWLEN        LDY LEN2RDWR    ; LENGTH TO READ OR LENGTH-1 TO
                                ; WRITE (FROM FM PARM LIST).
                BNE DECLENRW    ; MORE BYTES TO READ OR WRITE.
                LDX LEN2RDWR+1  ; LOW BYTE WAS 0, CHK HI BYTE.
                BEQ RWLEN0      ; COUNTER = 0 SO DONE READ/WRITE.
                DEC LEN2RDWR+1
DECLENRW        DEC LEN2RDWR    ; REDUCE COUNTER.
                RTS

RWLEN0          JMP GOODFMXT    ; DONE READ/WRITE, EXIT FM.


                                ; =========================================
                                ; LOCATE OR CREATE A FILE ENTRY IN THE
                                ; DIRECTORY BUFFER.
                                ; MAKE TWO SEARCHES IF NECESSARY:
                                ; - SEARCH1 - TRY TO LOCATE ENTRY WITH THE
                                ; SAME NAME AS THE FILE WANTED.
                                ; - SEARCH2 - COULDN'T LOCATE ENTRY
                                ; CORRESPONDING TO THE FILE
                                ; WANTED SO CREATE A NEW ENTRY
                                ; IN THE 1RST AVAILABLE SPACE
                                ; IN THE DIRECTORY SECTOR IN
                                ; CASE THE CMD CAN CREATE A
                                ; NEW FILE.
                                ; =========================================

GETFNTRY        JSR READVTOC    ; READ IN VTOC SO CAN GET LINK TO
                                ; TRKMAPS & LINK TO 1RST DIR SEC.

                                ; PT A4L/H AT PRIMARY NAME BUF.

                LDA FNAMBUFM    ; GET ADR OF NAME BUF FROM THE
                STA A4L         ; FM PARM LIST & PUT IT IN A4L/H.
                LDA FNAMBUFM+1
                STA A4H


                                ; TRY TO FIND THE DIRECTORY SECTOR
                                ; CONTAINING THE NAME OF THE WANTED
                                ; FILE.  MAKE TWO SEARCHES IF NECESSARY.
                                ; ON THE FIRST SEARCH, TRY TO FIND THE
                                ; WANTED FILE NAME.  IF THAT DOESN'T
                                ; WORK, DO A 2ND SEARCH TO LOCATE THE
                                ; 1RST AVAILABLE SPACE IN A DIRECTORY
                                ; SECTOR WHERE WE CAN STORE A NEW FILE
                                ; DESCRIPTION IN CASE THE CMD CAN CREATE
                                ; A NEW FILE.

                LDA #1          ; INIT SRCH COUNTER (SCRNSRCH), IN
SETSRCH         STA SCRNSRCH    ; FM SCRATCH SPACE FOR 2 SEARCHES
                                ; (1 = SEARCH1, 0 = SEARCH2).
                LDA #0          ; INIT OFFSET OF FILE DESCRIP FROM
                STA SECNXD1R    ; THE VERY 1RST DIRECTORY SEC.
                CLC             ; (C)=0=SIGNAL TO RD 1RST DIR SEC.
GETDIRSC        INC SECNXD1R    ; KICK UP OFFSET FROM 1RST DIR.
                                ; (ON FIRST ENTRY:  $00 ---> $01.)
                JSR RDDIRECT    ; GO READ  DIREC SEC IN2 DIREC BUF
                BCS CHNGSRCH    ; LNK ZEROED OUT, NO MORE DIRECT
                                ; SECTORS, SO GO SWITCH SEARCHES.
                LDX #0
CKDIRTRK        STX CURDIRNX    ; OFFSET OF FILE DESCRIP INTO THE
                                ; CURRRENT DIRECTORY SECTOR.
                LDA FIL1TSTK,X  ; GET TRK# OF 1RST T/S LIST SEC
                                ; FOR A PARTICULAR FILE FROM THE
                                ; FILE DESCRIP ENTRY IN DIR SEC.
                BEQ CHRSRCHA    ; IF TRK#=0, NO MORE FILES IN THIS
                                ; DIRECTORY SECTOR.
                BMI CHRSRCHB    ; SKIP DELETED FILE.  (WHEN A FILE
                                ; IS DELETED, #$FF IS PUT IN BYTE
                                ; WHERE TRK# OF 1RST T/S LIST IS
                                ; USUALLY KEPT.)

                                ; COMPARE NAME FOUND IN THE FILE
                                ; DESCRIPTION ENTRY PORTION OF THE
                                ; DIRECTORY SECTOR WITH NAME WNTD.
                                ; (ON ENTRY, A4L/H POINTS AT THE
                                ; PRIMARY FILE NAME BUFFER.)

                LDY #0          ; INIT INDEX TO NAME BUFFER.
                INX             ; POINT (X) AT 1RST CHAR POS'N IN
                INX             ; NAME FIELD OF DESCRIP ENTRY.
CMPNAMES        INX
                LDA (A4L),Y     ; GET CHAR OF NAME WANTED FROM THE
                                ; PRIMARY FILENAME BUFFER.
                CMP FIL1TSTK,X  ; CHAR OF NAME WANTED VS CHAR IN
                                ; DESCRIPTION ENTRY OF DIREC SEC.
                BNE DONTMTCH    ; CHARS (IE., NAMES) DON'T MATCH.
                INY
                CPY #30         ; DONE ALL CHARS YET (0 TO 29)?
                BNE CMPNAMES    ; CHRS MTCH, BRANCH IF MORE 2 CHK.
                LDX CURDIRNX    ; ALL CHARS MTCHD, SO NAMES MTCHD.
                CLC             ; RTN WITH (X) = INDEX TO FILE
                RTS             ; DESCRIP IN CURRENT DIRECTORY AND
                                ; ===             ;WITH (C)=0 TO SIGNAL THAT THE
                                ; CORRECT FILE DESCRIP WAS FOUND.

                                ; ADVANCE INDEX TO POINT AT THE NEXT
                                ; POTENTIAL FILE DESCRIPTION ENTRY.

DONTMTCH        JSR NXPLUS35    ; NAMES DIDN'T MATCH, SO ADD 35 TO
                                ; INDEX TO POINT IT AT NEXT ENTRY.
                                ; (CHK TO MAKE SURE DON'T INDEX
                                ; RIGHT OFF END OF DIRECTORY SEC.)
                BCC CKDIRTRK    ; MORE POTENTIAL FILE DESCRIPS TO
                                ; CHK IN THIS DIRECTORY SECTOR.
                BCS GETDIRSC    ; GO GET NEXT DIRECTORY SECTOR.
                                ; ---

                                ; IF JUST COMPLETED FIRST SEARCH,
                                ; GO BACK TO DO SECOND SEARCH.

CHRSRCHA        LDY SCRNSRCH    ; (1=SEARCH1, 0=SEARCH2)
                BNE SETSRCH     ; GO SWITCH TO SECOND SEARCH.

                                ; IF FIRST SEARCH, SKIP DELETED FILES.
                                ; IF SECOND SEARCH, FALL THRU TO STORE
                                ; THE (NEW) DESCRIPTION IN THE 1RST
                                ; UNUSED SPACE IN THE DIRECTORY.

CHRSRCHB        LDY SCRNSRCH    ; (1=SEARCH1, 0=SEARCH2)
                BNE DONTMTCH

                                ; COULDN'T LOCATE THE FILE NAME IN THE
                                ; DIRECTORY DESCRIPTION ENTRIES, SO
                                ; BEGIN CREATING A NEW DESCRIPTION IN
                                ; THE FIRST AVAILABLE SPACE IN A
                                ; DIRECTORY (IN CASE CMD CAN LEGALLY
                                ; CREATE A NEW FILE).

NWDESCRP        LDY #0          ; INIT INDEX TO PRIMARY NAME BUF.
                INX             ; SET INDEX TO 1RST CHAR POS'N IN
                INX             ; THE NAME FIELD OF FILE DESCRIP
SETNWNAM        INX             ; ENTRY SPACE N THE DIRECTORY SEC.
                LDA (A4L),Y     ; COPY CHAR FROM PRIMARY NAME BUF
                STA FIL1TSTK,X  ; TO DIREC DESCRIP ENTRY AREA.
                INY
                CPY #30         ; 30 CHARS IN NAME (0 TO 29).
                BNE SETNWNAM    ; BRANCH IF MORE CHARS TO COPY.
                LDX CURDIRNX    ; RTN WITH INDEX TO FILE DESCRIP
                SEC             ; IN CURRENT DIRECTORY SECTOR AND
                RTS             ; WITH (C)=1 TO SIGNAL A NEW ENTRY
                                ; WAS JUST CREATED.


                                ; =====================================
                                ; ADD 35 TO THE OFFSET TO POINT THE
                                ; INDEX AT THE NEXT FILE DESCRIPTION
                                ; ENTRY.  (CHECK TO MAKE SURE THAT WE
                                ; DON'T INDEX RIGHT OFF THE END OF THE
                                ; DIRECTORY SECTOR.)
                                ; =====================================

NXPLUS35        CLC             ; ADD 35 TO THE INDEX.  (EACH FILE
                LDA CURDIRNX    ; DESCRIPTION IS 35 BYTES LONG.)
                ADC #35
                TAX             ; CHK IF MORE SPACE FOR ENTRIES IN
                CPX #245        ; CURRENT DIRECTORY.
                RTS             ; EXIT WITH (C) CONDITIONED:
                                ; (C)=0=MORE SPACE IN DIRECTORY.
                                ; (C)=1=RAN OFF END OF DIRECTORY.


                                ; ====================================
                                ; - IF FIRST SEARCH, SWITCH TO SECOND
                                ; SEARCH.
                                ; - IF SECOND SEARCH, LINK ZEROED OUT
                                ; (BECAUSE THERE ISN'T ENOUGH ROOM
                                ; ON DISK FOR A NEW ENTRY.  THERE4,
                                ; GO EXIT WITH A DISK-FULL-ERROR
                                ; MESSAGE.
                                ; ====================================

CHNGSRCH        LDA #0          ; SET (A) = 0 SO WE CAN RESET
                                ; SCRNSRCH IF WE HAVE 2 GO BACK 2
                                ; DO A SECOND SEARCH.
                LDY SCRNSRCH    ; (1=SEARCH1, 0=SEARCH2.)
                BNE SETSRCH     ; JUST DID FIRST SEARCH, SO NOW GO
                                ; BACK TO START SECOND SEARCH.
                JMP DISKFULL    ; EVEN THE SECOND SEARCH WAS
                                ; UNSUCCESSFUL, SO GO HANDLE A
                                ; DISK-FULL ERROR.


                                ; ========================================
                                ; ASSIGN TRK(S)/SEC(S) FOR THE NEW FILE.
                                ; ========================================

                                ; NOTE:  THIS ROUTINE USUALLY ASSIGNS
                                ; MORE SECTORS THAN ARE NEEDED.  EACH
                                ; TIME A TRK WITH ONE OR MORE FREE SECS
                                ; IS LOCATED, THE ENTIRE TRACK IS
                                ; IS ASSIGNED.  THE UNNEEDED SECS ARE
                                ; LATER RELEASED BY THE CLOSE COMMAND.
                                ;
                                ; NOTE:  DOS DOES NOT SUPPORT THE
                                ; ALLOCATION OF TRK 0 FOR A FILE.
                                ; INSTEAD, TRK 0 IS RESERVED FOR STORING
                                ; PART OF THE DOS IMAGE.  HOWEVER, AS
                                ; SHOWN BELOW, TRK 0 HAS SPECIAL
                                ; SIGNIFICANCE FOR THE FOLLOWING FLAGS:
                                ; ASIGNTRK = TRK# BEING ASSIGNED OR, IF
                                ; ASIGNTRK=0, THEN IT IS A
                                ; SIGNAL TO GET NEXT TRK TO
                                ; ASSIGN FROM THE VTOC.
                                ; TRK0YET = 0 = HAVEN'T ENCOUNTERED TRK0
                                ; YET.
                                ; = 1 = TRK0 HAS BEEN ENCOUNTERED.
                                ; (TRK 0 IS USED AS A REFERENCE POINT.
                                ; THE FIRST TIME TRK0 IS ENCOUNTERED,
                                ; TRK0YET IS SET TO 1.  THE NEXT TIME
                                ; TRK0 IS ENCOUNTERED, THE ENTIRE DISK
                                ; HAS BEEN SEARCHED.)


                                ; HAS A TRK ALREADY BEEN ASSIGNED FOR
                                ; THIS FILE?

ASGNTKSC        LDA ASIGNTRK
                BEQ PRPNWTRK    ; BRANCH IF NO TRK ASSIGNED YET.
                                ; (ALWAYS TAKEN 1RST TIME "JSR" TO
                                ; HERE FRM CREATNEW. HOWEVER, WHEN
                                ; WE LATER JSR TO HERE, ASIGNTRK
                                ; EQUALS THE TRK # FOR T/S LIST.)

                                ; A TRK WAS ALREADY ASSIGNED, SO NOW SEE
                                ; IF THERE ARE ANY FREE SECS WHICH WE
                                ; CAN USE ON THIS TRK.

ANYAVAIL        DEC ASIGNSEC    ; NEXT SECTOR BE ASSIGNED.
                BMI ASGNWTRK    ; IF DEC FROM $00 ==> #$FF, THEN
                                ; NO MORE FREE SECS ON THIS TRK.

                                ; CHECK IF ANY SECS ARE FREE.

                CLC             ; ROLL BITS IN THE 4-BYTES OF
                LDX #4          ; ASIGNMAP AS AS UNIT - ROLL THEM
                                ; BACK TO STANDARD POSITION.
ADJSTMAP        ROL ASIGNMAP-1,X
                                ; IF C=1, SEC ASSOC WITH ROLLED
                DEX             ; BIT POS'N IS FREE TO BE ASSIGNED
                BNE ADJSTMAP    ; TO A NEW FILE.
                BCC ANYAVAIL    ; SEC NOT FREE - GO GET NEXT ONE.

                                ; FOUND A FREE SECTOR.

                INC FILENSEC    ; SEC WAS FREE, SO KICK FILE SIZE
                BNE XWITHFRE    ; UP BY 1 & RTN WITH FREE SEC# IN
                INC FILENSEC+1  ; (A) SO IT CAN LATER BE USED FOR
XWITHFRE        LDA ASIGNSEC    ; THE T/S LIST SECTOR.
                RTS             ; (ACTUALLY ONLY GOOD EXIT AVAIL.)
                                ; ===

                                ; PREPARE TO ASSIGN A NEW TRK (CAUSE
                                ; ALL SECS WERE ASSIGNED ON THE LAST TRK.)

ASGNWTRK        LDA #0          ; SET SIGNAL TO ASSIGN NEW TRK.
                STA ASIGNTRK

                                ; CONTINUE PREPS TO ASSIGN NEW TRK
                                ; OR BEGIN PREPARATIONS TO ASSIGN
                                ; THE FIRST TRK.

PRPNWTRK        LDA #0
                STA TRK0YET     ; SIGNAL NOT ALL TRKS CHECKED YET.
                JSR READVTOC    ; READ IN THE VTOC TO FIND NEXT
                                ; TRK TO USE.

                                ; FIND & REASSIGN FREE SECS FOR THE
                                ; NEXT TRK.  CALC NEXT TRK TO ASIGN.

GETNWTRK        CLC
                LDA NXTRKUSE    ; GET NEXT TRK# TO ASSIGN.
                ADC DRECTION    ; DIRECTION (+1/-1) OF ASSIGNMENT.
                BEQ CKIFFULL    ; IF 0, GO SEE IF CHKD ALL TRKS.

                                ; IS THE TRACK NUMBER LEGAL?

                CMP TKPERDSK    ; # OF TRKS ON DISK (FROM VTOC).
                BCC CHK4FREE    ; BRANCH IF TRK # IS VALID.

                                ; TRK# TOO LARGE, SO REVERSE DIRECT'N.

                LDA #$FF        ; (A) = -1.
                BNE SRCH4TRK    ; ALWAYS.

                                ; AT TRK0, SEE IF CHKD ALL TRKS.
                                ; IF AT TRK0 FOR 1RST TIME, SET
                                ; FLAG.  IF 2ND TIME AT TRK0, GO
                                ; ISSUE DISK-FULL-ERROR MESSAGE
                                ; (BECAUSE WE SEARCHED ALL TRKS &
                                ; DIDN'T FIND ANY FREE SECTORS).

CKIFFULL        LDA TRK0YET
                BNE TODSKFUL    ; 2ND TIME = DISK FULL.

                                ; START THE SECOND SEARCH.

                LDA #1          ; SET FLAG TO INDICATE THAT THE
                STA TRK0YET     ; PENDING SEARCH WILL BE 2ND ONE.

                                ; START SEARCH AT CATALOG
                                ; TRK PLUS OR MINUS ONE.

SRCH4TRK        STA DRECTION    ; SET THE SEARCH DIRECTION.
                CLC             ; BEGIN THE SEARCH ONE TRACK AWAY
                ADC #$11        ; FROM THE CATALOG TRK.

                                ; CHECK TRK'S TRKMAP FOR FREE SECS.

CHK4FREE        STA NXTRKUSE
                STA ASIGNTRK
                TAY             ; IRRELEVANT.
                ASL A           ; TRK*4 CAUSE 4BYTES/TRK N TRKMAP.
                ASL A
                TAY             ; INDEX FROM LAST BYTE OF FRESECMAP.
                LDX #4          ; INDEX TO THE ASIGNMAP.
                CLC             ; (C)=0, ASSUME NO FREE SEC AVAIL.
CPYTKMAP        LDA FRESECMAP+3,Y ; COPY BYTE FROM TRKMAP TO THE
                STA ASIGNMAP-1,X
                                ; ASSIGNMENT MAP.
                BEQ NXMAPBYT    ; 0 = SEC USED.

                                ; FOUND A FREE SECTOR.

                SEC             ; (C) = 1 = FREE SECTOR FOUND.
                LDA #0          ; PUT 0 IN TRKMAP 2 REASSIGN ALL 8
                STA FRESECMAP+3,Y ; SECS REPRESENTED BY THIS BYTE.
                                ; (REMEMBER ONLY 2 BYTES OF TRKMAP
                                ; ACTUALLY REPRESENT SECS.  THE
                                ; OTHER 2 BYTES ARE DUDS.)
NXMAPBYT        DEY             ; REDUCE INDICES TO MAPS.
                DEX
                BNE CPYTKMAP    ; NOT DONE TRANSFERRING ALL BYTES
                                ; FROM TRKMAP TO ASIGNMAP YET.

                                ; CHECK IF FOUND A FREE SECTOR.

                BCC GETNWTRK    ; IF (C)=0,THEN NO FREE SECS FOUND
                                ; YET SO GO BACK TO GET A NEW TRK.
                JSR WRITVTOC    ; UPDATE THE VTOC ON THE DISK.
                LDA SECPERTK    ; RESET ASIGNSEC WITH # SECS/TRK.
                STA ASIGNSEC    ; (IE 1 GREATER THAN HIGHEST SEC#.)
                BNE ANYAVAIL    ; ALWAYS.


                                ; =================================
                                ; GO ISSUE DISK-FULL-ERROR MSG.
                                ; =================================

TODSKFUL        JMP DISKFULL    ; GO HANDLE ERROR.
I
                                ; =====================================
                                ; FREE UP SECTORS THAT WERE ASSIGNED
                                ; BUT NOT USED.
                                ; =====================================

                                ; WHENEVER, SOMETHING IS WRITTEN TO
                                ; THE DISK, THE WHOLE TRK IS ALLOCATED
                                ; IN THE VTOC WHETHER IT IS NEEDED OR
                                ; NOT.  THERE4, ONCE WE ARE DONE
                                ; WRITING, GO BACK & FREE UP THE
                                ; UNNEEDED SECTORS.

FIXMAP          LDA ASIGNTRK    ; HAS A TRK ALREADY BEEN ASSIGNED?
                BNE FREEXTRA    ; YES - GO FREE UP EXTRA SECS.
                RTS             ; NO - GO EXIT.

FREEXTRA        PHA             ; SAVE TRK # ON STK.
                JSR READVTOC    ; READ IN THE VTOC.
                LDY ASIGNSEC    ; SET (Y) = # OF NEXT SECTOR WHICH
                                ; COULD HAVE BEEN WRITTEN.
                PLA             ; GET ASSIGNMENT TRK# BAK FRM STK.
                CLC             ; DON'T WANT 2 FREE LAST SEC USED,
                                ; SO CLR (C) HERE SO DON'T FREE IT
                                ; UP WHEN BEGIN ROTATING MAPS IN
                                ; SUB2FREE ROUTINE.
                JSR SUB2FREE    ; ADJUST ASIGNMAP TO FREE UP SECS
                                ; BY SETTING BIT CORRESPONDING TO
                                ; THE SEC #.  NEXT, MERGE ASIGNMAP
                                ; WITH THE APPROPRIATE TRK MAP IN
                                ; THE VTOC.
                LDA #0          ; NO MORE DEALLOCATIONS NEEDED.
                STA ASIGNTRK
                JMP WRITVTOC    ; WRITE CORRECTED VTOC BACK 2 DSK.


                                ; ================================
                                ; SUBROUTINE TO FREE UP SECS THAT
                                ; WERE DELETED OR PREMATURELY
                                ; ASSIGNED BUT NOT USED.
                                ; ================================

                                ; THIS TRICKY LITTLE ROUTINE IS
                                ; EASY TO UNDERSTAND ONCE YOU
                                ; REALIZE THAT:
                                ; 1) UNLIKE THE VTOC, ASIGNMAP
                                ; DOES NOT CONTAIN UNNECESSARILY
                                ; ASSIGNED SECTORS.
                                ; 2) IF THE DISK WAS JUST WRITTEN
                                ; TO, ASIGNMAP MAP DOES NOT HOUSE
                                ; ANY NEWLY ASSIGNED SECS (EVEN
                                ; IF THOSE SECS ARE NECESSARY OR
                                ; NOT).
                                ; 3) SECS ARE NORMALLY ASSIGNED
                                ; IN DESCENDING ORDER.
                                ; 4) # OF ROR'S = # OF SECS THAT
                                ; NEED TO BE ASSIGNED.
                                ;
                                ; FOR EX:  IF LAST TRK HAD NEVER
                                ; BEEN ASSIGNED & ONLY SECS $0F
                                ; AND $0E WERE NEEDED, THEN ON
                                ; ENTRY TO SUB2FREE, THE 1RST 2
                                ; BYTES WOULD APPEAR AS FOLLOWS:
                                ; SEC NMB: CBA98765 43210FED
                                ; BIT VAL: 11111111 11111...
                                ; AFTER THE 1RST ROR, THE STATUS
                                ; OF SEC $0D IS DETERMINED BY THE
                                ; ENTRY STATUS OF THE CARRY (C):
                                ; SEC NMB: DCBA9876 543210FE
                                ; BIT VAL: C1111111 111111..
                                ; ON NEXT ROR, THE "CPY SECPERTK"
                                ; INSTRUC CONDITIONS (C) TO CLR
                                ; FOR SEC $0E:
                                ; SEC NMB: EDCBA987 6543210F
                                ; BIT VAL: 0C111111 1111111.
                                ; ON NEXT ROR, THE "CPY SECPERTK"
                                ; INSTRUC CONDITIONS (C) TO CLR
                                ; FOR SEC $0F:
                                ; SEC NMB: FEDCBA98 76543210
                                ; BIT VAL: 00C11111 11111111
                                ; WHEN ASIGNMAP IS MERGED WITH THE
                                ; CORRESPONDING TRKMAP IN THE VTOC,
                                ; THE SECS THAT WERE UNNECESSARILY
                                ; ASSIGNED IN THE VTOC ARE FREED.
                                ; (NOTE:  WHEN USED IN THE DELETE
                                ; FUNCTION, SUB2FREE IS REPEATEDLY
                                ; CALLED BY FREESEC TO FREE ONE
                                ; SECTOR AT A TIME.)

SUB2FREE        LDX #$FC        ; SET INDEX TO SHIFT 4 BYTES AS A
                                ; UNIT (#$FC --> #$FF).
STNDARD         ROR ASIGNMAP-$FC,X
                                ; 4 BYTES PER MAP FOR @ TRK.
                INX
                BNE STNDARD
                INY             ; WHEN (Y) = 16, ASIGNMAP IS BACK
                                ; IN STANDARD POS'N.
                CPY SECPERTK    ; CONDITION (C) FOR NEXT SHIFT.
                BNE SUB2FREE
                ASL A           ; TRK*4 TO INDEX TRKMAP.
                ASL A
                TAY
                BEQ SUB2RTN     ; TRK VAL OF 0 NOT ALLOWED.

                                ; ASIGNMAP NOW REFLECTS TRUE SEC
                                ; ASSIGNMENT & IS IN STANDARD
                                ; POSITION.  THERE4, MERGE IT
                                ; WITH THE APPROPRIATE TRKMAP IN
                                ; THE VTOC TO FREE UP EXTRA SECS.

                LDX #4
MERGMAPS        LDA ASIGNMAP-1,X
                ORA FRESECMAP+3,Y ; DO THE MERGE.
                STA FRESECMAP+3,Y
                DEY             ; REDUCE INDICES.
                DEX
                BNE MERGMAPS
SUB2RTN         RTS


                                ; ==========================================
                                ; CALCULATE THE EXACT POSITION OF THE
                                ; 3-BYTE FILE POINTER:
                                ; ==========================================

                                ; - FILPTSEC = SECTOR OFFSET (IN LOW/HI
                                ; FORMAT) INTO THE ENTIRE FILE (2 BYTES).
                                ; - FILPTBYT = BYTE OFFSET INTO THE CURRENT
                                ; SECTOR (1 BYTE).
                                ;
                                ; ALL 3 BYTES BYTES DEFINE THE EXACT POS'N
                                ; OF THE FILE POINTER VIA THE FOLLOWING
                                ; FORMULA:
                                ; (REC# * REC LENGTH) + BYTE OFFSET
                                ; INTO THE RECORD.
                                ; WHERE:
                                ; RECNMBFM=RECORD# FROM R-PARAMETER (SET
                                ; BY USER WHEN USING RANDOM
                                ; ACCESS FILES OR SIMPLY
                                ; INCREMENTED WHEN USING OTHER
                                ; FILE TYPES).
                                ; RECLENWA=RECORD LENGTH PARSED FROM
                                ; L-PARAMETER & ASSIGNED WITH
                                ; THE OPEN CMD (ELSE DEFAULTED
                                ; TO A SIZE OF 1).
                                ; BYTOFFFM=OFFSET INTO THE CURRENT RECORD
                                ; (SET BY USER WHEN USING THE
                                ; OPEN CMD OR OCCASIONALLY USED
                                ; WITH SEQUENTIAL FILES AS A
                                ; B-PARAMETER).
                                ; NOTE THAT YOU CAN ACTUALLY DIRECTLY
                                ; ACCESS ANY BYTE IN ANY FILE BY
                                ; BYPASSING THE COMMAND INTERPRETER AND
                                ; SETTING THE L-, B- AND R-PARAMETERS
                                ; HOWEVER YOU WANT.

CALCFPTR        LDA RECNMBFM    ; PUT RECORD # IN MULTIPLIER AND
                STA FILPTBYT    ; ALSO SAVE IT IN THE WORK AREA.
                STA RECNMBWA
                LDA RECNMBFM+1
                STA FILPTSEC
                STA RECNMBWA+1
                LDA #0          ; ZERO OUT HI ORDER BYTE OF SEC
                STA FILPTSEC+1  ; OFFSET INTO THE ENTIRE FILE.

                                ; CALCULATE:  REC # * REC LENGTH.
                                ; THIS ROUTINE IS JUST A BASIC
                                ; MULTPLICATION OF TWO 16-BIT
                                ; NUMBERS.  IT MAY AT FIRST SEEM
                                ; CONFUSING BECAUSE FILPTSEC &
                                ; FILPTBYT ARE USED BOTH FOR HOLDING
                                ; THE MULTIPLIER (RECORD #) AND PART
                                ; OF THE PRODUCT RESULT.  HOWEVER,
                                ; THE BITS OF THE PRODUCTS DON'T GET
                                ; MIXED UP WITH THE BITS OF THE
                                ; MULTIPLIER BECAUSE ROLLING IN A
                                ; PRODUCT BIT ALSO ROLLS OUT THE
                                ; LAST-USED MULTIPLIER BIT (IE.,
                                ; THERE IS NO BIT OVERLAP).

                LDY #16         ; 16 BITS / ONE 2-BYTE NUMBER.
NMBXLEN         TAX             ; SAVE PART OF RUNNING PRODUCT.
                                ; (ON 1RST ENTRY, SET (X) = 0.)
                LDA FILPTBYT    ; GET (A) = MULTIPLIER.
                LSR A           ; PUT MULTIPLIER BIT IN CARRY.
                BCS NMBXLEN1    ; IF (C)=1, GO ADD MULTIPLICAND.
                TXA             ; (A) = PART OF RUNNING PRODUCT.
                BCC NMBXLEN2    ; ALWAYS, NO USE +ING MULTIPLICAND
                                ; CAUSE BIT IN MULTIPLIER IS A 0
                                ; SO JUST GO SHIFT RUNNING PRODUCT
NMBXLEN1        CLC             ; + MULTIPLICAND 2 RUNNING VERSION
                LDA FILPTSEC+1  ; OF SHIFTED PRODUCT.
                ADC RECLENWA
                STA FILPTSEC+1
                TXA             ; SET (A)=LOW BYT OF RUNNING PROD.
                ADC RECLENWA+1
NMBXLEN2        ROR A           ; SHIFT (AS A UNIT) RUNNING RESULT
                ROR FILPTSEC+1  ; 1 BIT RIGHT 4 NEXT TIME AROUND.
                ROR FILPTSEC    ; SHIFT LOWER 2 BYTES OF RUNNING
                ROR FILPTBYT    ; PRODUCT & AT SAME TIME THROW OUT
                                ; LAST-USED MULTIPLIER BIT.
                DEY             ; REDUCE BIT COUNTER.
                BNE NMBXLEN     ; TAKE IF NOT USED ALL 16 BITS YET

                                ; COPY BYTE OFFSET INTO RECORD FROM
                                ; THE FM PARAMETER LIST TO THE WORK
                                ; AREA.

                IF DOS33_1986 || DOS33_1983
                CLC
                ENDIF

                LDA BYTOFFFM
                STA BYTOFFWA

                                ; CALCULATE THE LOWEST ORDER BYTE OF
                                ; THE FILE POINTER:
                                ; BYTOFFWA = OFFSET INTO CURRENT RECORD.
                                ; = BYTE OFFSET INTO RECORD
                                ; + (RECORD LENGTH * RECORD #).

                ADC FILPTBYT
                STA FILPTBYT
                LDA BYTOFFFM+1
                STA BYTOFFWA+1
                ADC FILPTSEC
                STA FILPTSEC

                IF DOS33_1986 || DOS33_1983
                BCC CALCRTS
                INC FILPTSEC+1
                ELSE
                IF DOS33_1980 || DOS31 || DOS32
                LDA #0
                ADC FILPTSEC+1
                STA FILPTSEC+1
                ENDIF
                ENDIF

CALCRTS         RTS

                IF DOS33_1986 || DOS33_1983
                DS 2
                ENDIF

                                ; =================================
                                ; EXIT FM WITH OR WITHOUT ERRS.
                                ; =================================

LNGNOTAV        LDA #1
                BNE BADFMXIT    ; ALWAYS.
RNGERROP        LDA #2
                BNE BADFMXIT    ; ALWAYS.
RNGERRSB        LDA #3
                BNE BADFMXIT    ; ALWAYS.
WRITPROT        LDA #4
                BNE BADFMXIT    ; ALWAYS.
ENDOFDAT        LDA #5
                BNE BADFMXIT    ; ALWAYS.
FILENOT         LDA #6
                BNE BADFMXIT    ; ALWAYS.
DISKFULL
                IF DOS31
                LDA #9
                BNE BADFMXIT
                ELSE
                JMP FULLPTCH
                NOP
                ENDIF

FILELOKD        LDA #10
                BNE BADFMXIT    ; ALWAYS.

GOODFMXT        LDA RTNCODFM
                CLC             ; (C)=0 TO SIGNAL GOOD OPERATION.
                BCC FMEXIT

BADFMXIT        SEC             ; (C) = 1 TO SIGNAL UNSUCCESSFUL.

                                ; COMMON FM EXIT ROUTINE.
                                ; NOTE THAT ROUTINE IS EXITED BY
                                ; RESETTING THE STACK POINTER.
                                ; USUALLY RETURNS TO CALLER OF THE
                                ; FUNCTION (IE. NORMALLY RETURNS TO
                                ; AFTRFUNC, $A6AB) IN THE FMDRIVER
                                ; ROUTINE ($A6A8).)  HOWEVER, THERE
                                ; IS ONE EXCEPTION.  THE APPEND CMD
                                ; HNDLR (CMDAPPND, $A298) MAY CALL
                                ; THIS ROUTINE SEVERAL TIMES.  MOST
                                ; OF THE TIME, EXECUTION RTNS TO
                                ; AFTRFUNC.  HOWEVER, THE LAST TIME
                                ; FMEXIT IS CALLED, THE CONTENTS OF
                                ; STKSAV ($B39B) ARE ALTERED BEFORE
                                ; FMEXIT IS ENTERED.  THIS FORCES
                                ; AN EXIT TO CALLER OF APPEND CMD
                                ; HNDLR (RATHER THAN TO CALLER OF
                                ; FUNCTION HNDLR).  IN THIS LATER
                                ; INSTANCE, EXECUTION ACTUALLY RTNS
                                ; TO AFTRCMD ($A17D) LOCATED IN THE
                                ; COMMAND PARSING & PROCESSING ROUTINES.


FMEXIT          PHP
                STA RTNCODFM    ; STORE RTN CODE IN FM PARM LIST.
                IF !DOS31
                LDA #0          ; AVOID THAT INFAMOUS $48 BUG.
                STA STATUS
                ENDIF
                JSR CPYFMWA     ; COPY WORK AREA TO WORK BUFFER.
                PLP             ; RETRIEVE STATUS OF SUCCESS OF
                                ; OPERATION BACK OFF STK.
                LDX STKSAV      ; ADJUST STK POINTER TO FORCE EXIT
                TXS             ; TO CALLER EVEN IF SEVERAL
                RTS             ; SUBRT'NS DEEPER THAN ORIG ENTRY.


                                ; =================================
                                ; FILE MANAGER SCRATCH SPACE.
                                ; ($B397 - $B3A3)
                                ; =================================

CURDIRTK        DS 1            ; TRK# OF CURRENT DIRECTORY SEC.
CURDIRSC        DS 1            ; SEC# OF CURRENT DIRECTORY SEC.
WABUFADR        DB $00,$00      ; UNUSED ($B399-$B39A).
STKSAV          DS 1            ; SECOND STACK POINTER SAVE AREA.
                                ; USED TO RESET THE STACK TO FORCE
                                ; EXECUTION TO RTN TO A DESIRED
                                ; ROUTINE.  (NORMALLY RETURNS TO
                                ; AFTRFUNC ($A6AB) AFTR @ FUNCTION
                                ; IS CALLED. HOWEVER, ALSO USED BY
                                ; THE APPEND CMD 2 FORCE EXECUTION
                                ; TO RTN TO AFTRCMD ($A17D).)
                                ; P.S.  DON'T CONFUSE STKSAV WITH
                                ; THE 1RST STACK POINTER SAVE AREA
                                ; (STKSAVED, $AA59).
CURDIRNX        DS 1            ; BYTE OFFSET OF FILE DESCRIPTION
                                ; ENTRY INTO CURRENT DIREC SEC.
SCRNSRCH        DS 1            ; - CATALOG SCRN LINE COUNTER.
                                ; - DESCENDING CNTR 4 # OF SRCHS
                                ; DONE 2 LOCATE A MATCHING NAME
                                ; OR EMPTY SPACE FOR A NEW FILE
                                ; DESCRIP ENTRY IN DIRECTORY SEC
                                ; (SEARCH1 = 1, SEARCH2 = 0).
                                ; - OFFSET OF DAT PR FROM START OF
                                ; A GIVEN T/S LIST.
TRK0YET         DS 2            ; ASSIGNMENT FLAG = SIGNAL IF TRK0
                                ; ENCOUNTERED YET (ONLY 1RST BYTE
                                ; USED):
                                ; $00=TRK0 NOT ENCOUNTERED YET.
                                ; $01 = TRK0 ENCOUNTERED.
                                ; (USED TO SEE IF ENTIRE DISK HAS
                                ; BEEN SCANNED WHEN LOOKING 4 FREE
                                ; SECS TO ASSIGN.)
LOKUNMSK        = TRK0YET       ; LOCK/UNLOCK MASK ($80/$00).
FRETKMSK
                IF DOS31 || DOS32
                DB %00000000,%00000000,%11111000,%11111111
                ELSE
                DB %00000000,%00000000,%11111111,%11111111
                ENDIF
                                ; 4-BYTE MASK USED BY INIT FUNC'N
                                ; TO FREE AN ENTIRE TRACK.


                                ; =================================
                                ; CONVERSION TABLE FOR PRVOLNMB.
                                ; ($B3A4 - $B3A6)
                                ; =================================

BASETEN         DB 1,10,100     ; 10^0=1, 10^1=10, 10^2=100.


                                ; =================================
                                ; CHARACTER CODE FILE TYPE SYMBOLS
                                ; USED BY THE CATALOG ROUTINE.
                                ; ($B3A7 - $B3AE)
                                ; =================================

                CMAP     " ",160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
                CMAP     "@",192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
                CMAP     "`",224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
                IF DOS31
FTYPETBL        DB "TBAI"       ; TEXT, BINARY, APPLESOFT, INTEGER
                ELSE
FTYPETBL        DB "TIABSRAB"   ; TEXT, INTEGER, APPLESOFT, BINARY
                ENDIF
                CMAP
                                ; S-TYPE, R(ELOCATABLE)-TYPE,
                                ; A-TYPE, B-TYPE.  THESE CODES ARE
                                ; FREQUENTLY CHANGED BY HACKERS.)


                                ; =================================
                                ; DISK VOLUME SPELLED BACKWARDS.
                                ; ($B3AF - $B3BA)
                                ; =================================

                CMAP     " ",160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
                CMAP     "@",192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
                CMAP     "`",224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
DSKVOLUM        DB " EMULOV KSID"
                                ; THESE CHRS ARE OFTEN CHANGED
                CMAP
                                ; TO PERSONALIZE A CATALOG.






                                ; =================================
                                ; VOLUME TABLE OF CONTENTS (VTOC)
                                ; BUFFER ($B3BB - $B4BA).
                                ; =================================

VTOCBUFF        DS 1            ; UNUSED ($B3BB).
                                ; REFERENCE FOR START OF TABLE.
FIRDIRTK        DS 1            ; TRK# OF 1RST DIRECTORY SECTOR.
FIRDIRSC        DS 1            ; SEC# OF 1RST DIRECTORY SECTOR.
VERSION                         ; DOS VERSION RELEASE NUMBER.
                IF DOS31
                DB 1
                ELSE
                IF DOS32
                DB 2
                ELSE
                DB 3
                ENDIF
                ENDIF
                DS 2            ; UNUSED ($B3BF-$B3C0).
VOLUSED         DS 1            ; DISK VOL# (NORMALLY, $FE).
                DS 32           ; UNUSED ($B3C2-$B3E1).
MXIN1TSL        DB $7A          ; MAX # OF SECS THAT CAN BE LISTED
                                ; IN A T/S LIST SEC ($7A, #122).
                DS 8            ; UNUSED ($B3E3-$B3EA).
NXTRKUSE        DS 1            ; NEXT TRACK TO ASSIGN.
DRECTION        DS 1            ; TRK ASGNMENT DIRECT'N (+1 OR -1)
                DS 2            ; UNUSED ($B3ED-$B3EE).
TKPERDSK        DB $23          ; TRKS/DISK (#35).
                                ; AFTER DRIVE ADJUSTMENT, VALUE IN
                                ; TKPERDSK CAN BE ALTERED 2 ENABLE
                                ; THE USE OF AN EXTRA TRK ON DISK.
SECPERTK
                IF DOS31 || DOS32
                DB $0D          ; SECS/TRK ($0D, 13, $00 --> $0C)
                ELSE
                DB $10          ; SECS/TRK ($10, 16, $00 --> $0F)
                ENDIF

BYTPERSC        DW $100         ; BYTES/SECTOR ($0100, #256).


                                ; ------------------------------------
                                ; TRACK/SECTOR MAPS IN VTOC.
                                ; ($B3F3 - $B47E)
                                ; ------------------------------------

                                ; MAPS OF SECTOR USAGE ON EACH TRK.
                                ; EACH TRK IS REPRESENTED BY FOUR
                                ; BYTES.  THE BITS IN THESE BYTES
                                ; DEFINE THE SECTOR USAGE BY THE
                                ; FOLLOWING CONVENTION:
                                ; SET BIT = FREE SECTOR.
                                ; CLEAR BIT = USED SECTOR.
                                ; 1ST BYTE:  FEDC BA98
                                ; 2ND BYTE:  7654 3210
                                ; (THE 3RD & 4TH BYTES ASSOCIATED
                                ; WITH EACH TRACK ARE NOT USED.)

FRESECMAP       DS $23*4

                DS 60           ; UNUSED ($B47F-$B4BA).

                                ; END VTOC
                                ; =================================






                                ; =================================
                                ; DIRECTORY SECTOR BUFFER.
                                ; ($B4BB - $B5BA)
                                ; =================================

DIRECBUF        DB $00          ; UNUSED-REFERENCE 4 START OF BUF.
DIRLNKTK        DS 1            ; TRK OF NEXT DIRECTORY SECTOR.
DIRLNKSC        DS 1            ; SECTOR OF NEXT DIRECTORY SECTOR.
                DS 8            ; UNUSED ($B4BC-$B4C5).


                                ; ---------------------------------
                                ; FILE DESCRIPTION ENTRIES.
                                ; ($B4C6 - $B5BA)
                                ; ---------------------------------

FIL1TSTK        DS 1            ; FILE1: T/S LIST TRK ($B4C6)
FIL1TSSC        DS 1            ; T/S LIST SEC ($B4C7)
FIL1TYPE        DS 1            ; FILE TYPE ($B4C8)
FIL1NAME        DS 30           ; NAME ($B4C9-$B4E6)
FIL1SIZE        DS 2            ; SIZE ($B4E7-$B4E8)

FIL2TSTK        DS 1            ; FILE2: T/S LIST TRK ($B4E9)
FIL2TSSC        DS 1            ; T/S LIST SEC ($B4EA)
FIL2TYPE        DS 1            ; TYPE ($B4EB)
FIL2NAME        DS 30           ; NAME ($B4EC-$B509)
FIL2SIZE        DS 2            ; SIZE ($B50A-$B50B)

FIL3TSTK        DS 1            ; FILE3: T/S LIST TRK ($B50C)
FIL3TSSC        DS 1            ; T/S LIST SEC '$B50D)
FIL3TYPE        DS 1            ; TYPE ($B50E)
FIL3NAME        DS 30           ; NAME ($B50F-$B52C)
FIL3SIZE        DS 2            ; SIZE ($B52D-$B52E)

FIL4TSTK        DS 1            ; FILE4: T/S LIST TRK ($B52F)
FIL4TSSC        DS 1            ; T/S LIST SEC ($B530)
FIL4TYPE        DS 1            ; TYPE ($B531)
FIL4NAME        DS 30           ; NAME ($B532-$B54F)
FIL4SIZE        DS 2            ; SIZE ($B550-$B551)

FIL5TSTK        DS 1            ; FILE5: T/S LIST TRK ($B552)
FIL5TSSC        DS 1            ; T/S LIST SEC ($B553)
FIL5TYPE        DS 1            ; TYPE ($B554)
FIL5NAME        DS 30           ; NAME ($B555-$B572)
FIL5SIZE        DS 2            ; SIZE ($B573-$B574)

FIL6TSTK        DS 1            ; FILE6: T/S LIST TRK ($B575)
FIL6TSSC        DS 1            ; T/S LIST SEC ($B576)
FIL6TYPE        DS 1            ; TYPE ($B577)
FIL6NAME        DS 30           ; NAME ($B578-$B595)
FIL6SIZE        DS 2            ; SIZE ($B596-$B597)

FIL7TSTK        DS 1            ; FILE7: T/S LIST TRK ($B598)
FIL7TSSC        DS 1            ; T/S LIST SEC ($B599)
FIL7TYPE        DS 1            ; TYPE ($B59A)
FIL7NAME        DS 30           ; NAME ($B59B-$B5B8)
FIL7SIZE        DS 2            ; SIZE ($B5B9-$B5BA)


                                ; =================================
                                ; FILE MANAGER PARAMETER LIST.
                                ; ($B5BB - $B5D0)
                                ; =================================

OPCODEFM        DS 1            ; FM OPERATION CODE.
SUBCODFM        DS 1            ; FM OPERATION SUBCODE.
RECNMBFM        DS 2            ; FM PARM LST VERSION OF RECORD #.
                                ; (USUALLY 1 LESS THAN RECNMBWA.)
                                ; (SEE DESCRIPTION OF THE RECORD
                                ; NUMBER GIVEN IN THE WORK AREA
                                ; LISTED BELOW.)
BYTOFFFM        DS 2            ; BYTE OFFSET INTO RECORD.
LEN2RDWR        DS 2            ; LENGTH TO READ OR LENGTH-1
                                ; TO WRITE.  (INIT VAL & COUNTER).
                                ; ALSO USED AS A TEMPORARY BUF TO
                                ; TRANSFER ADDR & LENGTH BYTES TO
                                ; ONEIOBUF BUF WHEN USING THE
                                ; WRITE-ONE-BYTE AND READ-ONE-BYTE
                                ; SUBFUNCTIONS.
CURIOBUF        DS 2            ; ADDR OF CURRENT I/O BUFFER.
RTNCODFM        DS 1            ; RETURN CODE.  (CONTRARY TO WHAT
                                ; SOME ARTICLES SUGGEST, THE VALUE
                                ; IN THIS BYTE IS ONLY RELEVANT IF
                                ; AN ERROR OCCURS.)
                DS 1            ; UNUSED ($B5C6).
WRKBUFFM        DS 2            ; PTS TO WORK BUF (IN DOS CHAIN).
TSBUFFM         DS 2            ; PTS TO T/S LIST SEC BUF (CHAIN).
DATBUFFM        DS 2            ; PTS TO DATA SECTOR BUF (CHAIN).
NXTNAME         DS 2            ; PTS TO NEXT DOS NAME BUFFER IN
                                ; CHAIN. (SET UP, BUT NOT USED.)
                DS 2            ; UNUSED ($B5CF-$B5D0).


FMPRMLST        = OPCODEFM      ; START OF FM PARAMETER LIST.

FIRDOSPG        = OPCODEFM      ; CONTAINS 1RST PAGE# OF DOS WHEN
                                ; WRITING DOS IMAGE DURING INIT.

RECLENFM        = RECNMBFM      ; FM PARM LIST VERSION OF THE
                                ; RECORD LENGTH.  (SEE DESCRIPTION
                                ; OF RECORD LENGTH DESCRIBED IN
                                ; THE WORK AREA LISTING BELOW.)
RENAMBUF        = RECLENFM      ; PTS 2 BUFFER CONTAINING NEW FILE
                                ; NAME.  (USED IN RENAME CMD.)
VOLFM           = BYTOFFFM      ; VOLUME# WANTED.
DRVFM           = BYTOFFFM+1    ; DRIVE# WANTED.

SLOTFM          = LEN2RDWR      ; SLOT NUMBER.
FILTYPFM        = LEN2RDWR+1    ; FILE TYPE CODE (INCLUDING THE
                                ; LOCKED/UNLOCKED STATUS).
FNAMBUFM        = CURIOBUF      ; FILE NAME ADDRESS.
ONEIOBUF        = CURIOBUF      ; A ONE-BYTE I/O BUFFER.


                                ; =================================
                                ; FILE MANAGER WORK AREA.
                                ; ($B5D1 - $B5FF)
                                ; (DON'T CONFUSE WITH THE VARIOUS
                                ; WORK BUFFERS CONTAINED IN THE
                                ; CHAIN OF DOS BUFFERS.)
                                ; =================================

FMWKAREA        DS 1            ; SIMPLY USED FOR REFERENCE POINT.

FIRSTSTK        = FMWKAREA      ; TRK# OF 1RST T/S LIST SEC.
FIRTSSEC        DS 1            ; SEC # OF 1RST T/S LIST SEC.
CURTSTRK        DS 1            ; TRK# OF CURRENT T/S LIST SEC.
CURTSSEC        DS 1            ; SEC# OF CURRENT T/S LIST SEC.
UPDATFLG        DS 1            ; FLAG TO UPDATE DIFFERENT TYPES
                                ; OF SECTORS:
                                ; $02=LAST OPERATION WAS A WRITE.
                                ; $20=VTOC NEEDS UPDATING.
                                ; $40=DATA SEC NEEDS UPDATING.
                                ; $80=T/S LST SEC NEEDS UPDATING.
CURDATRK        DS 1            ; TRK# OF CURRENT DATA SECTOR.
CURDATSC        DS 1            ; SEC# OF CURRENT DATA SECTOR.
SECNXD1R        DS 1            ; OFFSET OF FILE DESCRIPTION FROM
                                ; THE VERY FIRST DIRECTORY SEC.
BYTNXD1R        DS 1            ; OFFSET OF FILE DESCRIPTION INTO
                                ; THE CURRENT DIRECTORY SEC.
MXSCURTS        DS 2            ; MAXIMUM # OF SECS THAT CAN BE
                                ; LISTED IN A T/S LIST.
RELFIRST        DS 2            ; RELATIVE SEC # (IN RELATION TO
                                ; THE ENTIRE FILE) OF THE FIRST
                                ; DATA SEC THAT IS (OR CAN BE)
                                ; LISTED IN THE CURRENT T/S LIST.
                                ; (POSSIBLE VALS ARE:$0000, $007A,
                                ; 2*$007A, 3*$007A OR 4*$007A.)
RELASTP1        DS 2            ; ONE GREATER THAN THE MAXIMUM
                                ; RELATIVE SEC# (IN RELATION 2 THE
                                ; ENTIRE FILE) OF THE LAST DAT SEC
                                ; THAT CAN POSSIBLY BE DESCRIBED
                                ; IN THE CURRENT T/S LIST.
                                ; (POSSIBLE VALUES ARE: $007A,
                                ; 2*$007A, 3*$007A, 4*$007A AND
                                ; 5*$007A.)
RELPREV         DS 2            ; RELATIVE SEC# (IN RELATION 2 THE
                                ; ENTIRE FILE) OF THE LAST DAT SEC
                                ; THAT WAS READ OR WRITTEN.
                                ; (POSSIBLE VAL ARE: $0000, $007A,
                                ; 2*$007A, 3*$007A OR 4*$007A.)
SECSIZWA        DW $100         ; BYTES/SECTOR (#256, $00-$FF).

                                ; --- FILE POINTER ---
                                ; (3 BYTES)
FILPTSEC        DS 2            ; SECTOR OFFSET OF PTR (2 BYTES).
FILPTBYT        DS 1            ; BYTE OFFSET PORTION OF POINTER.

WASTEBYT        DS 1            ; WEIRD FLG USED BY THE APPEND CMD
                                ; (VIA RSETPTRS, $B6B3) WHEN
                                ; BACKING UP THE FILE POINTER AND
                                ; TESTED (IN APNDPTCH, $B692)
                                ; WHENEVER AN OUT-OF-DATA ERROR IS
                                ; ENCOUNTERED.
RECLENWA        DS 2            ; RECORD LENGTH.
RECNMBWA        DS 2            ; CURRENT RECORD NUMBER.
BYTOFFWA        DS 2            ; CURRENT BYTE OFFSET INTO RECORD.
                                ; - RANDOM ACCESS TXT FILES HAVE A
                                ; FIXED RECORD LNGTH ASSIGNED BY
                                ; THE USER.
                                ; - SEQUENTIAL TEXT AND APPLESOFT
                                ; FILES HAVE A RECORD LENGTH OF
                                ; ONE.
                                ; - DURING A LOAD OR BLOAD, APPLE-
                                ; SOFT OR BINARY FILES ARE
                                ; CONSIDERED TO BE COMPOSED OF A
                                ; COLLECTION OF ONE-BYTE LONG
                                ; RECORDS.
                                ; - WHEN SAVING OR BSAVING HOWEVER
                                ; THESE FILES ARE TREATED AS IF
                                ; THEY CONSIST OF A SINGLE VERY
                                ; LONG RECORD.
FILENSEC        DS 2            ; FILE LENGTH IN SECTORS.
ASIGNSEC        DS 1            ; NEXT SECTOR TO ASSIGN.
ASIGNTRK        DS 1            ; NEXT TRK TO ASSIGN.
ASIGNMAP        DS 4            ; 4-BYTE MAP OF SEC USAGE ON THE
                                ; TRK BEING ASSIGNED.
FILTYPWA        DS 1            ; FILE TYPE CODE (INCLUDING THE
                                ; LOCKED OR UNLOCKED STATUS).
SLOT16WA        DS 1            ; SLOT*16.
DRVWA           DS 1            ; DRIVE NUMBER.
VOLWA           DS 1            ; 1'S COMPLEMENT OF VOLUME NUMBER.
TRKWA           DS 1            ; TRACK NUMBER.
                DS 5            ; UNUSED ($B5FB-$B5FF).











                                ; =================================
                                ; IMAGE OF BOOT1 ($B600-$B6FF)
                                ; =================================

                                ; - STORED ON TRK0/SEC0.
                                ; - READ IN AT $800-$8FF BY DISK CONTROLLER ROM (BOOT0).
                                ; - EXECUTION BEGINS AT $0801 & USES THE CONTROLLER'S READ-
                                ; SECTOR SUBROUTINE (BTRDSEC, $CS00, WHERE S = SLOT # OF
                                ; CARD) TO READ IN TRK0/SEC9 DOWN TO TRK0/SEC1 (THAT IS,
                                ; $BFFF ----> $B600).

                                ; NOTE:  IN ORDER TO GENERATE AN ACCURATE SYMBOL TABLE THAT
                                ; CAN BE APPLIED TO BOTH THE FORMATTED AND LINEAR DIS-
                                ; ASSEMBLIES, AND BECAUSE DIFFERENT ASSEMBLERS VARY IN
                                ; THEIR ABILITIES TO ACCEPT CERTAIN OBJECT VALUES OR RE-ORG
                                ; DURING ASSEMBLY, THE FOLLOWING SPECIAL LABEL SYSTEM HAS
                                ; BEEN CREATED:
                                ;
                                ; IMAGE LBL,ADR    EXECUTION LBL,ADR  ;COMMENTS
                                ; ---------------  -----------------  --------------------
                                ; SEC2RDB6, $B600  SEC2RDB08, $800    ;DEFINES # OF SECS 2 BE READ IN BY BOOT0
                                ; BT1EXCB6, $B601  BT1EXC08 , $801    ;START BT1 EXECUTION BOOT0 JMPS TO HERE.
                                ; SKPRELB6, $B61F  SKPREL08 , $81F    ;TARGET LBL 4 BRNCH.
                                ; PRP4B2B6, $B639  PRP4B208 , $839    ;TARGET LBL 4 BRNCH.
                                ; IMG8FD  , $B6FD  BT1LDADR , $8FD    ;BOOT1 LOAD ADDRESS.
                                ;                                     ;VARIES FROM $B600 TO
                                ;                                     ;$BF00.  EVENTUALLY
                                ;                                     ;PTS 2 START BOOT2 ($B700).
                                ; IMG8FF  , $B6FF  BT1PG2RD , $8FF    ;CONTAINS # OF SECS
                                ;                                     ;TO READ IN WHEN
                                ;                                     ;EXECUTING BOOT1.
                                ;                                     ;ALSO DOUBLES AS
                                ;                                     ;LOGICAL SEC #.
                                ;                                     ;VARIES FROM:
                                ;                                     ;$09 --> $00 --> $FF.
                                ;
                                ; AS INDICATED ABOVE, SEC2RD08 ($800) DEFINES # OF SECS
                                ; TO BE READ IN BY BOOT0.  THIS VALUE IS NORMALLY $01
                                ; (MEANING READ ONLY SEC0 OF TRK0).  HOWEVER, YOU CAN ZAP
                                ; TRK0/SEC0/OFFSET0 WITH A LARGER VALUE ($01 TO $10) TO
                                ; READ IN MORE SECS FROM TRK0.  ALSO NOTE THAT MOST
                                ; REFERENCES SAY THAT SEC2RD08 NORMALLY CONTAINS A "$00"
                                ; (RATHER THAN A "$01").  BECAUSE THE TEST AT $CS56 USES
                                ; THE CARRY, EITHER VAL WILL CAUSE ONLY 1 SEC TO BE READ IN
                                ; HOWEVER, "$01" IS THE VALUE USED BY DOS.  (CONFUSION MAY
                                ; STEM FROM THE FACT THAT APPLESOFT LATER STORES A $00 IN
                                ; $800.)

BOOT1
                IF DOS31
                DB 0
                ELSE
                DB 1            ; IMAGE OF SEC2RD08.  DENOTES # OF
                                ; SECS TO BE READ FROM TRK0 DURING
                                ; BOOT0.
                ENDIF




                IF DOS31
                DS 11
                                ; upon entry, A3 --> first byte of highest RAM page (e.g., $BF00)
L1B28SR
                LDA   A3H
                AND   #$DF      ; $BF becomes $9F
                STA   A4H
                STX   A4L       ; (A4) --> $9F00
                LDA   (A4L,X)
                PHA             ; save (A4) in case we need to restore it below
                STA   PROSCRTH
L1B35           TYA
                EOR   PROSCRTH
                STA   PROSCRTH
                TYA
                EOR   (A3L,X)
                STA   (A4L,X)
                CMP   PROSCRTH
                BNE   L1B4D
                INY
                BNE   L1B35
                                ; comes here if 9F page maps to BF page
                LDY   A4H       ; $9F
                PLA             ; (A4)
                RTS
L1B4D           PLA
                STA (A4L,X)
                LDY A3H
                RTS

                DS $195
                ELSE
                IF DOS32
                DS $FC
                ELSE

BT1EXCB6        LDA PT2BTBUF+1  ; IMAGE OF BT1EXC08. GET NEXT PAGE
                                ; TO BE READ IN.
                CMP #$09        ; IS IT PAGE 9 (IE. 1RST PAGE READ
                                ; BY BOOT1)?
                BNE SKPRELB6    ; NO - ALREADY USED BY BOOT1 TO
                                ; READ PAGE9, SO SKIP POINTER
                                ; INITIALIZATION GIVEN BELOW.

                                ; INITIALIZE THE POINTER (PTR2RDSC)
                                ; TO POINT AT BOOT0'S READ SECTOR
                                ; SUBROUTINE (BTRDSEC, $CS5C;
                                ; WHERE S=SLOT#, NORMALLY $C65C).

                LDA SLT16ZPG    ; (A) = SLOT*16 FROM ZERO PAGE.
                LSR A           ; DIVIDE BY 16.
                LSR A
                LSR A
                LSR A
                ORA #$C0        ; MERGE WITH $C0 TO GET $CS, WHERE
                                ; S=SLOT#.
                STA PTR2RDSC+1  ; STORE HI BYTE OF CONTROLLER'S
                                ; READ-SECTOR SUBROUTINE ADDR.
                LDA #LO BTRDSEC ; GET LOW BYTE OF SUBRTN ADR.
                STA PTR2RDSC    ; (LOW BYTE IS A CONSTANT (#$5C) &
                                ; IS THERE4 NOT VARIABLE WITH SLOT
                                ; USED (AS IS HI BYTE).)


                                ; READ IN 9 SECTORS REPRESENTED BY
                                ; TRK0/SEC9 DOWN TO TRK0/SEC1 INTO
                                ; $BFFF TO $B600.  NOTE THAT THE
                                ; SECS ARE READ IN FROM HIGHER TO
                                ; LOWER MEMORY. THESE SECS CONTAIN
                                ; THE IMAGE OF BOOT1, PART OF THE
                                ; FILE MANAGER AND ALMOST ALL OF
                                ; RWTS & ITS ASSOCIATED ROUTINES.


                                ; CALCULATE THE TARGET ADDR FOR
                                ; THE FIRST SECTOR TO BE READ IN.

                CLC
                LDA BT1LDADR+1  ; CONTAINS $B6 ON 48K SLAVE.
                ADC BT1PG2RD    ; CONTAINS #09 ON 48K SLAVE.
                STA BT1LDADR+1  ; (A) = $BF ON 48K SLAVE.

                                ; DETERMINE # OF PAGES (SECS) LEFT
                                ; 2 READ, PHYSICAL SECTOR# & TARGET
                                ; ADDRESS.  THEN, GO READ IN THE
                                ; NEXT SECTOR.

SKPRELB6        LDX BT1PG2RD    ; IMAGE OF SKRPREL08 ($81F).
                                ; (X)=PAGES LEFT 2 READ (MINUS 1).
                                ; (ALSO DOUBLES AS LOGICAL SEC#.
                                ; VARIES FROM $09-->$FF).
                BMI PRP4B2B6    ; WHEN (X) = #$FF, THEN WE HAVE
                                ; READ ALL THE SECS IN, SO GO XIT.
                LDA PHYSECP8-$2E00,X
                                ; EQUIVALENT 2 "LDA $84D,X".
                                ; CONVERT LOGICAL SEC# 2 PHYS SEC#
                STA BOOTSEC     ; STORE PHYSICAL SEC# IN PAGE0.
                DEC BT1PG2RD    ; REDUCE PAGES (SECS) LEFT TO READ
                                ; FOR NEXT TIME AROUND.
                LDA BT1LDADR+1  ; POINT BUFFER POINTER AT TARGET
                STA PT2BTBUF+1  ; ADR.  (VARIES FROM $BF TO $B6
                                ; ON 48K SLAVE).
                DEC BT1LDADR+1  ; REDUCE HI BYTE OF I/O BUF FOR
                                ; NEXT TIME AROUND.  (VARIES FROM
                                ; $BF TO $B5 ON 48K SLAVE.)
                LDX SLT16ZPG    ; SET (X) = SLOT*16.
                JMP (PTR2RDSC)  ; EQUIVALENT TO "JMP ($8FD)" OR
                                ; "JMP $CS5C" TO GO READ IN THE
                                ; NEXT SECTOR.
                                ; ************ NOTE *************
                                ; * GOES TO BT1EXC08 ($801) AFTER
                                ; * EACH SECTOR IS READ IN.
                                ; * (REMEMBER, BT1EXCB6 IS A
                                ; * CARBON COPY OF BT1EXC08.)
                                ; *******************************


                                ; PREPARE FOR BOOT2.

PRP4B2B6        INC BT1LDADR+1  ; IMAGE OF PR4B208 ($839).
                                ; POINT AT THE LOAD ADR FOR BOOT2.
                INC BT1LDADR+1  ; (AFTR INCS, = $B7 ON 48K SLAVE).

                                ; SET FULL SCREEN TEXT & DESIGNATE
                                ; KEYBOARD & SCREEN AS I/O DEVICES.

                JSR SETKBD      ; SIMULATE IN#0 (SET KSW: KEYIN).
                JSR SETVID      ; SIMULATE PR#0 (SET CSW: COUT1).
                JSR INIT        ; SIMULATE A "TEXT" STATEMENT.
                LDX SLT16ZPG    ; (X) = SLOT*16.

                                ; ------ GO TO BOOT2 ------

                JMP (BT1LDADR)  ; JMP 2 BOOT2 ($B700 ON 48K SLAVE)


                                ; =================================
                                ; TABLE OF PHYSICAL SECTOR #'S.
                                ; ($B64D - $B65C)
                                ; - AN IMAGE OF THIS TABLE IS
                                ; HOUSED AT $84D DURING THE BOOT.
                                ; =================================

                                ; CORRESPONDING LOGICAL SECTOR #
PHYSECP8        DB $00          ; $00
                DB $0D          ; $01
                DB $0B          ; $02
                DB $09          ; $03
                DB $07          ; $04
                DB $05          ; $05
                DB $03          ; $06
                DB $01          ; $07
                DB $0E          ; $08
                DB $0C          ; $09
                DB $0A          ; $0A
                DB $08          ; $0B
                DB $06          ; $0C
                DB $04          ; $0D
                DB $02          ; $0E
                DB $0F          ; $0F

                                ; =================================
                                ; OTHER ERROR PATCH.
                                ; ($B65D - $B670)
                                ; - USED WHEN FM DRIVER GETS AN
                                ; ERROR THAT IS NOT AN OUT-OF-
                                ; DATA ERROR.
                                ; - ALSO CONTAINS THE APPEND FLAG.
                                ; =================================

APPNDFLG        DB $00          ; APPEND FLAG.

                                ; ERROR WAS DEADLY, SO BETTER
                                ; RELEASE THE FILE'S BUFFER AND
                                ; MAKE SURE THE APPEND FLAG IS OFF.

OTHRERR         JSR GETBUFF     ; LOCATE BUFFER BELONGING TO THE
                                ; FILE. (PUT ADR IN A3L/H PTR.)
                BCS TOERRMSG    ; NO BUFFER WAS ASSIGNED, SO NO
                                ; NEED 2 RELEASE THE FILE'S BUF OR
                                ; TURN OFF THE APPEND FLAG.
                LDA #0          ; ZERO OUT THE APPEND FLAG & SET
                TAY             ; (Y) TO NDEX THE 1RST BYTE OF THE
                STA APPNDFLG    ; DOS NAME BUFFER.
                STA (A3L),Y     ; RELEASE FILE'S DOS BUFFER.
TOERRMSG        LDA RTNCODFM    ; GET ERROR CODE TO INDEX ERR MSG.
                JMP ERRHNDLR    ; EXIT & GO PRINT ERROR MESSAGE.


                                ; =================================
                                ; PATCH TO HANDLE APPEND.
                                ; ($B671 - $B685)
                                ; =================================

                                ; PREPARE TO MANUALLY BACK UP THE
                                ; FILE POINTER IF NECESSARY.  NEED
                                ; TO BACK IT UP ONE BYTE IF A $00
                                ; BYTE WAS ENCOUNTERED IN A DATA
                                ; SECTOR.  HOWEVER, IF A ZEROED-
                                ; OUT DATA PAIR (LISTED IN A T/S
                                ; LIST) OR A ZEROED-OUT T/S LINK
                                ; WAS ENCOUNTERED, THEN THE FILE
                                ; POINTER IS POSITIONED CORRECTLY.
                                ; (P.S. AT ONE TIME IN THE HISTORY
                                ; OF DOS, THE POSITION FUNCTION
                                ; WAS USED TO BACK UP THE POINTER.)
                                ; ENTER WITH APPEND FLAG SET IF A
                                ; $00 WAS DETECTED IN A (NON-EMPTY)
                                ; FILE'S T/S LIST.

CKAPFLG         LDA APPNDFLG    ; IS APPEND FLAG ON?
                BEQ CLRAPFLG    ; NO - FLAG IS OFF.
                INC RECNMBFM    ; YES -SO INCREMENT THE FILE MGR'S
                BNE CLRAPFLG    ; VERSION OF THE RECORD # BECAUSE
                INC RECNMBFM+1  ; RECNMBFM IS POINTING AT THE LAST
                                ; VALID DATA BYTE AND WE WANT IT 2
                                ; POINT AT THE NEXT POTENTIAL
                                ; RECORD NUMBER.  (P.S.  REMEMBER
                                ; THAT RECNMBFM LAGS RECNMBWA BY
                                ; ONE BYTE.)
CLRAPFLG        LDA #0          ; DON'T NEED THE APPEND FLAG ANY
                STA APPNDFLG    ; MORE, SO TURN IT OFF.

                IF DOS33_1980
                JMP BK2APND
                ELSE
                IF DOS33_1983
                JMP CMPATCH
                ELSE
                IF DOS33_1986
                JMP RSETPTRS    ; GO BACK UP THE FILE POINTER.
                ENDIF
                ENDIF
                ENDIF

                                ; ==================================
                                ; PATCH TO VERIFY A RANGE-OF-BYTES.
                                ; (CALLED BY RWRANGE TO R/W RANGE
                                ; OF BYTES & THEN VERIFY THE DATA.)
                                ; ==================================

VRFYRWNG        STA SUBCODFM    ; PUT RANGE-OF-BYTES SUBCODE IN
                                ; RWTS'S IOB.
                JSR FMDRIVER    ; CALL FM DRIVER TO READ/WRITE A
                                ; RANGE OF BYTES.
                JSR CMDCLOSE    ; CLOSE FILE & THEN VERIFY DATA.
                JMP CMDVERFY


                                ; ================================
                                ; APPEND PATCH.
                                ; ($B692 -$B6B2)
                                ; - USED TO HANDLE AN END-OF-DATA
                                ; ERROR.
                                ; ================================

                                ; THIS PATCH IS DIFFICULT TO UNDER-
                                ; STAND BECAUSE IT IS A PATCH THAT
                                ; HAS BEEN ADDED TO REPAIR PREVIOUS
                                ; PATCHES AND BECAUSE EXECUTION FAILS
                                ; ON OCCASSION.  AS A RESULT, THE APPEND
                                ; COMMAND HAS EVOLVED INTO A CLASSIC
                                ; CASE OF SPAGHETTI PROGRAMMING.
                                ; PARTS OF THE FOLLOWING ROUTINES
                                ; SEEM USELESS.  THEY MAY JUST BE
                                ; RESIDUAL (BUT INNOCUOUS) INSTRUCS
                                ; THAT ARE LEFT OVER FROM AN EARLIER
                                ; VERSION OF DOS.

                                ; CHECK IF FILE POINTER AND WASTEBYT
                                ; ARE ZEROES.

APNDPTCH        LDY #$13
CK4ZEROS        LDA (A4L),Y
                BNE SETAPFLG    ; UNLESS WE ARE DEALING WITH A
                                ; USELESS FILE THAT WAS PREVIOUSLY
                                ; OPENED. BUT NEVER CLOSED, THIS
                                ; INSTRUCTION IS ALWAYS TAKEN.
                INY
                CPY #$17
                BNE CK4ZEROS

                                ; THE PURPOSE OF THE FOLLOWING
                                ; INSTRUCTIONS IS NOT UNDERSTOOD.
                                ; THIS SECTION OF CODE MAY HAVE BEEN
                                ; DESIGNED TO DEAL WITH USELESS FILES
                                ; THAT WERE OPENED BUT NEVER CLOSED.
                                ; WHATEVER THE ORIGINAL PURPOSE WAS,
                                ; THE FOLLOWING CODE APPEARS TO KEEP
                                ; THE FILE POINTER AT #$000000 WHEN
                                ; AN EMPTY FILE (IE. FILE WITH NO
                                ; DATA) IS ENCOUNTERED.

                LDY #$19        ; COPY IMAGE OF RECNMBWA/+1 AND
COPYRECS        LDA (A4L),Y     ; BYTOFFWA/+1 THAT WERE JUST
                STA RECLENFM-$19,Y
                                ; STORED IN THE WORK BUFFER TO
                INY             ; RECNMBFM/+1 AND BYTOFFFM/+1 IN
                CPY #$1D        ; THE FM PARAMETER LIST.
                BNE COPYRECS

FMDVRTN         JMP BK2FMDRV

                                ; SET THE APPEND FLAG.
                                ; (NEVER ENTERED IF DEALING WITH
                                ; AN EMPTY FILE.)

SETAPFLG        LDX #$FF
                STX APPNDFLG    ; SET THE APPEND FLAG.
                BNE FMDVRTN     ; ALWAYS.


                IF DOS33_1986
                                ; =================================
                                ; YET ANOTHER APPEND PATCH.
                                ; ($B6B3 - $B6CE)
                                ; =================================

                                ; BUGGY ROUTINE USED TO BACK UP THE
                                ; FILE POINTER.  IF A FILE IS $FFFF
                                ; (#65536) BYTES LONG (OR SOME
                                ; MULTIPLE THEREOF), THE APPEND CMD
                                ; WILL FAIL BECAUSE THIS ROUTINE
                                ; NEGLECTS TO BACK UP THE HI BYTE
                                ; OF THE FILE POINTER (FILPTSEC+1).

RSETPTRS        LDA RECNMBFM    ; RECONCILE RECORD NUMBER VERSIONS
                STA FILPTBYT    ; AND LOWEST TWO BYTE OF THE FILE
                STA RECNMBWA    ; POINTER.
                LDA RECNMBFM+1
                STA WASTEBYT    ; APPEARS TO BE IRRELEVANT.
                                ; OBVIOUSLY HAS SOMETHING TO DO
                                ; WITH CK4ZEROS ROUTINE DESCRIBED
                                ; ABOVE.
                STA RECNMBWA+1
                STA FILPTSEC
                TSX             ; RESET THE STK POINTER SO WE CAN
                STX STKSAV      ; USE THE FMEXIT ROUTINE TO RETURN
                                ; TO THE CALLER OF THE APPEND CMD.
                                ; (NOTE: THIS WILL BE EXCEPTIONAL
                                ; EXIT ROUTE FOR FMEXIT.)
                JMP GOODFMXT    ; EXIT THE APPEND CMD VIA FMEXIT
                                ; ROUTINE. EXECUTION ACTUALLY RTNS
                                ; 2 AFTRCMD ($A17D) LOCATED IN THE
                                ; CMD PARSING AND PROCESSING
                                ; ROUTINES.
                ELSE
                DS 28
                ENDIF


                                ; =================================
                                ; FREE SPACE
                                ; =================================

                DS 1            ; ($B6CF)


                IF DOS33_1980
                                ; =================================
                                ; STRAY CODE (NOT USED).
                                ; ($B6D0-$B6E7.)
                                ; =================================

                                ; - DO A HOME & THEN PRINT "B01-00"
                                ; - CONSIDER TO BE FREE SPACE.

                JSR HOME
                LDA #"B"|0x80
                JSR COUT
                LDA #$01
                JSR PRBYTE
                LDA #"-"|0x80
                JSR COUT
                LDA #$00
                JSR PRBYTE
                RTS
                ELSE
                DS 24
                ENDIF


                                ; =================================
                                ; FREE SPACE
                                ; =================================

                DS 21           ; ($B6E8-$B6FC.)

                ENDIF
                ENDIF

                                ; =================================
                                ; STORAGE FOR BOOT1.
                                ; ($B6FD - $B6FF)
                                ; (IMAGE MOVED TO $8FD-$8FF.)
                                ; =================================


IMG8FD
BT1LDADR        = IMG8FD-(BOOT1-$800)
                IF DOS31
                DW BOOT2-$F8
                ELSE
                DW BOOT1        ; VARIES FROM $B600-$BF00 ON 48K (Chris Mosher: was hardcoded $B600)
                                ; SLAVE.  (EVENTUALLY POINTS TO THE
                                ; START OF BOOT2 AT $B700.  IMAGE
                                ; OF BT1LDADR AT $8FD.)
                ENDIF
IMG8FF
BT1PG2RD        = IMG8FF-(BOOT1-$800)
                IF DOS31 || DOS32
                DB $48
                ELSE
                DB 9            ; DS 1 ;CONTAINS # OF PAGES TO READ WHEN (Chris Mosher DS 1 to DB 9)
                                ; EXECUTING BOOT1.  ALSO DOUBLES AS
                                ; LOGICAL SEC#.  INITIALLY = $01.
                                ; VARIES FROM:$09 --> $00 --> $FF.
                                ; (IMAGE OF BT1PG2RD AT $8FF.)
                ENDIF












                                ; =========================================
                                ; BOOT2 ($B700 - $B749).
                                ; =========================================

                                ; - READS IN THE REST OF DOS STARING AT
                                ; TRK02/SEC04 DOWN TO TRK00/SEC0A
                                ; ($B5FF --> $9B00).  (SECTORS 0A & 0B
                                ; OF TRK 0 ($9CFF - $9B00) ARE
                                ; EMPTY.)
                                ; - AFTER THE REST OF DOS IS READ IN,
                                ; EXECUTION JUMPS TO DOS'S COLDSTART
                                ; ROUTINE (DOSCLD, $9D84).
                                ; - NOTE THAT ON ENTRY:  (X) = SLOT * 16.
                                ; :::::::::::::::::::::::::::::::::::::::::

                                ; PREPARE RWTS'S INPUT-OUTOUT BLOCK
                                ; (IOB) AND DESIGNATE THE NUMBER OF
                                ; SECTORS TO READ.

BOOT2           STX IBSLOT      ; (X) = SLOT*16 WANTED.
                STX IOBPSN      ; LAST-USED SLOT*16.
                LDA #1          ; DESIGNATE BOTH LAST-USED & WNTD
                STA IOBPDN      ; DRIVES TO BE DRIVE#1.
                STA IBDRVN
                LDA NMPG2RD     ; SET NUMBER OF PAGES TO READ.
                STA BT2PGCTR    ; COUNTER 4 NUMBER OF PGS 2 READ.

                IF DOS31 || DOS32
                LDA #0
                STA IBTRK
                LDA BT1RSTSC
                STA IBSECT
                LDA BT1STPAG
                STA IBBUFP+1
                ELSE
                LDA #2          ; START WITH TRK$02/SEC$04.
                STA IBTRK       ; TRACK.
                LDA #4
                STA IBSECT      ; SECTOR.
                LDY BTSTAGE+1   ; (Y)=HI BYTE OF ADDR OF IMAGE OF
                                ; BOOT1 (#$B6 ON 48K SLAVE).
                DEY             ; DEFINE I/O BUF AS 1 PAGE BELOW
                STY IBBUFP+1    ; BOOT1.
                ENDIF

                LDA #1          ; OPCODE FOR READ.
                STA IBCMD

                                ; CONVERT FROM (X) = SLOT*16
                                ; TO (X) = SLOT.

                TXA             ; (X) = SLOT * 16.
                LSR A           ; DIVIDE BY 16.
                LSR A
                LSR A
                LSR A
                TAX             ; (X) = SLOT.

                                ; INITIALIZE PAGE-4 LOCATIONS WITH
                                ; TRACK #'S ASSOC WITH THE DRIVES.

                LDA #0
                STA TRK4DRV2,X
                STA TRK4DRV1,X

                                ; CALL ROUTINE TO READ IN THE REST OF DOS.

                JSR RWPAGES     ; GO READ A GROUP OF PAGES (SECS).
                LDX #$FF        ; COMPLETELY CLEAR OUT THE STACK.
                TXS
                STX IBVOL       ; SET VOL TO $FF (COMPLEMENT OF 0)
                IF DOS31 || DOS32
                JSR SETVID
                ELSE
                JMP CLOBCARD    ; GO CLOBBER THE LANGUAGE CARD AND
                                ; SET VIDEO OUTPUT (SIMUL8 PR#0).
                                ; (RETURNS TO NEXT INSTRUC BELOW.)
                ENDIF

BK2BOOT2        JSR SETKBD      ; SIMULATE "IN#0" STATEMENT.
                                ; (THAT IS, SELECT KEYBOARD.)
TODOSCLD2       JMP DOSRELOC    ; JUMP IN2 DOS'S COLDSTART ROUTINE
                                ; (AT $9DE4) TO BUILD THE DOS BUFS
                                ; AND THE PAGE-3 VECTOR TABLE AND
                                ; THEN RUN THE "HELLO" PROGRAM.
                                ; ************* NOTE ************
                                ; * THIS INSTRUC IS A HACKER'S
                                ; * DREAM.  FOR INSTANCE, YOU CAN
                                ; * CHANGE THE JUMP TO POINT TO
                                ; * YOUR OWN PASSWORD OR TIME-
                                ; * BOMB PRGM THAT YOU HAVE
                                ; * DEVIOUSLY IMBEDDED IN AN
                                ; * UNUSED SECTION OF DOS.
                                ; *******************************
                                ; Mosher: note: on a master disk, it
                                ; jumps to the DOS relocation routine;
                                ; on a slave disk, it just jumps to
                                ; the coldstart as indicated above.


                                ; ================================
                                ; WRITE DOS IMAGE ON TRKS 0 - 2.
                                ; (USED BY INIT FUNCTION.)
                                ;
                                ; WRITE TRK02/SEC04 ($B5FF) DOWN
                                ; TO TRK00/SEC0C ($9D00).
                                ; ================================

WRDOSIMG
                IF DOS31 || DOS32
                LDA   IBBUFP+1
                STA   BT1STPAG
                SEC
                LDA   BTSTAGE+1
                SBC   BT1STPAG
                STA   NMPG2RD
                LDA   #$00
                STA   IBTRK
                STA   IBSECT
                STA   IBBUFP
                LDA   BTSTAGE+1
                STA   IBBUFP+1
                STA   IMG8FD+1
                LDA   #$0A
                STA   BT2PGCTR
                STA   BT1RSTSC
                LDA   #$48
                STA   IMG8FF
                LDA   #$02
                STA   IBCMD
                JSR   RWPAGES
                LDA   BT1STPAG
                STA   IBBUFP+1
                LDA   NMPG2RD
                STA   BT2PGCTR
                JSR   RWPAGES
                RTS

RWPAGES         LDA   ADROFIOB+1
                LDY   ADROFIOB
                IF DOS31
                JSR   RWTS
                ELSE
                JSR   ENTERWTS
                ENDIF
                LDY   IBSECT
                INY
                CPY   #$0D
                BNE   L37A9
                LDY   #$00
                INC   IBTRK
L37A9           STY   IBSECT
                INC   IBBUFP+1
                DEC   BT2PGCTR
                BNE   RWPAGES
                RTS
                ENDIF
                IF DOS31
VERFY           LDA   #$0C
                JSR   HNDLCMD1
                LDA   #$06
                CMP   RTNCODFM
                BNE   TOCLOSE
                JMP   TONOTFND
TOCLOSE         JMP   CMDCLOSE
                DS 24
                ENDIF





                IF !DOS31

                IF !DOS32
                LDA BTSTAGE+1   ; CALC # OF PAGES TO WRITE:
                SEC             ; (#$B6 - #$9D = #$19 OR #25.)
                SBC IBBUFP+1
                STA BT2PGCTR    ; SET COUNTER FOR 25 PAGES.
                LDA BTSTAGE+1
                STA IBBUFP+1
                DEC IBBUFP+1    ; START WITH PAGE #$B5.
                LDA #2          ; START WITH TRK02/SEC04.
                STA IBTRK
                LDA #4
                STA IBSECT
                LDA #2          ; SET WRITE COMMAND.
                STA IBCMD
                JSR RWPAGES     ; WRT TRK02/SEC04 TO TRK00/SEC00.

                                ; WRITE TRK00/SEC09 ($BFFF) DOWN
                                ; TO TRK00/SEC00 ($9D00).

                LDA BTSTAGE+1   ; STORE HI BYTE OF ADRRESS OF THE
                STA IMG8FD+1    ; START OF BOOT1 (#$B6).
                CLC             ; CALC HI BYTE ADR OF TRK00/SEC09
                ADC #9          ; (#$B6 + #$09 = #$BF).
                STA IBBUFP+1    ; SET BUF 2 SEND INFO 2 PAGE #$BF.
                LDA #10         ; DESIGNATE 10 PAGES TO WRITE.
                STA BT2PGCTR    ; (#$BFFF - #$B600).
                SEC
                SBC #1
                STA IMG8FF      ; SIGNIFY THAT THERE ARE 9 PAGES 2
                                ; BE READ WHEN BOOT1 IS EXECUTED.
                STA IBSECT      ; START WRITING WITH TRK00/SEC09.
                JSR RWPAGES     ; WRITE TRK00/SEC09 2 TRK00/SEC00.
                RTS

                DS 6            ; UNUSED.

                                ; =================================
                                ; READ/WRITE A GROUP OF PAGES.
                                ; =================================

RWPAGES         LDA ADROFIOB+1  ; INIT (A)/(Y) WITH HI/LOW BYTS OF
                LDY ADROFIOB    ; ADR OF RWTS'S IOB 4 NTRY 2 RWTS.
                JSR ENTERWTS    ; ENTER IN2 RWTS 2 READ/WRITE SEC.
                LDY IBSECT      ; GET # OF SEC JUST RD OR WRITTEN
                DEY             ; VAL 4 NXT SEC 2 READ/WRITE (WHEN
                                ; EXECUTING BOOT1, #$09 --> #$FF).
                BPL SAMETRK     ; BRANCH TO USE THE SAME TRACK.

                                ; START A NEW TRACK.

                LDY #$0F        ; START WITH SEC 15.
                NOP
                NOP
                DEC IBTRK       ; REDUCE TRK# WANTED.

                                ; ADJUST POINTER TO IOB & TEST IF THERE
                                ; ARE ANY MORE SECTORS TO READ/WRITE.

SAMETRK         STY IBSECT      ; STORE NUMBER OF SEC WANTED.
                DEC IBBUFP+1    ; REDUCE BUFFER'S PAGE ADR.
                DEC BT2PGCTR    ; REDUCE CNTR 4 # OF SECS 2 READ.
                BNE RWPAGES     ; MORE SECS TO READ.
                RTS

                ENDIF



                                ; ===================================
                                ; ROUTE EXECUTION TO RWTS.
                                ; ===================================

                                ; NORMAL ROUTE TO ENTER RWTS FROM
                                ; CUSTOM ASSEMBLY LANGUAGE PRGMS.
                                ; ON ENTRY - THE IOB AND DCT TBLS
                                ; MUST ALREADY BE SET UP.
                                ; - (Y) AND (A) = LOW AND
                                ; HI BYTES (RESPECTIVELY)
                                ; OF ADDR OF IOB TABLE.
                                ; (P.S.  NOTE THAT THE $3D9 VECTOR
                                ; JUMPS TO HERE!!!)

ENTERWTS        PHP             ; SAVE STATUS ON STK.
                                ; (C)=0 IF SEEKING OR READING.
                                ; (C)=1 IF WRITING OR FORMATTING.
                SEI             ; SET INTERRUPT DISABLE FLAG TO
                                ; PREVENT ANY FURTHER MASKABLE
                                ; INTERRUPTS WHEN DOING REAL-TIME
                                ; PROGRAMMING.
                JSR RWTS        ; ENTER RWTS PROPER 2 DO OPERAT'N:
                                ; $00=SEEK, $01=READ,
                                ; $02=WRITE, $03=FORMAT.
                BCS ERRENTER    ; OPERATION WAS NOT SUCCESSFUL.
                                ; NVR TAKEN IF JUST SEEKING CAUSE
                                ; NO ERROR SIGNALLING ROUTINES ARE
                                ; ASSOCIATED WITH THAT OPERATION.
                PLP             ; THROW STATUS OFF STACK.
                CLC             ; SIGNAL SUCCESSFUL.
                RTS

ERRENTER        PLP             ; THROW STATUS OFF STACK.
                SEC             ; SIGNAL UNSUCCESSFUL.
                RTS


                                ; =================================
                                ; SET UP RWTS'S IOB TO WRITE DOS.
                                ; =================================
PRPWRDOS        LDA FIRDOSPG+1  ; DESIGNATE START OF DOS AS ADR OF
                STA IBBUFP+1    ; I/O BUF IN RWTS'S IOB.
                LDA #0
                STA IBBUFP
                LDA VOLWA       ; COMPLEMENT VOL#.
                EOR #$FF
                STA IBVOL
                RTS


                                ; =================================
                                ; ZERO OUT THE CURRENT (256-BYTE)
                                ; BUFFER.
                                ; =================================
ZCURBUF         LDA #0
                TAY
ZCURBUF1        STA (A4L),Y
                INY
                BNE ZCURBUF1
                RTS




                ENDIF







                                ; =================================
                                ; PARAMETERS FOR BOOT2.
                                ; ($B7DF - $B7E7)
                                ; =================================

                DS 1            ; UNUSED ($B7DF).
NMPG2RD         DB $1B          ; # OF PAGES TO READ (#27).
BT2PGCTR        DS 1            ; # OF PAGES LEFT 2 READ (VARIES).
BT1RSTSC        DB $0A          ; FIRST SEC # IN STAGE (#10).
BT1STPAG        DB HI MASTERDOS ; BASE PAGE TO READ INTO?

ADROFIOB        DW IBTYPE       ; ADR OF RWTS'S IOB (NORM $B7E8).

BTSTAGE                         ; ADR OF START OF IMAGE OF BOOT1.
                IF DOS31
                DW BOOT2-$100
                ELSE
                DW BOOT1
                ENDIF



                                ; =================================
                                ; RWTS'S INPUT/OUTPUT BLOCK (IOB).
                                ; ($B7E8 - $B7FA)
                                ; =================================

IBTYPE          DB $01          ; TABLE TYPE (SHOULD BE $01).
IBSLOT          DS 1            ; SLOT WANTED * 16.
IBDRVN          DS 1            ; DRIVE WANTED ($01 OR $02).
IBVOL           DS 1            ; VOL WANTED ($00 GOOD FOR ALL).
IBTRK           DS 1            ; TRK WANTED.
IBSECT          DS 1            ; LOGICAL SEC WANTED.
IBDCTP          DW DEVTPC       ; PTS 2 DEVICE CHARACTERISTIC TBL.
                                ; (NORMALLY, $B7FB).
IBBUFP          DS 2            ; PTS 2 RWTS'S I/O BUFFER.
IBSECSZ         DW $100         ; SEC SIZ IN BYTS (LOW/HI FORMAT). ; mosher ??? DS 2 ???
IBCMD           DS 1            ; RWTS COMMAND CODE:
                                ; $00=SEEK, $01=READ,
                                ; $02=WRITE, $04=FORMAT.
IBSTAT          DS 1            ; ERROR CODE:
                                ; $00=NO ERRS, $10=WRIT PROT,
                                ; $20=VOL MISMTCH, $40=I/O(DRV)ERR
                                ; $80=READ ERR.
IBSMOD          DS 1            ; VOLUME FOUND.
IOBPSN          DS 1            ; SLOT*16 OF LAST ACCESS (FOUND).
IOBPDN          DS 1            ; DRIVE # OF LAST ACCESS (FOUND).
                DS 2            ; UNUSED ($B7F9-$B7FA).


                                ; =================================
                                ; DEVICE CHARACTERISTIC TABLE.
                                ; ($B7FB - $B7FF)
                                ; =================================

DEVTPC          DB $00          ; DEVICE TYPE.
PPTC            DB $01          ; PHASES/TRK. (EVEN VAL = 1PHASE,
                                ; ODD VAL = 2PHASE.)  THEREFORE,
                                ; $01=2 PHASE (WHICH TRANSLATES TO
                                ; 2 ARM MOVEMENTS PER TRACK).
MONTC           DB $EF,$D8      ; MOTOR-ON-TIME COUNT.
                DS 1            ; UNUSED ($B7FF).

                                ; ================================
                                ; PRENIBBLE DATA ($B800-$B829).
                                ; CONVERT 256 MEMORY BYTES TO 342
                                ; SIX-BIT NIBBLES AS SHOWN BELOW.
                                ; ================================

                                ; ON ENTRY:  PTR2BUF PTS AT DATA BUF.
                                ; ON EXIT:  (A) = ?.
                                ; (X) = #$FF.
                                ; (Y) = #$FF.
                                ; (C) = 1.

                                ; RWTSBUF1
                                ; BB00: 0 0 00-7 00-6 00-5 00-4 00-3 00-2
                                ; BB01: 0 0 01-7 01-6 01-5 01-4 01-3 01-2
                                ; BB02: 0 0 02-7 02-6 02-5 02-4 02-3 02-2
                                ; .
                                ; .
                                ; .
                                ; BBFF: 0 0 FF-7 FF-6 FF-5 FF-4 FF-3 FF-2
                                ;
                                ; RWTSBUF2
                                ; BC00: 0 0 01-0 01-1 AB-0 AB-1 55-0 55-1
                                ; BC01: 0 0 00-0 00-1 AA-0 AA-1 54-0 54-1
                                ; BC02: 0 0 FF-0 FF-1 A9-0 A9-1 53-0 53-1
                                ; .
                                ; .
                                ; .
                                ; BC54: 0 0 AD-0 AD-1 57-0 57-1 01-0 01-1
                                ; BC55: 0 0 AC-0 AC-1 56-0 56-1 00-0 00-1

                                ; WHERE "AC-0" = BIT0 OF MEMORY BYTE
                                ; WHICH IS OFFSET
                                ; #$AC BYTES INTO
                                ; THE DATA SECTOR.
                                ; THE FOLLOWING BITS ARE DUPLICATED
                                ; IN $BC00-$BC01 & $BC54-$BC55 BUT
                                ; ARE IGNORED IN $BC00-$BC01:
                                ; 01-0,01-1,00-0,00-1.

PRENIBL
                IF DOS31 || DOS32
                                ; Note: DOS 3.2 and DOS 3.1 use "5 and 3" encoding,
                                ; instead of the "6 and 2" encoding used by DOS 3.3.
                LDX   #$32
                LDY   #$00
PRENIB1         LDA   (PTR2BUF),Y
                STA   PT2BTBUF
                LSR   A
                LSR   A
                LSR   A
                STA   RWTSBUF1,X
                INY
                LDA   (PTR2BUF),Y
                STA   HOLDPRES
                LSR   A
                LSR   A
                LSR   A
                STA   RWTSBUF1+$33,X
                INY
                LDA   (PTR2BUF),Y
                STA   DESTRK
                LSR   A
                LSR   A
                LSR   A
                STA   RWTSBUF1+$66,X
                INY
                LDA   (PTR2BUF),Y
                LSR   A
                ROL   DESTRK
                LSR   A
                ROL   HOLDPRES
                LSR   A
                ROL   PT2BTBUF
                STA   RWTSBUF1+$99,X
                INY
                LDA   (PTR2BUF),Y
                LSR   A
                ROL   DESTRK
                LSR   A
                ROL   HOLDPRES
                LSR   A
                STA   RWTSBUF1+$CC,X
                LDA   PT2BTBUF
                ROL   A
                AND   #%00011111
                STA   RWTSBUF2,X
                LDA   HOLDPRES
                AND   #%00011111
                STA   RWTSBUF2+$33,X
                LDA   DESTRK
                AND   #%00011111
                STA   RWTSBUF2+$66,X
                INY
                DEX
                BPL   PRENIB1
                LDA   (PTR2BUF),Y
                TAX
                AND   #$07
                STA   RWTSBUF2+$99
                TXA
                LSR   A
                LSR   A
                LSR   A
                STA   RWTSBUF1+$FF
                ELSE
                LDX #0
                LDY #2
PRENIB1         DEY
                LDA (PTR2BUF),Y ; GET BYTE FROM "DATA" BUFFER.
                LSR A           ; PUT ITS LWR 2 BITS IN2 RWTSBUF1.
                ROL RWTSBUF2,X
                LSR A
                ROL RWTSBUF2,X
                STA RWTSBUF1,Y  ; PUT REMAINING 6 BITS N RWTSBUF1.
                INX
                CPX #$56
                BCC PRENIB1
                LDX #0
                TYA
                BNE PRENIB1     ; REPEAT UNTIL @ BYTE OF RWTSBUF2
                                ; HAS 6 BITS.
                LDX #$55        ; MAKE SURE BITS 6 & 7 OF RWTSBUF2
PRENIB2         LDA RWTSBUF2,X  ; ARE ZEROES.
                AND #%00111111
                STA RWTSBUF2,X
                DEX
                BPL PRENIB2
                ENDIF

                RTS


                                ; ====================================
                                ; WRITE SECTOR TO DISK ($B82A-$B8B7).
                                ; ====================================

                                ; ON ENTRY: (X) = SLOT*16
                                ; ON EXIT:  (C) = 1 = WRIT PROT ERR.
                                ; IF NO ERROR: (C) = 0
                                ; (A) = ?
                                ; (X) = SLOT*16
                                ; (Y) = #$00


WRITESEC        SEC             ; (C)=1, ASSUME WRITE PROTECTED
                                ; ERROR AS DEFAULT CONDITION.
                IF !DOS31 && !DOS32
                STX FRMTSLOT    ; SAVE SLOT*16 IN PAGES 0 & 6.
                STX SLOTPG6
                ENDIF
                LDA Q6H,X       ; CHK IF DISK IS WRITE PROTECTED.
                LDA Q7L,X
                BMI PROTECTD    ; BRANCH IF WRITE PROTECTED.
                IF DOS31 || DOS32
                STX FRMTSLOT    ; SAVE SLOT*16 IN PAGES 0 & 6.
                STX SLOTPG6
                ENDIF
                LDA RWTSBUF2    ; GET 1RST 2-ENCODED BYTE AND SAVE
                STA HOLDNIBL    ; IT FOR LATER USE.

                                ; WRITE 5-SYNC GAP BETWEEN ADDRESS
                                ; EPILOGUE & DATA PROLOGUE.

                LDA #$FF        ; (A) = SYNC BYTE.
                STA Q7H,X       ; WRITE 1 SYNC BYTE.
                ORA Q6L,X
                PHA             ; (3 CYC)
                PLA             ; (4 CYC)
                NOP             ; (2 CYC)
                IF DOS31 || DOS32
                LDY #10
                ELSE
                LDY #4          ; WRITE 4 MORE SYNCS (2 CYC).
                ENDIF
WRITE4FF
                IF DOS31 || DOS32
                ORA HOLDNIBL
                ELSE
                PHA             ; (3 CYC)
                PLA             ; (4 CYC)
                ENDIF
                JSR WRITE2      ; (12 CYC BEFORE, 6 AFTER.)
                DEY             ; (2 CYC)
                BNE WRITE4FF    ; (2 OR 3 CYC)

                                ; WRITE DATA PROLOGUE ("D5 AA AD").

                LDA #$D5        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)
                LDA #$AA        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)
                LDA #$AD        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)

                                ; CONVERT & WRITE CONTENTS OF RWTS
                                ; BUFFERS TO DISK.  (WHEN FORMATTING,
                                ; THESE BUFS ARE ZEROED OUT.  THE
                                ; "$00" BYTES IN BUF ARE LATER TRANS-
                                ; LATED TO "$96" BYTES ON THE DISK.)

                                ; CONVERT & WRITE 2-ENCODED
                                ; NIBBLES FROM RWTSBUF2.
                                ; (EOR TO CALC (X) & THEN USE (X)
                                ; AS INDEX TO TBL OF DISK BYTES.)
                                ;
                                ; #0 EOR $BC55 = (X)
                                ; $BC55 EOR $BC54 = (X)
                                ; $BC54 EOR $BC53 = (X)
                                ; .   .     .     .
                                ; .   .     .     .
                                ; .   .     .     .
                                ; $BC01 EOR $BC00 = (X)

                TYA             ; (A) = 0.
                IF DOS31 || DOS32
                LDY #$9A
                ELSE
                LDY #$56        ; (DEC #86.)
                ENDIF
                BNE DOEOR       ; ALWAYS.
GETNIBL         LDA RWTSBUF2,Y
DOEOR           EOR RWTSBUF2-1,Y
                TAX             ; INDEX TO DISK BYTE.
                LDA DSKNBTBL,X  ; GET DISK BYTE.
                LDX FRMTSLOT    ; (X) = SLOT*16.
                STA Q6H,X       ; WRITE BYTE.
                LDA Q6L,X
                DEY             ; (Y) = $56 --> #$00.
                BNE GETNIBL     ; (WRITE $56 OR DEC #86 BYTES.)

                                ; CONVERT & WRITE 6-ENCODED
                                ; NIBBLES FROM RWTSBUF1.
                                ;
                                ; $BC00 EOR $BB00 = (X)
                                ; $BB00 EOR $BB01 = (X)
                                ; $BB01 EOR $BB02 = (X)
                                ; .    .    .      .
                                ; .    .    .      .
                                ; .    .    .      .
                                ; $BBFE EOR $BBFF = (X)

                LDA HOLDNIBL    ; NORMALLY = CONTENTS OF $BC00.
                NOP
SCNDEOR         EOR RWTSBUF1,Y
                TAX             ; INDEX TO DISK BYTE.
                LDA DSKNBTBL,X  ; GET DISK BYTE TO WRITE.
                LDX SLOTPG6     ; (X) = SLOT*16.
                STA Q6H,X       ; WRITE 87TH ---> 341ST BYTES.
                LDA Q6L,X
                LDA RWTSBUF1,Y
                INY             ; (Y) = #$00 ---> #$FF.
                BNE SCNDEOR

                                ; CONVERT & WRITE DATA CHECKSUM.
                                ; (342ND BYTE, $BBFF ------> (X).)

                TAX             ; INDEX TO TABLE OF DISK BYTES.
                LDA DSKNBTBL,X  ; GET DISK BYTE TO WRITE.
                LDX FRMTSLOT    ; (X) = SLOT*16.
                JSR WRITE3      ; (5 CYCS BEFORE, 6 AFTER.)

                                ; WRITE DATA EPILOGUE ("DE AA EB").

                LDA #$DE        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)
                LDA #$AA        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)
                LDA #$EB        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)

                                ; WRITE A SYNC BYTE.
                IF !DOS31 && !DOS32
                LDA #$FF        ; (2 CYC)
                JSR WRITE1      ; (14 CYCS BEFORE, 6 AFTER.)
                ENDIF
                LDA Q7L,X       ; SET READ MODE.
PROTECTD        LDA Q6L,X
                RTS


                                ; ====================================
                                ; WRITE BYTE WITH VARIOUS DELAYS.
                                ; (DELAYS PRIOR TO ENTRY & THOSE
                                ; SHOWN BELOW RESULT IN WRITING BYTES
                                ; EVERY 32 MACHINE CYCLES.)
                                ; ====================================

WRITE1          CLC             ; (2 CYC)
WRITE2          PHA             ; (3 CYC)
                PLA             ; (4 CYC)
WRITE3          STA Q6H,X       ; (5 CYC) - SHIFT REGISTER)
                ORA Q6L,X       ; (4 CYC - STROBE LATCH)
                RTS             ; (6 CYC)


                                ; =================================
                                ; POSTNIBBLE DATA ($B8C2 - $B8DB).
                                ; CONVERT 6- & 2-ENCODED BYTES IN
                                ; RWTS'S TWO BUFFERS TO NORMAL
                                ; MEMORY BYTES (USUALLY PLACED IN
                                ; DOS DATA SECTOR BUFFER).
                                ; =================================

                                ; ON ENTRY:  (X) = SLOT*16.
                                ; PTR2BUF = PTS TO DATA BUF.
                                ; ON EXIT:  (A) = ?
                                ; (X) = ?
                                ; (Y) = BYTE COUNT USED
                                ; FOR RWTBUF2.
                                ; (C) = 1.


                IF !DOS31 && !DOS32
POSTNB16        LDY #0
POSTNIB1        LDX #$56        ; (DEC #86.)
POSTNIB2        DEX
                BMI POSTNIB1
                LDA RWTSBUF1,Y  ; SET (A) = 6-ENCODED BYTE.
                LSR RWTSBUF2,X  ; PUT LWR 2 BITS OF 2-ENCODED BYTE
                ROL A           ; INTO ORIGNAL 6-ENCODED BYTE TO
                LSR RWTSBUF2,X  ; CREATE A NORMAL MEMORY BYTE.
                ROL A
                STA (PTR2BUF),Y ; PUT NORMAL MEMORY BYTE IN RWTS'S
                INY             ; BUF (NORMALLY DOS DATA SEC BUF).
                CPY PROSCRTH
                BNE POSTNIB2
                RTS
                ENDIF


                                ; ===================================
                                ; READ DATA SECTOR INTO RWTS'S BUFS.
                                ; ===================================

                                ; CONDITIONS FOR $B8DC - $B943:
                                ; ON ENTRY:  (X) = SLOT*16
                                ; ON EXIT:  (C) = 1 IF ERROR
                                ; IF NO ERR: (C) = 0.
                                ; (A) = #$AA.
                                ; (X) = SLOT*16.
                                ; (Y) = #$00.

                                ; FIND DATA PROLOGUE ("D5 AA AD").

READATA         LDY #32         ; SET (Y) = 32 ATTEMPTS TO FIND
REDUCEY         DEY             ; THE DATA PROLOGUE.
                BEQ ERRTN       ; ERROR - CAN'T FIND DAT PROLOGUE.
PRODATD5        LDA Q6L,X       ; GET BYTE FROM DATA PROLOGUE.
                BPL PRODATD5    ; WAIT FOR FULL BYTE.
VERSD5          EOR #$D5        ; CHK IF BYTE WAS "D5".
                BNE REDUCEY     ; WASN'T "D5", REDUCE COUNTER.
                NOP             ; STALL 2 CYCLES.
PRODATAA        LDA Q6L,X       ; READ NEXT DATA PROLOGUE BYTE.
                BPL PRODATAA    ; WAIT FOR FULL BYTE.
                CMP #$AA        ; WAS IT AN "AA"?
                BNE VERSD5      ; NO - GO RESTART SEQUENCE.
                IF DOS31 || DOS32
                LDY #$9A
                ELSE
                LDY #$56        ; SET (Y) FOR LATER USE IN READ
                                ; DATA ROUTINE.
                ENDIF
PRODATAD        LDA Q6L,X       ; READ NEXT BYTE IN DATA PROLOGUE.
                BPL PRODATAD    ; WAIT FOR FULL BYTE.
                CMP #$AD        ; WAS IT AN "AD"?
                BNE VERSD5      ; NO - GO RESTART SEQUENCE.

                                ; READ 1RST 86 BYTES OF DATA INTO
                                ; RWTSBUF2 ($BC55 --> $BC00).
                                ;
                                ; USE DISK BYTE AS INDEX TO THE
                                ; NDX2NIBL TABLE WHICH CONTAINS
                                ; OFFSETS THAT WE WOULD BE USING
                                ; IF WE WERE ACCESSING A TABLE
                                ; OF DISK BYTES WHEN WRITING.
                                ; (IE. WE ARE JUST DOING OPPOSITE
                                ; OF WRITING.)
                                ; EOR VALUE FROM NDX2NIBL TABLE
                                ; WITH PREVIOUS EOR RESULT.  (ON
                                ; ENTRY, USE #$00 FOR PREVIOUS
                                ; EOR RESULT.)

                LDA #0          ; INITIALIZE (A) FOR LATER EORING.
RDUCY           DEY             ; REDUCE INDEX TO RWTSBUF2.
                STY PROSCRTH    ; SAVE INDEX.
RDSKBYT         LDY Q6L,X       ; (Y) = DISK BYTE.
                BPL RDSKBYT     ; WAIT FOR FULL BYTE.
                EOR NDX2NIBL-N2NOFF,Y
                                ; USE (Y) AS INDEX TO TABLE OF
                                ; 2-ENCODED NIBBLES.
                LDY PROSCRTH    ; RETRIEVE INDEX TO SECOND BUF.
                STA RWTSBUF2,Y  ; STORE 2-ENCODED NIBL N RWTSBUF2.
                BNE RDUCY       ; Z-FLG CONDITIONED FRM THE "LDY".

                                ; READ REST OF SEC INTO RWTSBUF1
                                ; ($BB00 --> $BBFF).
                                ;
                                ; USE DISK BYTE AS INDEX TO THE
                                ; NDX2NIBL TABLE WHICH CONTAINS
                                ; OFFSETS THAT WE WOULD BE USING
                                ; IF WE WERE ACCESSING A TABLE
                                ; OF DISK BYTES WHEN WRITING.
                                ; (IE. WE ARE JUST DOING OPPOSITE
                                ; OF WRITING.)
                                ; EOR VALUE FROM NDX2NIBL TABLE
                                ; WITH PREVIOUS EOR RESULT.

SAVYNDX         STY PROSCRTH    ; SAVE INDEX TO RWTSBUF1.
RDSKBYT2        LDY Q6L,X       ; (Y) = DISK BYTE.
                BPL RDSKBYT2    ; WAIT FOR FULL BYTE.
                EOR NDX2NIBL-N2NOFF,Y
                                ; GET 6-ENCODED NIBL FRM TBL.
                LDY PROSCRTH    ; GET INDEX TO RWTSBUF1.
                STA RWTSBUF1,Y  ; STORE 6-ENCODED NIBL N RWTSBUF1.
                INY
                BNE SAVYNDX     ; MORE DISK BYTES TO READ.

                                ; READ DATA CHECKSUM.

RDCHECK         LDY Q6L,X       ; GET DATA CHECKSUM BYTE FROM DSK.
                BPL RDCHECK     ; WAIT FOR FULL BYTE.
                CMP NDX2NIBL-N2NOFF,Y
                                ; DOES CONVERTED CHKSUM EQUAL
                                ; THE VALUE IN $BBFF?
                                ; REMEMBER: VAL IN $BBFF IS RESULT
                                ; OF PREVIOUS CUMMULATIVE EORING.
                                ; THERE4, THIS COMPARISON WITH (A)
                                ; DETECTS ANY (NON-CANCELLING)
                                ; ERROR(S) THAT MAY HAVE OCCURRED
                                ; IN THE ENTIRE SECTOR!!!
                BNE ERRTN       ; ERROR -DIDN'T MATCH WITH CHKSUM.
                                ; HACKERS OFTEN CHANGE THESE TWO
                                ; BYTES 2 "CLC" AND "RTS" INSTRUCS
                                ; IN ORDER TO DEFEAT DATA CHECKSUM
                                ; AND IGNORE THE DATA EPILOGUE.

                                ; READ 1RST TWO BYTES (ONLY) OF
                                ; DATA EPILOGUE ("DE AA EB").

EPIRDDE         LDA Q6L,X       ; READ 1RST BYTE OF DATA EPILOGUE.
                BPL EPIRDDE     ; WAIT FOR FULL BYTE.
                CMP #$DE        ; IS IT A "DE"?
                BNE ERRTN       ; NO - GOT AN ERROR.
                NOP             ; STALL 2 CYCLES.
EPIRDAA         LDA Q6L,X       ; READ 2ND BYTE OF DATA EPILOGUE.
                BPL EPIRDAA     ; WAIT FOR FULL BYTE.
                CMP #$AA        ; IS IT AN "AA"?
                BEQ GOODRTN     ; YES - GOT A GOOD READ.
ERRTN           SEC             ; SIGNAL BAD READ.
                RTS             ; HACKERS OFTEN CHANGE THE "SEC" 2
                                ; "CLC" TO DEFEAT ERROR CHECKING.


                                ; ====================================
                                ; READ ADDRESS ROUTINE ($B944-$B99F).
                                ; ====================================

                                ; ON ENTRY:  (X) = SLOT*16.
                                ; ON EXIT:  (C) = 1 IF ERROR.
                                ; IF NO ERRS: (A) = #$AA.
                                ; (Y) = #$00.
                                ; (X) = SLOT*16.
                                ; $2C = CHECKSUM VAL FOUND.
                                ; $2D = SEC # FOUND.
                                ; $2E = TRK # FOUND.
                                ; $2F = VOL # FOUND.

                                ; READ THE ADDRESS HEADER.

RDADDR
                IF DOS31 || DOS32
                LDY #$F8
                ELSE
                LDY #$FC        ; SET 772 CHANCES TO FIND CORRECT
                ENDIF
                STY PROSCRTH    ; ADR PROLOGUE (#$FCFC-#$10000).
KICKNTR         INY
                BNE TRYD5
                INC PROSCRTH
                BEQ ERRTN       ; ERROR - CAN'T FIND PROLOGUE.

                                ; FIND ADR PROLOGUE ("D5 AA 96").

TRYD5           LDA Q6L,X
                BPL TRYD5       ; WAIT FOR A FULL BYTE.
VERSUSD5        CMP #$D5        ; WAS IT "D5"?
                BNE KICKNTR     ; NO - TRY AGAIN.
                NOP             ; WAIT 2 CYCLES.
TRYAA           LDA Q6L,X
                BPL TRYAA       ; WAIT FOR FULL BYTE.
                CMP #$AA        ; WAS IT "AA"?
                BNE VERSUSD5    ; NO - RETRY SEQUENCE.
                LDY #3          ; SET (Y) 4 LATER READING OF VOL,
                                ; TRK, SEC & CHKSUM INFO FROM THE
                                ; ADRRESS FIELD.
TRY96           LDA Q6L,X
                BPL TRY96       ; WAIT FOR A FULL BYTE.
                IF DOS31 || DOS32
                CMP #$B5        ; WAS IT "B5"?
                ELSE
                CMP #$96        ; WAS IT "96"?
                ENDIF
                BNE VERSUSD5    ; NO - RETRY SEQUENCE.

                                ; READ ODD-EVEN ENCODED VOL, TRK,
                                ; SEC & CHECKSUM FROM ADR FIELD.
                                ; (DURING READING, CALC A RUNNING
                                ; CHECKSUM.)
                                ; FROM: BYTE1: 1  B7  1 B5  1 B3  1  B1
                                ; BYTE1: B6 1  B4 1  B2 1  B0  1
                                ; ---------------------------------
                                ; TO:   BYTE:  B7 B6 B5 B4 B3 B2 B1 B0

                LDA #0          ; INTIALIZE FOR RUNNING CHECKSUM.
CALCK           STA CKSUMCAL
GETHDR          LDA Q6L,X       ; GET ODD-ENCODED BYTE.
                BPL GETHDR      ; WAIT FOR A FULL BYTE.
                ROL A           ; SHIFT BITS, PUT (C)=1 IN BIT0.
                STA PROSCRTH    ; SAVE SHIFTED VERSION.
RDHDR           LDA Q6L,X       ; GET EVEN-CODED BYTE.
                BPL RDHDR       ; WAIT FOR A FULL BYTE.
                AND PROSCRTH    ; MERGE & CREATE NORM MEMORY BYTE.
                STA CKSUMDSK,Y  ; STORE INFO READ FROM ADDR FIELD
                                ; IN Z-PAGE:
                                ; 2F = VOL FND, 2E = TRK FND,
                                ; 2D = SEC FND, 2C = CHECKSUM FND.
                                ; (NOTE "STA:" FORCES 3-BYT CODE.)
                EOR CKSUMCAL    ; UPDATE RUNNING CHECKSUM.
                DEY
                BPL CALCK
                TAY             ; PUT CHECKSUM FOUND IN (Y).
                BNE ERRTN       ; IF CHKSUM FOUND < > 0 THEN ERR.
                                ; HACKERS OFTEN CHANGE THESE TWO
                                ; BYTES 2 "CLC" AND "RTS" INSTRUCS
                                ; IN ORDER 2 DEFEAT THE ADR CHKSUM
                                ; AND IGNORE THE ADR EPILOGUE.

                                ; READ 1RST 2 BYTES (ONLY) OF
                                ; ADDRESS EPILOGUE ("DE AA EB").

TRYEPIDE        LDA Q6L,X       ; GET 1RST BYTE.
                BPL TRYEPIDE    ; WAIT FOR A FULL BYTE.
                CMP #$DE        ; WAS IT A "DE"?
                BNE ERRTN       ; NO - TRY AGAIN.
                NOP             ; STALL 2 CYCLES.
TRYEPIAA        LDA Q6L,X       ; GET 2ND BYTE.
                BPL TRYEPIAA    ; WAIT FOR A FULL BYTE.
                CMP #$AA        ; WAS IT AN "AA"?
                BNE ERRTN       ; NO - RETRY SEQUENCE.
GOODRTN         CLC             ; SIGNAL GOOD READ.
                RTS

                IF DOS31 || DOS32
POSTNB16        LDX   #$32
                LDY   #$00
POSTNIB1        LDA   RWTSBUF2,X
                LSR   A
                LSR   A
                LSR   A
                STA   HOLDPRES
                LSR   A
                STA   PT2BTBUF
                LSR   A
                ORA   RWTSBUF1,X
                STA   (PTR2BUF),Y
                INY
                LDA   RWTSBUF2+$33,X
                LSR   A
                LSR   A
                LSR   A
                LSR   A
                ROL   HOLDPRES
                LSR   A
                ROL   PT2BTBUF
                ORA   RWTSBUF1+$33,X
                STA   (PTR2BUF),Y
                INY
                LDA   RWTSBUF2+$66,X
                LSR   A
                LSR   A
                LSR   A
                LSR   A
                ROL   HOLDPRES
                LSR   A
                ROL   PT2BTBUF
                ORA   RWTSBUF1+$66,X
                STA   (PTR2BUF),Y
                INY
                LDA   PT2BTBUF
                AND   #$07
                ORA   RWTSBUF1+$99,X
                STA   (PTR2BUF),Y
                INY
                LDA   HOLDPRES
                AND   #$07
                ORA   RWTSBUF1+$CC,X
                STA   (PTR2BUF),Y
                INY
                DEX
                BPL   POSTNIB1
                LDA   RWTSBUF2+$99
                LSR   A
                LSR   A
                LSR   A
                ORA   RWTSBUF1+$FF
                STA   (PTR2BUF),Y
                RTS
                ENDIF
                                ; ======================================
                                ; MOVE DISK ARM TO A GIVEN HALFTRACK
                                ; POSITION ($B9A0-$B9FF).
                                ; ======================================

                                ; ON ENTRY: (X) = SLOT*16
                                ; (A) = DESTINATION HALFTRK.
                                ; PRESTRK = CURRENT HALFTRK.
                                ; ON EXIT:  (A) = ?
                                ; (X) = SLOT*16.
                                ; (Y) = ?
                                ; DESTRK = FINAL HALFTRK.
                                ; PRESTRK = FINAL HALFTRK.
                                ; HOLDPRES = PREVIOUS HALFTRK.

SEEKABS
                IF !DOS31 && !DOS32
                STX SLT16ZPG    ; SAVE SLOT*16 IN ZERO PAGE.
                ENDIF
                STA DESTRK      ; SAVE DESTINATION HALFTRK#.
                CMP PRESTRK     ; DESTINATION 1/2TRK=PRES 1/2TRK?
                BEQ ARRIVED     ; YES-WE'RE ALREADY THERE, SO XIT.
                IF DOS31 || DOS32
                STX SLT16ZPG    ; SAVE SLOT*16 IN ZERO PAGE.
                ENDIF
                LDA #0          ; INIT COUNTER 4 # OF TRKS MOVED.
                STA STPSDONE

                                ; SAVE CURRENT HALFTRK POS'N AND CALC #
                                ; OF HALFTRKS NEED TO MOVE MINUS 1.

SAVCURTK        LDA PRESTRK     ; SAVE CURRENT HALFTRK POSITON.
                STA HOLDPRES
                SEC             ; CALC (PRESTRK-DESTRK).
                SBC DESTRK
                BEQ ATDESTN     ; AT DESTINATION SO GO SHUTDOWN.
                BCS MOVDOWN     ; PRES 1/2TRK > DESTINATION 1/2TRK
                                ; SO WANT 2 MOVE 2 LOWER 1/2TRK#.

                                ; WANT TO MOVE TO HIGHER HALFTRK#.
                                ; (PRESTRK - DESTRK = NEG RESULT.)

                EOR #$FF        ; CONVERT NEG TO POS.
                INC PRESTRK     ; MOVING UP,SO INC CURRENT HALFTRK
                                ; POS'N FOR NEXT TIME AROUND.
                BCC CKDLYNDX    ; ALWAYS.

                                ; WANT TO MOVE TO LOWER HALFTRK#.
                                ; (PRESTRK - DESTRK = POS RESULT.)

MOVDOWN         ADC #$FE        ; SIMULATE A SUBTRATION OF 1.
                                ; ACTUALLY ADDING MINUS 1 (#$FF)
                                ; CAUSE (C)=1.  WANT (A) TO EQUAL
                                ; 1 LESS THAN # OF HALFTRKS 2 MOV.
                DEC PRESTRK     ; MOVING DOWN, REDUCE PRES HALFTRK
                                ; NUMBER FOR NEXT TIME AROUND.

                                ; CHECK TO SEE WHICH INDEX TO USE
                                ; TO ACCESS THE DELAY TABLE.  IF
                                ; WE ARE WITHIN 12 STEPS OF THE
                                ; DESTINATION OR START POS'NS, USE
                                ; CLOSEST DISTANCE TO START OR END
                                ; POS'N TO INDEX THE DELAY TABLES.
                                ; DELAY TABLES ARE ONLY 12 BYTES
                                ; LONG, SO IF MORE THAN 12 STEPS
                                ; AWAY FROM BOTH START & DEST'N,
                                ; USE LAST INDEX (Y=12) TO ACCESS
                                ; THE TABLE.

                                ; CHECK IF CLOSER TO DEST'N OR
                                ; START POS'N.

CKDLYNDX        CMP STPSDONE    ; COMPARE # OF HALFTRKS ALREADY
                                ; MOVED VS # HALFTRKS NEED 2 MOVE.
                BCC CLSR2ND     ; CLOSER TO DEST'N THAN START.

                                ; CLOSER TO START.

                LDA STPSDONE    ; (A) = DISTANCE FROM START POS'N.

                                ; ENTRY PT IF CLOSER TO END.

CLSR2ND         CMP #12         ; ARE WE WITHIN 12 STEPS OF START
                                ; OR DESTINATION POS'N?
                IF DOS31 || DOS32
                BCC   L3A4F
                LDA   #$0B
L3A4F           TAY
                LDA   PRESTRK
                AND   #$03
                ASL   A
                ORA   SLT16ZPG
                TAX
                LDA   MAG0ON,X
                LDA   ONTABLE,Y
                JSR   DELAY
                LDA   HOLDPRES
                AND   #$03
                ASL   A
                ORA   SLT16ZPG
                TAX
                LDA   MAG0FF,X
                LDA   OFFTABLE,Y
                JSR   DELAY
                INC   $26
                BNE   SAVCURTK
ATDESTN         LDA   #$FF
                JSR   DELAY
                LDX   SLT16ZPG
ARRIVED         RTS
                ELSE
                BCS TURNON      ; WE ARE AT OR BEYOND 12 STEPS FRM
                                ; START OR DEST'N POS'N SO USE OLD
                                ; INDEX TO ACCESS DELAY TABLE.
                TAY             ; USE PRES DISTANCE 2 INDEX TABLE.
TURNON          SEC             ; (C)=1 SO GET ODD INDEX TO BASE
                                ; ADR SO MAGNET WILL BE TURNED ON.
                JSR ONOROFF     ; TURN MAGNET ON TO SUCK STEPPER
                                ; MOTOR 2 CORRECT HALFTRACK POS'N.
                LDA ONTABLE,Y   ; GET TIME TO LEAVE MAGNET ON.
                JSR DELAY       ; DELAY TO GIVE DRIVE TIME TO ACT
                                ; BEFORE MAGNET TURNED OFF AGAIN
                                ; CAUSE COMPUTER IS TOO FAST FOR
                                ; PERIPHERAL & WANT SMOOTH MOV'T.
                LDA HOLDPRES    ; (A) = LAST HALFTRK POS'N.
                CLC             ; CLR (C) SO INDEX WILL COME OUT
                                ; EVEN & THERE4 MAGNET WILL BE
                                ; TURNED OFF.
                JSR ENTRYOFF    ; TURN OFF THE MAGNET ASSOC WITH
                                ; PREVIOUS POS'N.
                LDA OFFTABLE,Y  ; GET TIME TO LEAVE MAGNET OFF.
                JSR DELAY       ; LEAVE MAGNET OFF FOR A WHILE TO
                                ; GIVE ARM TIME TO BE PROPERLY
                                ; ALIGNED.  (NEED TIME TO SUCK IT
                                ; OVER & ALSO TO DECREASE BOUNCE
                                ; OR OVER SHOOT.)
                INC STPSDONE
                BNE SAVCURTK    ; ALWAYS.


                                ; ----------------------------------
                                ; ARRIVED AT DESTINATION HALFTRACK.
                                ; ----------------------------------

ATDESTN         JSR DELAY       ; WAIT ON PERIPHERAL AGAIN.

                                ; TURN LAST-USED MAGNET OFF SO EXIT
                                ; WITH ALL PHASES (IE.MAGNETS) OFF.
                                ; NOTE:  THIS IS VERY IMPORTANT
                                ; CAUSE MAG1ON IS WIRED INTO THE
                                ; WRITE-PROTECT SWITCH!!!

                CLC             ; CLR (C) SO NDX WILL COME OUT AS
                                ; EVEN & THERE4 MAGNET WILL BE
                                ; TURNED OFF.

                                ; ---------------------------------
                                ; TURN MAGNET ON OR OFF.
                                ; ---------------------------------

ONOROFF         LDA PRESTRK     ; USE HALFTRK POS'N 2 INDEX MAGNET
ENTRYOFF        AND #%00000011  ; ONLY KEEP LWR 2 BITS OF HALFTRK#
                                ; BECAUSE ONLY 4 MAGNETS (0,1,2,3)
                ROL A           ; MULTIPLY HALFTRK * 2 & ADD (C).
                                ; IF (C)=0, RESULT EVEN, MAG OFF
                                ; IF (C)=1, RESULT ODD, MAGNET ON.
                ORA SLT16ZPG    ; MERGE INDEX 2 MAGNET WITH SLOT#.
                TAX             ; USE (X) TO INDEX MAGNET ON/OFF.
                LDA MAG0FF,X    ; USE MAGNET-0-OFF AS BASE ADR.
                LDX SLT16ZPG    ; RESTORE (X) = SLOT*16.
ARRIVED         RTS
                ENDIF

                                ; =================================
                                ; FREE SPACE ($B9FD-$B9FF).
                                ; =================================

                IF DOS33_1980
                DB $AA,$A0,$A0
                ELSE
                IF DOS33_1983 || DOS33_1986
                DS 3
                ENDIF
                ENDIF


                                ; ==================================
                                ; MAIN DELAY ROUTINE IN DOS.
                                ; AMT OF DELAY = 100*(A) MICROSECS.
                                ; ==================================

DELAY           LDX #17
DLY1            DEX
                BNE DLY1
                INC MTRTIME
                BNE DLY2
                INC MTRTIME+1
DLY2            SEC
                SBC #1
                BNE DELAY
                RTS


                                ; =================================
                                ; DELAY TIMES FOR STEPPER MOTOR
                                ; MOVEMENTS. (VALUE * 100 = DELAY
                                ; IN MICROSECONDS.)
                                ; =================================


                                ; ---------------------------------
                                ; TIMES TO LEAVE MAGNET ON.
                                ; ($BA11 - $BA1C)
                                ; ---------------------------------

ONTABLE         DB $01,$30,$28,$24,$20,$1E,$1D,$1C,$1C,$1C,$1C,$1C


                                ; ---------------------------------
                                ; TIMES TO LEAVE MAGNET OFF.
                                ; ($BA1D - $BA28)
                                ; ---------------------------------

OFFTABLE        DB $70,$2C,$26,$22,$1F,$1E,$1D,$1C,$1C,$1C,$1C,$1C


                                ; =================================
                                ; TABLE OF DISK BYTES.
                                ; ($BA29 - $BA68)
                                ; =================================

                IF !DOS31 && !DOS32
DSKNBTBL        DB $96,$97,$9A,$9B,$9D,$9E,$9F
                DB $A6,$A7,$AB,$AC,$AD,$AE,$AF
                DB $B2,$B3,$B4,$B5,$B6,$B7,$B9,$BA,$BB,$BC,$BD,$BE,$BF
                DB $CB,$CD,$CE,$CF
                DB $D3,$D6,$D7,$D9,$DA,$DB,$DC,$DD,$DE,$DF
                DB $E5,$E6,$E7,$E9,$EA,$EB,$EC,$ED,$EE,$EF
                DB $F2,$F3,$F4,$F5,$F6,$F7,$F9,$FA,$FB,$FC,$FD,$FE,$FF
                ENDIF


                                ; =================================
                                ; CHECK IF USING APPEND CMD.
                                ; (RECENT PATCH, $BA69-$BA75)
                                ; =================================

                                ; RAN OUT OF DATA SO BETTER CHECK
                                ; IF WE ARE APPENDING.

                IF DOS33_1986 || DOS33_1983
CKIFAPND        LDX NDX2CMD     ; GET COMMAND INDEX.
                CPX #$1C        ; ARE WE APPENDING?
                BEQ RTNCKAPN    ; YES - LEAVE APPEND FLAG ON.
                LDX #0          ; NO - MAKE SURE APPEND FLG OFF.
                STX APPNDFLG
RTNCKAPN        RTS


                                ; =================================
                                ; CLOBBER THE 80-COLUMN CARD.
                                ; (RECENT PATCH, $BA76-$BA83)
                                ; =================================

CONTCLOB        LDA #$FF        ; SET MODE FLAG FOR CARD.
                STA $4FB        ; SCRATCH PAD MEMORY FOR SLOT3.
                STA COL80OFF    ; TURN OFF THE ALTERNATE CHAR SET.
                STA ALTCAHR0FF
                JMP INIT        ; SIMULATE A TEXT STATEMENT.


                IF DOS33_1986
                                ; =================================
                                ; FREE SPACE
                                ; ($BA84 - $BA95)
                                ; =================================
CMPATCH         DS 16
                ELSE
                IF DOS33_1983
CMPATCH         LDA RECNMBFM
                STA FILPTBYT
                STA RECNMBWA
                TSX
                STX STKSAV
                JMP GOODFMXT
                ENDIF
                ENDIF

CMPATCHLIM      DS  2

                ELSE
                IF DOS33_1980
                DB $B3, $B3, $A0, $E0, $B3, $C3, $C5, $B3, $A0, $E0, $B3, $C3, $C5
                DB $B3, $A0, $E0, $B3, $B3, $C5, $AA, $A0, $82, $B3, $B3, $C5
                DB $AA, $A0, $82, $C5, $B3, $B3, $AA, $88, $82, $C5, $B3, $B3
                DB $AA, $88, $82, $C5, $C4, $B3, $B0, $88
                ENDIF
                ENDIF
NDX2NIBL
                IF DOS31 || DOS32
N2NOFF          EQU $A8
                DS 3
                DB $00,$01,$08,$10,$18,$02,$03,$04,$05,$06,$20,$28,$30,$07,$09,$38
                DB $40,$0A,$48,$50,$58,$0B,$0C,$0D,$0E,$0F,$11,$12,$13,$14,$15,$16
                DB $17,$19,$1A,$1B,$1C,$1D,$1E,$21,$22,$23,$24,$60,$68,$25,$26,$70
                DB $78,$27,$80,$88,$90,$29,$2A,$2B,$2C,$2D,$2E,$2F,$31,$32,$33,$98
                DB $A0,$34,$A8,$B0,$B8,$35,$36,$37,$39,$3A,$C0,$C8,$D0,$3B,$3C,$D8
                DB $E0,$3E,$E8,$F0,$F8
                ELSE
                                ; ==================================
                                ; TABLE OF BYTES USED WHEN READING.
                                ; ($BA96 - $BAFF)
                                ; - USED TO TRANSLATE A DISK BYTE
                                ; TO A 2- OR 6-ENCODED NIBBLE
                                ; NEEDED FOR THE RWTS BUFFERS).
                                ; ==================================

                                ; NUMBERS > $3F REPRESENT ILLEGAL
                                ; DISK BYTES VALUES THAT ARE SIMPLY
                                ; USED AS SPACERS IN TABLE.
                                ; mosher: note: values
                                ; $00-$3F are valid
                                ; $96-$FF are spacers
N2NOFF          EQU $96
                DB $00,$01                     ; VALID INDICES.
                DB $98,$99                     ; 2 SPACERS.
                DB $02,$03                     ; VALID INDICES.
                DB $9C                         ; 1 SPACER.
                DB $04,$05,$06                 ; VALID INDICES.
                DB $A0,$A1,$A2,$A3,$A4,$A5     ; 6 SPACERS.
                DB $07,$08                     ; VALID INDICES.
                DB $A8,$A9,$AA                 ; 3 SPACERS.
                DB $09,$0A,$0B,$0C,$0D         ; VALID INDICES.
                DB $B0,$B1                     ; 2 SPACERS.
                DB $0E,$0F,$10,$11,$12,$13     ; VALID INDICES.
                DB $B8                         ; 1 SPACER.
                DB $14,$15,$16,$17,$18,$19,$1A ; VALID INDICES.
                DB $C0,$C1,$C2,$C3,$C4,$C5     ; 6 SPACERS.
                DB $C6,$C7,$C8,$C9,$CA         ; 5 SPACERS.
                DB $1B                         ; VALID INDEX.
                DB $CC                         ; 1 SPACER.
                DB $1C,$1D,$1E                 ; VALID INDICES.
                DB $D0,$D1,$D2                 ; 3 SPACERS.
                DB $1F                         ; VALID INDEX.
                DB $D4,$D5                     ; 2 SPACERS.
                DB $20,$21                     ; VALID INDICES.
                DB $D8                         ; 1 SPACER.
                DB $22,$23,$24,$25,$26,$27,$28 ; VALID INDICES.
                DB $E0,$E1,$E2,$E3,$E4         ; 5 SPACERS.
                DB $29,$2A,$2B                 ; VALID INDICES.
                DB $E8                         ; 1 SPACER.
                DB $2C,$2D,$2E,$2F,$30,$31,$32 ; 7 INDICES.
                DB $F0,$F1                     ; 2 SPACERS.
                DB $33,$34,$35,$36,$37,$38     ; VALID INDICES.
                DB $F8                         ; 1 SPACER.
                DB $39,$3A,$3B,$3C,$3D,$3E,$3F ; VALID INDICES.

                ENDIF


                                ; =================================
                                ; BUFFER ($BB00-BBFF) OF 6-ENCODED
                                ; NIBBLES (IE. 00XXXXXX, WHERE
                                ; X = 0 OR 1, BITS 6 & 7 ARE
                                ; ALWAYS 0).
                                ; USED AS A TRANSITION BUFFER
                                ; BETWEEN NORMAL MEMORY BYTES
                                ; AND DISK BYTES.
                                ; =================================

RWTSBUF1        DS 256


                                ; ==================================
                                ; BUFFER ($BC00-$BC55) OF 2-ENCODED
                                ; NIBBLES.
                                ; ==================================

                                ; NIBBLES ARE OF THE FORM:
                                ; 0  0  JJ-0 JJ-1 KK-0 KK-1 LL-0 LL-1
                                ; WHERE BITS 6 & 7 ARE ALWAYS 0.
                                ; HOWEVER THE OTHER BITS REPRESENT
                                ; A MIXTURE OF BITS FROM DIFFERENT
                                ; ORIGINAL MEMORY BYTES.
                                ; (IE. JJ-0 REPRESENTS BIT 0 FROM
                                ; ORIGINAL MEMORY BYTE JJ.)

RWTSBUF2
                IF DOS31 || DOS32
                DS 154
                ELSE
                DS 86
                ENDIF

                IF DOS31 || DOS32
DSKNBTBL        DB $AB,$AD,$AE,$AF
                DB $B5,$B6,$B7,$BA,$BB,$BD,$BE,$BF
                DB $D6,$D7,$DA,$DB,$DD,$DE,$DF
                DB $EA,$EB,$ED,$EE,$EF
                DB $F5,$F6,$F7,$FA,$FB,$FD,$FE,$FF

                DB $1C,$1C,$1C
                DS 3
                LDY SECDSK
                LDA PHYSECTR13,Y
                LDY #5
                JMP L3E0A
FREE1
                DS 6

PHYSECTR13      DB $00,$05,$0A,$02,$07,$0C,$04,$09,$01,$06,$0B,$03,$08
                DS 35
                ELSE


                                ; ======================================
                                ; WRITE ADDRESS HEADER ($BC56-$BCC3).
                                ; (ONLY USED BY RWTS'S FORMAT COMMAND).
                                ; ======================================

                                ; ON ENTRY: (X) = SLOT*16.
                                ; (Y) = # OF SELF SYNCS
                                ; TO WRITE.
                                ; HOLDAA  = #$AA.
                                ; FRMTSEC = SEC #.
                                ; FRMTVOL = VOL #.
                                ; FRMTKCTR = TRK #.
                                ; ON EXIT:  (A) = ?
                                ; (X) = SLOT*16.
                                ; (Y) = #$00.
                                ; (C) = 0 IF NOT PROTECTED.
                                ; = 1 IF WRITE PROTECTED.

WRITADR         SEC             ; (C)=1, ASSUME ERROR AS DEFAULT.
                LDA Q6H,X       ; CHK IF DISK IS WRITE PROTECTED.
                LDA Q7L,X
                BMI SET4RD      ; BRANCH IF WRITE PROTECTED.


                                ; NOT WRITE PROTECTED SO PREP TO
                                ; WRITE A GAP OF 40-CYCLE SYNC
                                ; BYTES BTWN SECS.  (THIS ROUTINE
                                ; WRITES 2 DIF SIZES OF GAPS. GAP1
                                ; PRECEEDS SEC $00.  IT INITIALLY
                                ; CONSISTS OF 128 SELF-SYNC BYTES
                                ; BUT IS LATER PARTIALLY OVER-
                                ; WRITTEN BY SEC $0F.  GAP3 OCCURS
                                ; BTWN THE ADDR FIELD OF THE
                                ; PRECEEDING SEC & THE DATA FIELD
                                ; OF THE NEXT SEC.  ITS LENGTH
                                ; VARIES WITH THE TRK # AND THE
                                ; SPEED OF THE SPECIFIC DRIVE
                                ; BEING USED.)


                LDA #$FF        ; (A) = SYNC BYTE.
                STA Q7H,X       ; SET WRITE MODE.
                CMP Q6L,X
                PHA             ; (3 CYC)
                PLA             ; (4 CYC)
WRTSYNC         JSR WTADDRTN    ; (12 CYC)
                JSR WTADDRTN    ; (12 CYC)
                STA Q6H,X       ; (5 CYC)
                CMP Q6L,X       ; (4 CYC), WRITE BYTE.
                NOP             ; (2 CYC)
                DEY             ; (2 CYC)
                BNE WRTSYNC     ; (3 CYC ON BRNCH, 2 ON FALL THRU)

                                ; WRITE ADDRESS PROLOGUE.
                                ; ("D5 AA 96", 32-CYCLE BYTES.)

                LDA #$D5        ; (2 CYC)
                JSR WRBYTE3     ; (24 CYC BEFORE, 6 AFTER)
                LDA #$AA        ; (2 CYC)
                JSR WRBYTE3     ; (24 CYC BEFORE, 6 AFTER)
                LDA #$96        ; (2 CYC)
                JSR WRBYTE3     ; (24 CYC BEFORE, 6 AFTER)

                                ; WRITE VOL, TRK & SECTOR AS
                                ; ODD/EVEN ENCODED BYTES.
                                ; (32 CYCLES BETWEEN BYTES.)

                LDA FRMTVOL     ; (A) = VOLUME #, (3 CYC).
                JSR WRBYTE1     ; WRITE BYTES FOR VOLUME.
                                ; (JSR INSTRUCTION = 6 CYC.)
                LDA FRMTKCTR    ; WRITE BYTES FOR TRK.
                                ; (3 CYC + 6 FROM BEFORE.)
                JSR WRBYTE1     ; (6 CYC + 17 MORE CYC, WITH
                                ; 6 RESIDUAL CYC.)
                LDA FRMTSEC     ; WRITE BYTES FOR SEC.
                JSR WRBYTE1     ; (CYCLES AS PER ABOVE.)

                                ; CALCULATE ADDRESS CHECKSUM.

                LDA FRMTVOL     ; (3 CYC + 6 FROM BEFORE)
                EOR FRMTKCTR    ; (3 CYC)
                EOR FRMTSEC     ; (3 CYC)
                PHA             ; SAVE CKSUM ON STK (3 CYC).

                                ; ODD ENCODE THE ADDRESS CHECKSUM.

                LSR A           ; (2 CYC)
                ORA HOLDAA      ; (3 CYC)
                STA Q6H,X       ; (5 CYC - WRITE BYTE)
                LDA Q6L,X       ; (4 CYC)

                                ; EVEN ENCODE THE ADDRESS CHECKSUM.

                PLA             ; (3 CYC)
                ORA #%10101010  ; (2 CYC)
                JSR WRBYTE2     ; (26 CYC BEFORE WRITE, 6 AFTER)

                                ; WRITE ADDRESS EPILOGUE.
                                ; ("DE AA EB", 32-CYCLE BYTES.)

                LDA #$DE        ; (2 CYC + 6 LEFT OVER FRM B4.)
                JSR WRBYTE3     ; (24 CYC BEFORE WRITE, 6 AFTER)
                LDA #$AA        ; (2 CYC + 6 LEFT OVER FROM B4)
                JSR WRBYTE3     ; (24 CYC B4 WRITE, 6 LFT OVER)
                LDA #$EB        ; (2 CYC + 6 LEFT OVER FROM B4)
                JSR WRBYTE3     ; (24 CYC BEFORE WRITE, 6 AFTER)
                CLC
SET4RD          LDA Q7L,X       ; SET READ MODE.
                LDA Q6L,X
WTADDRTN        RTS


                                ; =================================
                                ; WRITE DOUBLE AND SINGLE BYTE
                                ; SUBR'TNS WITH DIFFERENT DELAYS.
                                ; =================================

                                ; NOTE:  A "JSR" INSTRUCTION
                                ; REQUIRES 6 CYCLES.  THEREFORE
                                ; 6 CYCLES + ANY OTHER OVERHEAD
                                ; SHOULD BE ADDED TO THE SUBRTNS
                                ; GIVEN BELOW IN ORDER TO ARRIVE
                                ; AT A 32-CYCLE COUNT BETWEEN @
                                ; BYTE WRITTEN.

WRBYTE1         PHA             ; (3 CYC)

                                ; CALC & WRITE ODD-ENCODED BYTE.

                LSR A           ; (2 CYC)
                ORA HOLDAA      ; (3 CYC)
                STA Q6H,X       ; (5 CYC)
                CMP Q6L,X       ; (4 CYC)

                                ; CALC & WRITE EVEN-ENCODED BYTE.

                PLA             ; (4 CYC)
                NOP             ; (2 CYC)
                NOP             ; (2 CYC)
                NOP             ; (2 CYC)
                ORA #$AA        ; (2 CYC)
WRBYTE2         NOP             ; (2 CYC)
WRBYTE3         NOP             ; (2 CYC)
                PHA             ; (3 CYC)
                PLA             ; (4 CYC)
                STA Q6H,X       ; (5 CYC)
                CMP Q6L,X       ; (4 CYC)
                RTS             ; (6 CYC LEFT OVER AFTER WRITE)


                                ; =================================
                                ; FREE SPACE
                                ; ($BCDF - $BCFF)
                                ; =================================
FREE1
                IF DOS33_1986 || DOS33_1983
                DS 33
                ELSE
                IF DOS33_1980

                IF FRANKLIN     ; CAM: This is the only difference in Franklin's DOS
                                ;       (well... this routine AND the patch to call this routine)
                                ; Since Franklin Ace had lower case letters, this routine
                                ; will upcase any commands the user types in before sending to DOS.
FRANK           LDA BUF200,X
                CMP #"a"|0x80
                BCC FRANK1
                CMP #"{"|0x80
                BCS FRANK1
                AND #$DF
FRANK1          RTS

                ELSE
                                ; UNUSED  GARBAGE - CONSIDER FREE.
                DB $88
                DB $A5,$E8,$91,$A0,$94,$88,$96,$E8
                DB $91,$A0,$94,$88,$96
                ENDIF
                DB $91,$91,$C8
                DB $94,$D0,$96,$91,$91,$C8,$94,$D0
                DB $96,$91,$A3,$C8,$A0,$A5,$85,$A4
                ENDIF
                ENDIF

                ENDIF







                                ; =================================
                                ; READ/WRITE TRACK/SECTOR (RWTS).
                                ; (ENTER WITH (Y)/(A) POINTING AT
                                ; RWTS'S INPUT/OUTPUT BLOCK (IOB).
                                ; =================================

RWTS
                IF DOS31 || DOS32



; TODO



                STY   PTR2IOB
                STA   PTR2IOB+1
                LDY   #$01
                LDA   (PTR2IOB),Y
                TAX
                STY   RSEEKCNT
                LDY   #$0F
                CMP   (PTR2IOB),Y
                BEQ   L3D2D
                TXA
                PHA
                LDA   (PTR2IOB),Y
                TAX
                PLA
                PHA
                STA   (PTR2IOB),Y
                LDA   Q7L,X
L3D1E           LDY   #$08
                LDA   Q6L,X
L3D23           CMP   Q6L,X
                BNE   L3D1E
                DEY
                BNE   L3D23
                PLA
                TAX
L3D2D           LDA   Q7L,X
                LDA   Q6L,X
                LDA   Q6L,X
                PHA
                PLA
                STX   SLOTPG5
                CMP   Q6L,X
                PHP
                LDA   MTRON,X
                LDY   #$06
L3D44           LDA   (PTR2IOB),Y
                STA   $0036,Y
                INY
                CPY   #$0A
                BNE   L3D44
                LDY   #$02
                LDA   (PTR2IOB),Y
                LDY   #$10
                CMP   (PTR2IOB),Y
                BEQ   L3D5E
                STA   (PTR2IOB),Y
                PLP
                LDY   #$00
                PHP
L3D5E           ROR   A
                LDA   SELDRV1,X
                BCS   L3D67
                LDA   SELDRV2,X
L3D67           ROR   DRVZPG
                LDY   #$02
                LDA   (PTR2DCT),Y
                STA   $46
                INY
                LDA   (PTR2DCT),Y
                STA   $47
                INY
                LDA   (PTR2IOB),Y
                JSR   L3E3B
                PLP
                BNE   L3D8A
L3D7D           LDY   #$12
L3D7F           DEY
                BNE   L3D7F
                INC   $46
                BNE   L3D7D
                INC   $47
                BNE   L3D7D
L3D8A           LDY   #$0C
                LDA   (PTR2IOB),Y
                BEQ   L3DE5
                CMP   #$04
                BEQ   L3DE7
                ROR   A
                PHP
                BCS   L3D9B
                JSR   PRENIBL
L3D9B           LDY   #$30
                STY   READCNTR
L3DA0           LDX   SLOTPG5
                JSR   RDADDR
                BCC   L3DC7
L3DA8           DEC   READCNTR
                BPL   L3DA0
                LDA   PRESTRK
                PHA
                LDA   #$60
                JSR   L3E82
                DEC   RSEEKCNT
                BNE   L3DDE
                LDA   #$00
                JSR   L3E3B
                PLA
L3DC1           JSR   L3E3B
                JMP   L3D9B
L3DC7           LDY   TRKDSK
                CPY   PRESTRK
                BEQ   L3DF0
                LDA   PRESTRK
                PHA
                TYA
                JSR   L3E82
                PLA
                DEC   READCNTR
                BPL   L3DC1
                BMI   L3DA8
L3DDE           PLA
                LDA   #$40
L3DE1           PLP
                JMP   L3E29
L3DE5           BEQ   L3E27
L3DE7           LDY   #$03
                LDA   (PTR2IOB),Y
                STA   VOLDSK
                JMP   L3E9C
L3DF0           LDY   #$03
                LDA   (PTR2IOB),Y
                PHA
                LDA   VOLDSK
                LDY   #$0E
                STA   (PTR2IOB),Y
                PLA
                BEQ   L3E06
                CMP   VOLDSK
                BEQ   L3E06
                LDA   #$20
                BNE   L3DE1
L3E06           LDY   #$05
                LDA   $2D
L3E0A           CMP   (PTR2IOB),Y
                BEQ   L3E17
                DEC   READCNTR
                BPL   L3DA0
                LDA   #$80
                BNE   L3DE1
L3E17           PLP
                BCC   L3E32
                JSR   READATA
                PHP
                BCS   L3DA8
                PLP
                JSR   POSTNB16
                LDX   SLOTPG5
L3E27           CLC
                DB $24 ; BIT to hide following SEC
L3E29           SEC
                LDY   #$0D
                STA   (PTR2IOB),Y
                LDA   MTROFF,X
                RTS
L3E32           JSR   WRITESEC
                BCC   L3E27
                LDA   #$10
                BCS   L3E27+2
L3E3B           PHA
                LDY   #$01
                LDA   (PTR2DCT),Y
                ROR   A
                PLA
                BCC   L3E4C
                ASL   A
                JSR   L3E4C
                LSR   PRESTRK
                RTS
L3E4C           STA   TRKDSK
                LDA   MAG0FF,X
                LDA   MAG1FF,X
                LDA   MAG2FF,X
                LDA   MAG3FF,X
                JSR   L3E7B
                LDA   PRESTRK,Y
                BIT   $35
                BMI   L3E67
                LDA   RSEEKCNT,Y
L3E67           STA   PRESTRK
                LDA   TRKDSK
                BIT   $35
                BMI   L3E75
                STA   RSEEKCNT,Y
                BPL   L3E78
L3E75           STA   PRESTRK,Y
L3E78           JMP   SEEKABS
L3E7B           TXA
                LSR   A
                LSR   A
                LSR   A
                LSR   A
                TAY
                RTS
L3E82           PHA
                LDY   #$02
                LDA   (PTR2IOB),Y
                ROR   A
                ROR   $35
                JSR   L3E7B
                PLA
                ASL   A
                BIT   $35
                BMI   L3E98
                STA   RSEEKCNT,Y
                BPL   L3E9B
L3E98           STA   PRESTRK,Y
L3E9B           RTS
L3E9C           LDA   #$80
                STA   PRESTRK
                LDA   #$00
                STA   $41
                JSR   SEEKABS
                LDA   #$AA
                STA   $4A
                LDY   #$50
L3EAE           STY   $47
                LDA   #HOLDPRES
                STA   $4B
                LDA   Q6H,X
                LDA   Q7L,X
                LDA   #$FF
                STA   Q7H,X
                CMP   Q6L,X
                BIT   $00
L3EC4           DEY
                BEQ   L3ED6
                PHA
                PLA
                NOP
L3ECA           PHA
                PLA
                NOP
                NOP
                STA   Q6H,X
                CMP   Q6L,X
                BCS   L3EC4
L3ED6           DEC   $4B
                BNE   L3ECA
                LDY   $47
                NOP
                NOP
                BNE   L3EE6
L3EE0           PHA
                PLA
                PHA
                PLA
                CMP   ($00,X)
L3EE6           NOP
L3EE7           STA   Q6H,X
                CMP   Q6L,X
                DEY
                BNE   L3EE0
                LDA   #$D5
                JSR   L3FCA
                LDA   #$AA
                JSR   L3FCB
                LDA   #$B5
                JSR   L3FCB
                LDA   VOLDSK
                JSR   L3FBB
                LDA   $41
                JSR   L3FBB
                LDA   $4B
                JSR   L3FBB
                LDA   VOLDSK
                EOR   $41
                EOR   $4B
                PHA
                LSR   A
                ORA   $4A
                STA   Q6H,X
                CMP   Q6L,X
                PLA
                ORA   #$AA
                JSR   L3FCA
                LDA   #$DE
                JSR   L3FCB
                LDA   #$AA
                JSR   L3FCB
                LDA   #$EB
                JSR   L3FCB
                LDA   #$FF
                JSR   L3FCB
                LDY   #$02
                STY   $46
                LDY   #$AD
                BNE   L3F46
L3F40           DEY
                BEQ   L3F50
                PHA
                PLA
                NOP
L3F46           PHA
                PLA
                STA   Q6H,X
                CMP   Q6L,X
                BCS   L3F40
L3F50           DEC   $46
                BNE   L3F46
                LDY   $47
                CLC
                BIT   $00
                STA   Q6H,X
                LDA   Q6L,X
                LDA   $4B
                ADC   #$0A
                STA   $4B
                SBC   #$0C
                BEQ   L3F73
                BCS   L3F6B+1
L3F6B           BIT   $4B85
                LDA   #$FF
                JMP   L3EE7
L3F73           PHA
                PLA
                LDY   $47
                LDA   Q6H,X
                LDA   Q7L,X
                BMI   L3FB3
                DEY
L3F80           PHA
                PLA
                NOP
                NOP
                BIT   $00
                PHA
                PLA
                DEY
                BNE   L3F80
                JSR   RDADDR
                BCS   L3F94
                LDA   $2D
                BEQ   L3F9E
L3F94           LDY   $47
                DEY
                CPY   #$10
                BCC   L3FB3
                JMP   L3EAE
L3F9E           INC   $41
                LDA   $41
                CMP   #$23
                BCS   L3FB8
                ASL   A
                JSR   SEEKABS
                LDY   $47
                INY
                INY
                STY   $47
                JMP   L3EAE
L3FB3           LDA   #$40
                JMP   L3E29
L3FB8           JMP   L3E27
L3FBB           PHA
                LSR   A
                ORA   $4A
                STA   Q6H,X
                CMP   Q6L,X
                PLA
                CMP   ($00,X)
                ORA   #$AA
L3FCA           NOP
L3FCB           PHA
                PLA
                NOP
                STA   Q6H,X
                CMP   Q6L,X
                RTS
L3FD5           INX
                BEQ   L3FD9
                RTS
L3FD9
                IF DOS31
                JMP   CLOSZERO
                DS    36
                ELSE
                JMP   CMDPOSN
                ENDIF




                ELSE




                STY PTR2IOB     ; SET UP A Z-PG PTR 2 RWTS'S IOB.
                STA PTR2IOB+1
                LDY #2          ; INITIALIZE CNTR FOR MAXIMUM
                STY RECLBCNT    ; NUMBER OF RECALIBRATION TRIES.
                LDY #4          ; INITIALIZE COUNTER FOR MAXIMUM
                STY RSEEKCNT    ; # OF RE-SEEKS BTW'N RECALIBS.
                LDY #1          ; (Y) = INDEX TO RWTS'S IOB.
                LDA (PTR2IOB),Y ; GET SLOT*16 FROM IOB IN (X), SO
                TAX             ; CAN USE IT TO INDEX BASE ADRS
                                ; FOR DRIVE FUNCTIONS.

                                ; CHK IF WANTED SLOT*16 = LAST SLOT*16?

                LDY #15         ; INDEX 4 VAL OF LAST SLOT USED.
                CMP (PTR2IOB),Y ; WANTED*16 VS LAST*16.
                BEQ SAMESLOT    ; SLOT WANTED=SLOT LAST ACCESSED.

                                ; WANT TO USE A DIFFERENT SLOT SO
                                ; RESET (X) BACK TO INDEX OLD SLOT
                                ; SO CAN TEST OLD MOTOR.

                TXA             ; SAVE SLOT*16 WANTED ON STK.
                PHA
                LDA (PTR2IOB),Y ; GET OLD SLOT*16 BACK.
                TAX             ; PUT IT IN (X) 2 INDEX BASE ADRS.
                PLA             ; PUT SLOT*16 WANTED IN (A) AND
                PHA             ; KEEP IT SAVED ON STK.
                STA (PTR2IOB),Y ; UPDATE LAST-USED SLOT*16 FOR
                                ; NEXT TIME AROUND.

                                ; CHECK TO SEE IF LAST-USED DRIVE
                                ; ASSOC WITH LAST-USED SLOT IS
                                ; STILL SPINNING.  IF IT IS, WAIT
                                ; FOR IT TO STOP.

                LDA Q7L,X       ; PREP LATCH FOR INPUT.
CKSPIN          LDY #8          ; SET CNTR 2 INSURE AT LEAST 8 CKS
                LDA Q6L,X       ; STROBE LATCH TO READ.
CHKCHNG         CMP Q6L,X       ; READ AGAIN & CMP TO LAST READ.
                BNE CKSPIN      ; DATA CHANGED, SO STILL SPINNING.
                DEY             ; NO CHANGE, SO CHK WITH SOME
                BNE CHKCHNG     ; DELAYS JUST TO MAKE SURE.

                                ; GET INDEX FOR SLOT WANTED.

                PLA             ; GET SLOT*16 BAK OFF STK & PUT IT
                TAX             ; IN (X) SO WE CAN NDX BASE ADRS.

                                ; CHECK TO SEE IF A DRIVE ASSOC
                                ; WITH SLOT WANTED IS STILL
                                ; SPINNING.  (AS SOON AS GET A
                                ; CHANGE, KNOW IT IS SPINNING.
                                ; IF NO CHANGE, CHK AT LEAST 8
                                ; TIMES TO BE CERTAIN IT IS OFF.)

SAMESLOT        LDA Q7L,X       ; SET READ MODE.
                LDA Q6L,X       ; STROBE LATCH TO READ.
                LDY #8          ; SET CNTR FOR 8 CHKS IF NEEDED.
STRBAGN         LDA Q6L,X       ; STROBE LATCH AGAIN.
                PHA             ; DELAY 14 MACHINE CYCLES.
                PLA
                PHA
                PLA
                STX SLOTPG5     ; SAVE SLOT*16 WANTED IN PAGE5.
                CMP Q6L,X       ; HAS DATA CHANGED YET?
                BNE DONETEST    ; YES - DATA CHANGED, SO SPINNING.
                DEY             ; NO - NO CHANGE, SEE IF CHKD
                                ; ENOUGH TIMES YET.
                BNE STRBAGN     ; CHK AT LEAST 8 TIMES.
DONETEST        PHP             ; SAVE TEST RESULTS ON STK SO CAN
                                ; LATER CHK IF NEED EXTRA DELAY
                                ; OR NOT.

                                ; TURN MOTOR ON IN A DRIVE ASSOC
                                ; WITH SLOT WANTED (JUST IN CASE
                                ; IT WASN'T ALREADY SPINNING).
                                ; NOTE:  THIS USES DRIVE WITH SAME
                                ; # AS LAST DRIVE USED.  THIS MAY
                                ; OR MAY NOT BE THE SPECIFIC DRIVE
                                ; # WE WANT.  HOWEVER, WE MUST USE
                                ; THIS INSTRUC TO SEND POWER VIA
                                ; THE CONTROLLER.  ONCE SWITCH IS
                                ; THROWN, WE CAN LATER RE-ROUTE
                                ; THAT POWER TO WHICHEVER DRIVE WE
                                ; WANT BY THROWING ANOTHER SWITCH
                                ; TO SELECT DRIVE1 OR DRIVE2.

                LDA MTRON,X     ; TURN MOTOR ON.

                                ; ESTABLISH Z-PAGE POINTERS TO
                                ; DEVICE CHARACTERISTIC TABLE &
                                ; RWTS'S I/O BUFFER (SO WE CAN
                                ; USE Z-PAGE INDIRECT ADDRESSING):
                                ; IBDCTP --> PTR2DCT (3C,3D).
                                ; IBBUFP --> PTR2BUF (3E,3F).

                LDY #6
MOVPTRS         LDA (PTR2IOB),Y ; GET PTRS FROM RWTS'S IOB.
                STA PTR2DCT-6,Y ; PUT THEM IN Z-PAGE.  (":" USED
                INY             ; 2 FORCE A 3-BYTE ZERO-PAGE ADR.)
                CPY #10         ; 4 BYTES TO COPY (6 TO 9).
                BNE MOVPTRS

                                ; CHECK DRIVE STATUS.

                LDY #3          ; SAVE HI BYTE OF MOTOR-ON-TIME
                LDA (PTR2DCT),Y ; COUNT IN Z-PAGE.
                STA MTRTIME+1
                LDY #2          ; GET DRIVE # WANTED.
                LDA (PTR2IOB),Y
                LDY #16         ; SET (Y) = INDEX 2 LAST-USED DRV.
                CMP (PTR2IOB),Y ; DRV# WANTED VS DRV# LAST USED.
                BEQ SAMEDRV
                STA (PTR2IOB),Y ; DESIGNATE DRV# WANTED AS LAST-
                                ; USED DRV# FOR NEXT TIME AROUND.
                PLP             ; GET STATUS BACK OFF STK.
                LDY #0          ; RESET STATUS (Z-FLAG OFF) TO
                                ; SIGNAL THAT SPECIFIC DRV # WE
                                ; WANT IN SPECIFIC SLOT WANTED WAS
                                ; NOT ORIGINALLY SPINNING.
                PHP             ; PUSH UPDATED STATUS BACK ON STK.
SAMEDRV         ROR A           ; PUT LOW BIT OF DRV WNTED IN (C).
                BCC USEDRV2     ; BRANCH IF WANT DRIVE 2.
                LDA SELDRV1,X   ; ROUTE POWER TO SELECT DRIVE 1.
                BCS USEDRV1     ; ALWAYS.

USEDRV2         LDA SELDRV2,X   ; ROUTE POWER TO SELECT DRIVE 2.
USEDRV1         ROR DRVZPG      ; PUT SIGN BIT FOR WHICH DRIVE
                                ; USING IN Z-PAGE:  NEG = DRIVE1.
                                ; POS = DRIVE2.

                                ; CHK TO SEE IF A SPECIFIC DRIVE
                                ; WANTED IN SPECIFIC SLOT WANTED
                                ; WAS ORIGINALLY ON OR NOT.

                PLP             ; GET PREVIOUS TEST RESULT.
                PHP             ; PUT IT BACK ON STK 4 LATER USE.
                BNE WASON       ; ORIG DRV IN ORIG SLOT WAS ON.

                                ; SPECIFIC DRIVE WANTED IN SPECIFIC
                                ; SLOT WANTED WAS ORIGINALLY OFF,
                                ; SO DELAY A BIT TO AVOID POS'NING
                                ; HEAD DURING THE PERIOD OF HEAVY
                                ; CURRENT FLOW THAT OCCURS WHEN
                                ; MOTOR IS TURNED ON.  (THAT IS,
                                ; GIVE LINE/CAPACITOR TIME TO BLEED
                                ; DOWN CAUSE MOTOR ON/OFF SWITCH
                                ; REQUIRES MORE CURRENT THAN THE
                                ; STEPPER MOTOR.)
                                ;
                                ; (AMOUNT OF DELAY IS NOT CONSTANT
                                ; CAUSE IT DEPENDS ON WHAT IS IN
                                ; ACCUMULATOR & WE DON'T KNOW
                                ; CAUSE WE WERE JUST ACCESSING
                                ; HARDWARE.)

                LDY #7
WAIT4MTR        JSR DELAY       ; STALL.
                DEY
                BNE WAIT4MTR    ; GO STALL SOME MORE.
                LDX SLOTPG5     ; RESTORE (X) = SLOT*16.
WASON           LDY #4          ; GET TRK WANTED.
                LDA (PTR2IOB),Y
                JSR SEEKTRK     ; GO MOVE ARM TO CORRECT TRK.

                                ; CHECK TO SEE IF MOTOR WAS
                                ; ORIGINALLY ON.

                PLP             ; GET EARLIER RESULT OF MOTOR TEST
                BNE BEGINCMD    ; BRANCH IF DRV WAS ORIGINALLY ON.
                LDY MTRTIME+1   ; MOTOR WASN'T ORIGNALLY ON.
                                ; HOWEVER, WE HAVE SINCE TURNED IT
                                ; ON.  NOW CHECK IF IT HAS BEEN ON
                                ; LONG ENOUGH.
                BPL BEGINCMD    ; YES -NO NEED TO WAIT ANY LONGER.

                                ; ALTHOUGH MOTOR IS TURNED ON, IT
                                ; HASN'T BEEN ON LONG ENOUGH TO DO
                                ; ACCURATE READING OF BYTES. THERE4
                                ; DELAY UNTIL MOTOR ON TIME IS ONE
                                ; SECOND (AT WHICH TIME MTRTIME
                                ; COUNT IS 0).  (PART OF TIME WAS
                                ; TAKEN UP TO SEEK TRACK.)

TIME1           LDY #18
TIME2           DEY
                BNE TIME2
                INC MTRTIME
                BNE TIME1
                INC MTRTIME+1
                BNE TIME1


                                ; =================================
                                ; MOTOR IS UP TO SPEED SO NOW
                                ; PROCESS COMMAND (SEEK=00,
                                ; READ=01, WRITE=02, FORMAT=04).
                                ; ---------------------------------

                                ; USE THE FOLLOWING COUNTERS:
                                ; READCNTR = ALLOW UP TO 48 TIMES
                                ; TO FIND CORRECT ADR
                                ; PROLOGUE BETWEEN
                                ; RE-SEEKING.
                                ; RSEEKCNT = ALLOW UP TO 4 RE-SEEKS
                                ; BTWN RECALIBRATIONS.
                                ; RECLBCNT = ALLOW UP TO 2 RECALIBRATIONS.
                                ;
                                ; (THERE4, IF NECESSARY, ALLOW UP
                                ; TO 384 ATTEMPTS TO FIND CORRECT
                                ; PROLOGUE ADDR.)

                                ; BEGIN RWTS COMMAND PROCESSING.

BEGINCMD        LDY #12         ; GET CMD FROM IOB.
                LDA (PTR2IOB),Y
                BEQ WASEEK      ; BRANCH IF CMD WAS "SEEK".
                CMP #4          ; WAS CMD "FORMAT"?
                BEQ FORMDSK     ; BRANCH IF CMD WAS  "FORMAT".


                                ; ---------------------------------
                                ; COMMAND WAS READ OR WRITE
                                ; (OPCODES $01 OR $02)
                                ; ---------------------------------

                ROR A           ; (C)=1 IF READ (OPCODE %00000001)
                                ; (C)=0 IF WRIT (OPCODE %00000010)
                PHP             ; SAVE (C) DENOTING CMD ON STK.
                BCS RESETCNT    ; READING - SO SKIP PRENIBBLING.

                                ; COMMAND WAS WRITE

WASWRITE        JSR PRENIBL     ; CONVERT 256 MEMORY BYTES TO 342
                                ; 6-BIT NIBBLES NEEDED FOR WRITING.

                                ; COMMON TO READ OR WRITE.

RESETCNT        LDY #48         ; INIT COUNT TO READ ADR HEADER.
                STY READCNTR
SETXSLT         LDX SLOTPG5     ; SET (X)=SLOT*16.
                JSR RDADDR      ; GO READ ADDR HEADER TO FIND SEC
                                ; THAT WE WANT TO READ OR WRITE.
                BCC RDRIGHT     ; ADDR READ WAS GOOD.

                                ; BAD ADDRESS (OR DATA) READ.

REDUCERD        DEC READCNTR    ; REDUCE READ COUNT.
                BPL SETXSLT     ; TRY AGAIN.

                                ; DO A RECALIBRATION CAUSE WE HAVE
                                ; EXHAUSTED ALL ATTEMPTS TO GET A
                                ; GOOD READ.

DORECALB        LDA PRESTRK     ; SAVE TRK WANTED ON STK.
                PHA
                LDA #96         ; PRETEND PRESENTLY ON TRK #96 SO
                                ; WE FORCE HEAD AGAIN STOP.
                                ; (REPEATEDLY BANGING HEAD AGAINST
                                ; STOP = FAMILIAR DISK CLATTER.)
                JSR SETTRK      ; GO SELECT DRV & PUT TRK WANTED
                                ; IN MEM LOCATION SPECIFIC 2 DRV.
                DEC RECLBCNT    ; REDUCE RECALIBRATION COUNTER.
                BEQ DRVERR      ; ERROR -EXHAUSTED RECALIBRATIONS.
                LDA #4          ; INDICATE 4 CHANCES TO RESEEK TRK
                STA RSEEKCNT    ; BETWEEN RECALIBRATIONS.
                LDA #0          ; SEEK TRACK 0.
                JSR SEEKTRK     ; GO MOVE ARM TO TRK 0.
                PLA             ; GET TRK WANTED FROM STK.
RESEEK          JSR SEEKTRK     ; NOW, MOVING OUT FROM TRK 0, TRY
                                ; TO LOCATE TRK WANTED.
                JMP RESETCNT    ; GO BACK & TRY TO DO READ AGAIN.

                                ; GOT A GOOD READ.

RDRIGHT         LDY TRKDSK      ; (Y) = TRK# FOUND IN HEADER.
                CPY PRESTRK     ; TRK FOUND = TRK WANTED?
                BEQ RTTRK       ; YES - SEEEKED TO CORRECT TRK.

                                ; BAD SEEK (OR ELSE SOME KIND
                                ; OF PROTECTION SCHEME) CAUSE
                                ; TRK WANTED < > TRK FOUND.

                LDA PRESTRK     ; SAVE TRK WANTED ON STK.
                PHA
                TYA             ; SET (A) =PRESENT TRK =TRK FOUND.
                JSR SETTRK      ; GO SELECT DRV & PUT TRK WANTED N
                                ; MEMORY LOCATION SPECIFIC TO DRV.
                PLA             ; GET TRK WANTED BACK OFF STACK.
                DEC RSEEKCNT    ; ALLOW 4 ATTEMPTS TO FIND CORRECT
                                ; TRK BETWEEN RECALIBRATIONS.
                BNE RESEEK      ; MORE ATTEMPTS LEFT TO FIND TRK.
                BEQ DORECALB


                                ; ---------------------------------
                                ; GOT A DRIVE ERROR.
                                ; ---------------------------------

DRVERR          PLA
                LDA #$40        ; ERROR CODE FOR BAD DRIVE.
TOERRWTS        PLP
                JMP RWTSERR


                                ; ---------------------------------
                                ; RWTS COMMAND WAS SEEK (NULL).
                                ; ---------------------------------

WASEEK          BEQ RWTSEXIT    ; IF CMD WAS SEEK, THEN GO EXIT
                                ; RWTS CAUSE JUST COMPLETED MOVE.


                                ; ---------------------------------
                                ; RWTS COMMAND WAS FORMAT ($04).
                                ; ---------------------------------

FORMDSK         JMP FORMAT      ; GO DO THE FORMAT.


                                ; ---------------------------------
                                ; FOUND CORRECT TRK FOR RWTS'S
                                ; READ OR WRITE COMMANDS.
                                ; ---------------------------------

RTTRK           LDY #3          ; GET VOL WANTED FROM IOB.
                LDA (PTR2IOB),Y
                PHA             ; SAVE IT ON THE STACK.
                LDA VOLDSK      ; GET VOL FOUND AND SAV IT IN IOB.
                LDY #14
                STA (PTR2IOB),Y
                PLA             ; RETRIEVE VOL WANTED OFF STK.
                BEQ CRCTVOL     ; VOLUME 0 GOOD FOR ALL.
                CMP VOLDSK      ; VOL WANTED = VOL FOUND?
                BEQ CRCTVOL     ; YES - GOT CORRECT VOL#.

                                ; GOT A VOLUME MISMATCH.

                LDA #$20        ; SET CODE FOR VOL MISMATCH.
                BNE TOERRWTS    ; ALWAYS.

                                ; FOUND CORRECT VOLUME SO NOW CHK
                                ; IF THE SECTOR IS ALSO CORRECT.

CRCTVOL         LDY #5          ; GET LOGICAL SECTOR # WANTED.
                LDA (PTR2IOB),Y
                TAY             ; SET (Y) = LOGICAL SECTOR# WANTED.
                LDA PHYSECTR,Y  ; (A) = PHYSICAL SECTOR # WANTED.
                CMP SECDSK      ; PHYS SEC WANTED=PHYS SEC FOUND?
                BNE REDUCERD    ; NO - GO TRY AGAIN.
                PLP             ; GET TYPE OF OPERATION FROM STK:
                                ; (C)=0=WRITE, (C)=1=READ.
                BCC WRITE       ; BRANCH IF RWTS OPCODE WAS WRITE.

                                ; READ DATA SEC INTO RWTS'S BUFFERS.

                JSR READATA     ; GO READ A SECTOR.
                PHP             ; SAVE STATUS OF READ ON STACK JUST
                                ; IN CASE WE NEED TO RE-READ.
                BCS REDUCERD    ; BAD READ - GO TRY AGAIN.  LEAVE
                                ; SET (C) ON STK 2 DENOTE READING.
                                ; (WE PREVIOUSLY PULLED THE SAVED
                                ; STATUS OFF THE STK.  THERE4, WE
                                ; BETTER PUT A SET (C) BACK ON STK
                                ; CAUSE WE ARE READING AND WE ARE
                                ; ABOUT 2 BRANCH BACK 2 A ROUTINE
                                ; THAT EXPECTS THE READ (C=1) OR
                                ; WRITE (C=0) FLAG ON THE STACK.
                PLP             ; GOOD READ -NOT BRANCHING BACK SO
                                ; NO NEED TO PRESERVE FLAG ON STK.

                                ; POSTNIBBLE DATA & SHUT DOWN.

                LDX #0
                STX PROSCRTH
                JSR POSTNB16    ; CONVERT 6- & 2-ENCODED BYTES IN
                                ; RWTS BUFS TO NORMAL MEMORY BYTES
                                ; (USUALLY PLACED IN DOS DATA
                                ; SECTOR BUFFER).
                LDX SLOTPG5     ; SET (X) = SLOT*16 FROM PAGE 5.


                                ; ----------------------------------
                                ; SIGNAL SUCCESS OR FAILURE
                                ; AND THEN SHUT DOWN.
                                ; ----------------------------------

                                ; SEVERAL REFERENCES ERRONEOUSLY
                                ; STATE THAT THE RETURN CODE IS
                                ; ZERO IF NO ERRORS OCCURRED.
                                ; HOWEVER, A LONE SEEK OPERATION
                                ; ALWAYS SETS THE RTN CODE TO ZERO.
                                ; EVEN IF A READ OR WRITE OPERATION
                                ; WAS SUCCESSFUL, THE IOB RTN CODE
                                ; WILL ACQUIRE A RANDOM VALUE (AS
                                ; A RESULT OF ACCESSING A HARDWARE
                                ; SWITCH PRIOR TO ENTERING THIS
                                ; ROUTINE).  THERE4, THE RTN CODE
                                ; IS ONLY RELEVANT IF AN ERROR IS
                                ; DENOTED (CARRY SET).

RWTSEXIT        CLC             ; (C)=0, SIGNL SUCCESSFUL OPERAT'N
                DB $24          ; "BIT $38" 2 IGNORE "SEC" INSTRUC
RWTSERR         SEC             ; (C)=1, SIGNL UNSUCCESSFUL OPER'N
                LDY #13         ; STORE RETURN CODE IN IOB.
                STA (PTR2IOB),Y
                LDA MTROFF,X    ; TURN MOTOR OFF.
                RTS


                                ; ---------------------------------
                                ; WRITE SECTOR.
                                ; ---------------------------------

WRITE           JSR WRITESEC    ; WRITE SYNC GAP AFTR ADR EPILOGUE
                                ; & THEN WRITE DATA PROLOGUE, DATA
                                ; PROPER AND DATA EPILOGUE.
                BCC RWTSEXIT    ; GOOD WRITE - GO EXIT.
                LDA #$10        ; WRITE PROTECT ERROR CODE.
                BCS RWTSERR     ; BAD WRITE - HANDLE THE ERROR.


                                ; =================================
                                ; DETERMINE DRIVE TYPE & MOVE
                                ; DISK ARM TO DESIRED TRK.
                                ; =================================

SEEKTRK         PHA             ; SAVE # OF TRK WANTED ON STK.
                LDY #1          ; GET DRIVE TYPE (EVEN VAL=2PHASE,
                LDA (PTR2DCT),Y ; ODD VAL=1PHASE) FROM DCT.
                                ; (PS. THE "II" IN THE "DISK II"
                                ; LOGO STAMPED ON APPLE'S DISK
                                ; DRIVE DENOTES A 2-PHASE MOTOR.)
                ROR A           ; PUT LOW BYTE OF DRV TYPE IN (C).
                PLA             ; GET TRK# WANTED BACK IN (A).
                BCC SEEKIT      ; NOT USING STANDARD DRIVE II,
                                ; USING A ONE-PHASE DRIVE INSTEAD,
                                ; THERE4 SKIP DOUBLING OF TRK# AND
                                ; USE SEEKIT AS PART OF ROUTINE
                                ; INSTEAD OF AS A SEPERATE SUBRTN.

                                ; USING A TWO-PHASE DRIVE.

                ASL A           ; 2*TRK# WANTED=1/2TRACK# WANTED.
                JSR SEEKIT      ; MOVE THE DISK ARM 2 DESIRED TRK.
                LSR PRESTRK     ; CONVERT HALFTRACK VALUE BACK TO
                RTS             ; WHOLE TRACK VALUE.


                                ; =====================================
                                ; ROUTINE/SUBROUTINE TO MOVE DRIVE
                                ; ARM TO A SPECIFIC TRK POS'N.
                                ; =====================================

                                ; USED AS A SUBROUTINE WHEN USING
                                ; APPLE'S DISK DRIVE II.  NOTE WHEN
                                ; SEEKIT IS USED AS A SUBROUTINE,
                                ; DESTRK, PRESTRK, TRK4DRV1, TRK4DR2,
                                ; STPSDONE AND HOLDPRES ARE ALL
                                ; EXPRESSED IN TERMS OF HALFTRACKS:
                                ; DESTRK = DESTINATION HALF-TRACK POS'N.
                                ; PRESTRK = PRESENT HALF-TRACK POS'N.
                                ; HOLDPRES = PRESENT HALF-TRACK POS'N.
                                ; TRK4DRV1 = BASE ADR (INDEXED BY SLOT*16)
                                ; TO POINT TO THE ADR THAT
                                ; CONTAINS THE LAST HALF-
                                ; TRACK # THAT DRIVE1 WAS
                                ; ALIGNED ONE.
                                ; TRK4DRV2 = BASE ADR (INDEXED BY SLOT*16)
                                ; TO POINT TO THE ADR THAT
                                ; CONTAINS THE LAST HALF-
                                ; TRACK # THAT DRIVE2 WAS
                                ; ALIGNED ON.
                                ; STPSDONE = NUMBER OF HALFTRACKS
                                ; MOVED SO FAR.
                                ; (NOTE:  IF NOT USING A II-PHASE
                                ; DRIVE, CHANGE ALL THE COMMENTS
                                ; BELOW THAT REFER TO HALFTRACKS
                                ; TO REFER TO FULLTRACKS INSTEAD.)

SEEKIT          STA DESTRK      ; (A) = HALFTRACK# WANTED.
                JSR SLOTX2Y     ; CONVERT (X)=SLOT*16-->(Y)=SLOT.
                LDA TRK4DRV1,Y  ; PRES HALFTRK # ASSOC WITH DRV1.
                BIT DRVZPG      ; CONTAINS:  NEG=DRV1, POS=DRV2.
                BMI SETPRSTK    ; BRANCH IF USING DRIVE1.
                LDA TRK4DRV2,Y  ; USING DRIVE2 SO GET PRESENT
                                ; HALFTRACK # ASSOC WITH DRIVE 2.
SETPRSTK        STA PRESTRK     ; SAVE PRESENT HALFTRK#.

                                ; DESIGNATE HALFTRK WE ARE ABOUT
                                ; TO SEEK AS PRESENT HALFTRK FOR
                                ; NEXT TIME AROUND.  (PUT HALFTRK
                                ; INFO IN SLOT-DEPENDENT LOCATIONS.)

                LDA DESTRK      ; HALFTRK WANTED.
                BIT DRVZPG      ; CHK WHICH DRIVE WE'RE USING.
                BMI DRV1USG     ; BRANCH IF USING DRIVE 1.
                STA TRK4DRV2,Y  ; USING DRIVE2 -STORE HALFTRK INFO
                                ; FOR NEXT TIME AROUND.
                BPL DRV2USG     ; ALWAYS.

DRV1USG         STA TRK4DRV1,Y  ; USING DRIVE1. STORE HALFTRK INFO
                                ; FOR NEXT TIME AROUND.
DRV2USG         JMP SEEKABS     ; GO MOVE DRIVE ARM.


                                ; ===================================
                                ; TRANSLATE (X)=SLOT*16 TO (Y)=SLOT.
                                ; ===================================

SLOTX2Y         TXA             ; GET SLOT*16 FROM (X).
                LSR A           ; DIVIDE IT BY 16.
                LSR A
                LSR A
                LSR A
                TAY             ; PUT SLOT# IN (Y).
                RTS


                                ; =================================
                                ; GO SELECT DRIVE AND PUT TRACK #
                                ; WANTED IN MEMORY LOCATION ASSOC
                                ; WITH THE # OF THE DRIVE WE'RE
                                ; USING.
                                ; =================================

SETTRK          PHA             ; SAVE PRESENT TRK # ON STK.
                LDY #2          ; GET DRV # WANTED FROM IOB.
                LDA (PTR2IOB),Y
                ROR A           ; CONDITION CARRY:
                                ; (C)=0=DRV1, (C)=1=DRV2.
                ROR DRVZPG      ; CONDITION ZERO-PAGE LOCATION:
                                ; NEG=DRV1, POS=DRV2.
                JSR SLOTX2Y     ; USE (X)=SLOT*16 TO GET (Y)=SLOT.
                PLA             ; GET TRK # WANTED OFF STK.
                ASL A           ; TIMES TWO FOR 1/2TRACK # WANTED.
                BIT DRVZPG      ; CHK WHICH DRIVE TO USE.
                BMI STORDRV1    ; BRANCH IF USING DRIVE 1.
                STA TRK4DRV2,Y  ; SAV HALFTRK # WANTED FOR DRIVE2.
                BPL RTNSETRK    ; ALWAYS.
STORDRV1        STA TRK4DRV1,Y  ; SAVE HALFTRK # WANTED 4 DRIVE1.
RTNSETRK        RTS


                                ; =================================
                                ; RWTS'S FORMAT COMMAND.
                                ; =================================

                                ; INITIALIZE ZERO-PAGE LOCATIONS.

FORMAT          LDY #3          ; GET VOL FRM IOB, STORE IN Z-PAGE.
                LDA (PTR2IOB),Y
                STA FRMTVOL
                LDA #$AA        ; STORE "AA" AS CONSTANT IN Z-PAGE.
                STA HOLDAA
                LDY #$56        ; INITIALIZE INDEX TO BUFFER.
                LDA #0          ; INITIALIZE TRK COUNTER.
                STA FRMTKCTR    ; NOTE:  ALWAYS BEGIN FORMATTING
                                ; WITH TRACK $00.

                                ; ZERO OUT THE RWTS BUFFERS.
                                ; (NOTE:  WHEN FORMATTING, THESE
                                ; "$00" BUFFER BYTES WILL LATER BE
                                ; TRANSLATED AND WRITTEN TO THE
                                ; DISK AS "$96" DISK BYTES.)

                                ; ZERO OUT RWTS BUFFER THAT NORMALLY
                                ; CONTAINS 2-ENCODED NIBBLES.
                                ; (RWTSBUF2, $BC00 <--- $BC55.)

ZBUF2           STA RWTSBUF1+$FF,Y
                                ; ($BC55 --> $BC00.)
                DEY
                BNE ZBUF2

                                ; ZERO OUT RWTS BUFFER THAT NORMALLY
                                ; CONTAINS 6-ENCODED NIBBLES.
                                ; (RWTSBUF1, $BB00 ---> $BBFF.)

ZBUF1           STA RWTSBUF1,Y
                DEY
                BNE ZBUF1

                                ; PREPARE TO DO A RECALIBRATION.

                LDA #80         ; PRETEND WE'RE ON TRK #80.
                JSR SETTRK      ; GO SELECT DRV & PUT HALFTRACK #
                                ; WANTED IN MEMORY LOCATION ASSOC
                                ; WITH THE # OF DRV BEING USED.
                LDA #40         ; SET UP FOR 40 SYNCS BTWN SECS
                STA SYNCNTR     ; ON TRK0.  NOTE THAT THIS # WILL
                                ; LATER BE REDUCED AS WE WRITE
                                ; SUBSEQUENT TRKS.(HIGHER NUMBERED
                                ; TRKS ARE CLOSER TO THE CENTER OF
                                ; THE DSK & THERE4 ARE REPRESENTED
                                ; BY SMALLER CIRCLES. WE CAN CROWD
                                ; ALL THE SECS INTO A SMALLER
                                ; CIRCUMFERENCE BY REDUCING THE #
                                ; OF SYNC BYTES BETWEEN SECS.

                                ; FORMAT THE NEXT TRACK.

FRMNXTRK        LDA FRMTKCTR    ; USE TRK COUNTER AS TRK TO SEEK.
                JSR SEEKTRK     ; POS'N ARM OVER CORRECT TRK.

                                ; GO FORMAT A SPECIFIC TRACK.

                JSR FORMATRK    ; FORMAT A TRACK.
                LDA #8          ; SET (A) AS DEFAULT VALUE IN CASE
                                ; COULDN'T FORMAT.  NOTE THAT ANY
                                ; TYPE OF ERROR ENCOUNTERED WHEN
                                ; FORMATTING YEILDS AN I/O-ERROR
                                ; MESSAGE.
                BCS ERRFRMT     ; BRANCH IF COULDN'T FORMAT.

                                ; DO A READ CHK OF TRK JUST FORMATTED.
                                ; (EVENTHOUGH TRACK VERIFIED, READ
                                ; IT AGAIN UNTIL LOCATE TRK0.
                                ; (PRESUMABLY, THIS (PARTIALLY)
                                ; DOUBLE CHECKS VERIFICATION AND
                                ; KEEPS SECTORS IN DIFFERENT TRACKS
                                ; SOMEWHAT ADJACENT?)

                LDA #48         ; SET 48 ATTEMPTS TO READ.
                STA READCNTR
RDAGAIN         SEC             ; DEFAULT (C)=1 TO SIGNAL ERROR.
                DEC READCNTR    ; REDUCE CHANCES TO READ.
                BEQ ERRFRMT     ; EXHAUSTED ALL CHANCES.
                JSR RDADDR      ; GO READ ADDR HEADER TO FIND SEC
                                ; THAT WE WANT TO READ OR WRITE.
                BCS RDAGAIN     ; BAD READ - TRY AGAIN.
                LDA SECDSK      ; WAS IT SECTOR 0?
                BNE RDAGAIN     ; NO - TRY AGAIN.
                JSR READATA     ; LAST CHANCE TO READ DATA.
                BCS RDAGAIN     ; LAST CHANCE BOMBED OUT!!!
                INC FRMTKCTR    ; KICK UP TRK COUNTER.
                LDA FRMTKCTR    ; SET (A) FOR NEXT TRK COUNT.
                CMP #$23        ; DONE ALL TRACKS YET (#0 TO #34)?
                BCC FRMNXTRK    ; NO - GO FORMAT THE NEXT TRACK.
                CLC             ; SIGNAL FINISHED ALL TRACKS.
                BCC DONEFRMT    ; ALWAYS - ONLY GOOD EXIT.

                                ; NOTE:  NO MATTER WHAT KIND OF ERROR
                                ; WE MIGHT HAVE ENCOUNTERED WHEN
                                ; FORMATTING, THE IOB ERROR CODE IS
                                ; SET TO $08.  THIS IS LATER TRANSLATED
                                ; TO AN FM ERROR CODE (ALSO $08) WHICH
                                ; DOS DISPLAYS AS AN I/O ERROR MSG.
                                ; (THIS IS WHY TRYING TO FORMAT A
                                ; WRITE-PROTECTED DISK RESULTS IN AN
                                ; I/O ERROR MSG INSTEAD OF A DISK-
                                ; WRITE-PROTECTED MSG.)
                                ; IF NO ERROR OCCURRED, THE IOB RETURN
                                ; CODE WILL BE SET TO SOME RANDOM
                                ; NUMBER (FROM REFERENCING A HARD-
                                ; WARE SWITCH ADDRESS).

ERRFRMT         LDY #13         ; INDEX TO RETURN CODE IN IOB.
                STA (PTR2IOB),Y ; STORE RETURN CODE.
                SEC             ; SIGNAL THAT AN ERROR OCCURRED.
DONEFRMT        LDA MTROFF,X    ; TURN THE MOTOR OFF, XIT WITH (C)
                RTS             ; DENOTING SUCCESS STATUS.


                                ; ------------------------------------
                                ; SUBROUTINE 2 FORMAT A SPECIFIC TRK.
                                ; ------------------------------------

                                ; SECTORS ARE WRITTEN IN ASCENDING
                                ; ORDER FROM SEC $00 TO SEC $0F.
                                ; (NOTE THAT THE FORMAT ROUTINE ONLY
                                ; DEALS WITH PHYSICAL SECTOR NUMBERS.)

FORMATRK        LDA #0          ; ALWAYS START WITH SEC $00.
                STA FRMTSEC
                LDY #128        ; USE 128 SYNC BYTS BEFORE SEC$00.
                                ; NOTE: THIS GAP WILL BE PARTIALLY
                                ; OVERWRITTEN BY SEC $0F.
                BNE DOADDR      ; ALWAYS.

FRMTASEC        LDY SYNCNTR     ; SET (Y)= # OF 40-CYCLE SELF-SYNC
                                ; BYTES TO BE WRITTEN BTWN SECS.
                                ; (THIS # VARIES DEPENDING ON THE
                                ; SPEED OF THE SPECIFIC DRV BEING
                                ; USED & THE # OF THE TRK BEING
                                ; WRITTEN.)
DOADDR          JSR WRITADR     ; WRITE SYNC BYTES & ADDR HEADER.

                BCS VRFYRTN     ; ERROR -DISK WAS WRITE PROTECTED.
                JSR WRITESEC    ; WRITE SYNC GAP BTWN ADDR & DATA
                                ; FIELDS, WRT DATA & WRITE A SYNC
                                ; BYTE AFTER DATA EPILOGUE.
                BCS VRFYRTN     ; IRRELEVANT - NEVER TAKEN BECAUSE
                                ; WE ALREADY CHECKED THE WRITE-
                                ; PROTECT SWTCH WHEN WE WROTE ADR.
                INC FRMTSEC     ; INCREASE SEC #.
                LDA FRMTSEC
                CMP #$10        ; DONE ALL 16 SECS YET?
                BCC FRMTASEC    ; NO - GO DO SOME MORE.


                                ; ......................................
                                ; VERIFY A SINGLE TRACK.
                                ; ......................................

                                ; NOTE WE JUST FINISHED FORMATTING
                                ; SEC $0F.  BECAUSE SEC $0F SHOULDN'T
                                ; OVERWRITE TOO MUCH OF OF THE SYNC GAP
                                ; (ORIGINALLY 128 SYNC LONG) THAT WAS
                                ; WAS WRITTEN PRIOR TO SEC $00, AND BECAUSE
                                ; WE DON'T WASTE TOO MUCH TIME BETWEEN
                                ; WRITING THE LAST BYTE OF SEC $0F AND
                                ; LOOKING FOR THE NEXT ADDR HEADER,
                                ; WE EXPECT TO BEGIN OUR VERIFICATION
                                ; WITH SEC $00.


                                ; INTIALIZE COUNTERS.

                LDY #$0F        ; SET COUNTER 4 # OF SECS VERIFIED
                STY FRMTSEC
                LDA #48         ; SET COUNTER FOR # OF ATTEMPTS.
                STA READCNTR

                                ; FILL SECTOR MAP WITH POSITIVE NUMBERS.

FILSECMP        STA SECFLGS,Y
                DEY
                BPL FILSECMP

                                ; DELAY TO LET SOME SYNCS PASS BY.

                LDY SYNCNTR     ; INITIALIZE  (Y).
BYPSYNCS        JSR VRFYRTN     ; (12 CYC)
                JSR VRFYRTN     ; (12 CYC)
                JSR VRFYRTN     ; (12 CYC)
                PHA             ; (3 CYC)
                PLA             ; (4 CYC)
                NOP             ; (2 CYC)
                DEY             ; (2 CYC)
                BNE BYPSYNCS    ; (3 CYC ON BRNCH, 2 ON FALL THRU)

                                ; READ ADDRESS OF FIRST SEC ENCOUNTERED.
                                ; (THIS BETTER BE SEC $00!!!!  IF IT
                                ; ISN'T, OUR DRIVE IS TOO FAST & WE
                                ; WILL EVENTUALLY HAVE TO REFORMAT
                                ; THE TRACK.)

                JSR RDADDR      ; READ ADR OF 1RST SEC ENCOUNTERED
                BCS REREADDR    ; BAD READ, TRY AGAIN.
                LDA SECDSK      ; WAS SEC READ = SEC00?
                BEQ RDNXTDAT    ; YES - GO READ NEXT DATA SEC.

                                ; DIDN'T FIND SECTOR $00 WHEN EXPECTED!!!!

                                ; DRIVE MUST BE FASTER THAN ANTICIPATED
                                ; CAUSE SEC $0F OVERLAID TOO MUCH OF
                                ; THE LONG SYNC GAP (GAP1) THAT WAS
                                ; ORIGINALLY WRITTEN BEFORE SEC $00.
                                ; WE WILL EVENTUALLY HAVE TO REFORMAT
                                ; THIS TRK USING 128 SELF-SYNCS BEFORE
                                ; SEC $00 (GAP1) AND LESS SYNC BYTES
                                ; BETWEEN OTHER SECS (GAP3).  THIS
                                ; WILL INSURE THAT LESS GAP-1 SYNCS
                                ; WILL BE OVERWRITTEN BY SEC $OF.
                                ; NOTE THAT DEPENDING ON JUST HOW
                                ; MUCH TOO FAST THE DRIVE IS, WE MAY
                                ; HAVE TO REFORMAT THIS TRK SEVERAL
                                ; TIMES BEFORE WE GET IT RIGHT.  EACH
                                ; TIME WE REFORMAT, WE REDUCE THE #
                                ; OF GAP-3 SYNCS.  IF THE SYNC COUNTER
                                ; IS > = 16, WE WRITE 2 LESS SYNCS.
                                ; IF THE COUNTER IS < 16, WE ONLY REDUCE
                                ; GAP-3 BY ONE SYNC.  IN ORDER TO GIVE
                                ; THE MACHINE TIME TO DECODE INFO, WE
                                ; WON'T ALLOW A GAP LESS THAN 5 SYNCS
                                ; LONG.  (NOTE THAT WE WON'T REFORMAT
                                ; THE TRACK UNTIL WE FIND THE ADR HEADER
                                ; FOR SEC $0F.  THIS PRESUMABLY KEEPS
                                ; LIKE-NUMBERED SECS IN ADJACENT TRKS
                                ; IN SOME SEMBLANCE OF ORDER.)

                LDA #16
                CMP SYNCNTR     ; CONDITION CARRY.
                LDA SYNCNTR     ; IF SYNC COUNT < 16, SUBTRACT 1,
                SBC #1          ; ELSE SUBTRACT 2.
                STA SYNCNTR
                CMP #5          ; DO WE HAVE AT LEAST 5 SYNCS?
                BCS REREADDR    ; YES.
                SEC             ; NO - SIGNAL ERROR CAUSE NEED AT
                RTS             ; LEAST 5 SYNCS.  DRIVE IS SO FAST
                                ; ===             ;THAT IT IS USELESS.  WE CAN'T
                                ; EVEN COMPENSATE 4 IT BY REDUCING
                                ; THE NUMBER OF GAP-3 SYNCS.

                                ; READ THE SEC ADDR & DATA PROPER.

RDNXTADR        JSR RDADDR      ; READ THE ADDR HEADER.
                BCS BADREAD     ; BRANCH IF BAD ADDRESS READ.
RDNXTDAT        JSR READATA     ; READ THE DATA PROPER.
                BCC CKSECMAP    ; READ WAS GOOD -SO GO CHK IF THIS
                                ; SEC HAS ALREADY BEEN READ.

BADREAD         DEC READCNTR    ; EITHER GOT A BAD READ OR ELSE
                                ; WE ALREADY VERIFIED THIS SEC.
                                ; REDUCE THE # OF CHANCES LEFT.
                BNE RDNXTADR    ; MORE CHANCES LEFT -GO TRY AGAIN.

                                ; DOING A RE-READ.  WILL DEFINITELY
                                ; HAVE TO REFORMAT.

REREADDR        JSR RDADDR      ; READ AN ADDR HEADER.
                BCS NOTLAST     ; GOT A BAD READ.

                                ; WE WILL REFORMAT BUT WE DON'T WANT
                                ; TO DO SO UNTIL WE READ SEC $0F.

                                ; HAVE WE FOUND SEC $0F YET?

                LDA SECDSK      ; GET PHYS # OF SEC JUST READ.
                CMP #$0F        ; WAS IT SEC 15?
                BNE NOTLAST     ; NO, SO GO LOOK SOME MORE.
                JSR READATA     ; YES - READ THE DATA IN SEC $0F.
                BCC FORMATRK    ; GOOD READ ON SEC15 SO NOW TIMING
                                ; IS RIGHT TO GO REFORMAT THIS TRK
NOTLAST         DEC READCNTR    ; BAD READ, CK IF MORE CHANCES LFT
                BNE REREADDR    ; YES - GO TRY AGAIN.
                SEC             ; EXHAUSTED ALL CHANCES, SO SET
VRFYRTN         RTS             ; (C) AS ERROR FLAG & EXIT.
                                ; ===

                                ; CHECK IF THIS SEC WAS PREVIOUSLY
                                ; VERIFIED.  IF NOT, UPDATE SECTOR
                                ; VERIFICATION MAP.  (IF TIMING IS
                                ; RIGHT, SHOULD NEVER ENCOUNTER AN
                                ; ALREADY VERIFIED SEC BEFORE FRMTSEC
                                ; DECREMENTS FROM $0F DOWN TO $FF.)

CKSECMAP        LDY SECDSK      ; USE # OF SEC FOUND AS INDEX TO
                                ; THE VERIFICATION MAP.
                LDA SECFLGS,Y   ; GET MAP BYT (NEG=PREV VERIFIED).
                BMI BADREAD     ; OH!OH! ALREADY VERIFIED THIS ONE
                LDA #$FF        ; SET BYTE IN MAP TO SIGNAL THAT
                STA SECFLGS,Y   ; THIS SEC WAS JUST VERIFIED.
                DEC FRMTSEC     ; ANY SECS LEFT TO VERIFY?
                BPL RDNXTADR    ; YES - GO DO SOME MORE.

                                ; ALL SECS VERIFIED, SO CHECK
                                ; IF WE JUST DID TRACK $00.

                LDA FRMTKCTR    ; WAS TRK JUST FORMATTED =TRK $00?
                BNE NOTRK0      ; NO - SO EXIT CLEANLY.

                                ; JUST FORMATTED & VERIFIED TRK $00.
                                ; TRK $00 IS THE OUTSIDE TRK AND THERE4
                                ; HAS THE LARGEST LENGTH IN WHICH TO
                                ; WRITE BYTES.  BECAUSE SUBSEQUENT
                                ; TRKS HAVE A SMALLER CIRCUMFERENCE,
                                ; WE MUST REDUCE THE NUMBER OF SYNCS
                                ; TO WRITE BETWEEN SECS (GAP3) SO WE
                                ; CAN GET ALL THE NEEDED INFO INTO
                                ; A SMALLER SPACE.

                LDA SYNCNTR     ; CHECK SYNC COUNT.
                CMP #16         ; LESS THAN 16 SYNCS?
                BCC VRFYRTN     ; YES - EXIT CLEANLY.
                                ; DON'T WANT TO START OFF WITH A
                                ; SMALLER GAP SO SKIP CODE BELOW.

                                ; REDUCE THE SIZE OF GAP3.

                DEC SYNCNTR     ; GAP > = 16 SYNCS LONG, SO CAN
                DEC SYNCNTR     ; AFFORD 2 REDUCE IT BY 2 IN ORDER
NOTRK0          CLC             ; TO ACCOMMODATE A TIGHTER TRACK.
                RTS             ; EXIT CLENALY.


                                ; =================================
                                ; FLAGS FOR SECTOR VERIFICATION.
                                ; ($BFA8 - $BFB7)
                                ; - NEG VAL = SECTOR VERIFIED.
                                ; - TABLE IS INDEXED BY (Y),
                                ; WHERE (Y) = SECTOR NUMBER.
                                ; =================================
SECFLGS         DB $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
                DB $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF


                                ; =================================
                                ; PHYSICAL SECTOR NUMBERS
                                ; ($BFB8 - $BFC7)
                                ; - LISTED IN LOGICAL ORDER.
                                ; =================================

                                ; CORRESPONDING LOGICAL SECTOR#.
PHYSECTR        DB $00          ; 00
                DB $0D          ; 01
                DB $0B          ; 02
                DB $09          ; 03
                DB $07          ; 04
                DB $05          ; 05
                DB $03          ; 06
                DB $01          ; 07
                DB $0E          ; 08
                DB $0C          ; 09
                DB $0A          ; 0A
                DB $08          ; 0B
                DB $06          ; 0C
                DB $04          ; 0D
                DB $02          ; 0E
                DB $0F          ; 0F


                                ; =================================
                                ; CLOBBER THE LANGUAGE CARD.
                                ; ($BFD9 - $BFDB)
                                ; - PATCH CALLED BY BOOT2.
                                ; =================================

CLOBCARD        JSR SETVID      ; SIMULATE A "PR#0" STATEMENT.
                LDA RROMWRAMD2  ; WRITE ENABLE RAM CARD.
                LDA RROMWRAMD2  ; (READ MOTHER/WRITE CARD BANK2.)
                LDA #0          ; SET LANGUAGE IDENTIFYING BYTE ON
                STA BASICCLD    ; CARD TO $00 SO IF CARD IS TESTED
                                ; (DURING AN "FP" CMD), THE
                                ; MACHINE WILL BE FORCED TO USE
                                ; MOTHERBOARD VERSION OF FP.

                IF DOS33_1986 || DOS33_1983
                JSR CONTCLOB    ; NOW CLOBBER THE 80-COLUMN CARD.
                ENDIF
                JMP BK2BOOT2    ; RTN TO ORIGINAL PART OF BOOT2.
                IF DOS33_1980
                DS 3
                ENDIF

                ENDIF

                IF !DOS31
                                ; ===================================
                                ; PATCH TO ZERO ADDED STORAGE BYTES.
                                ; ($BFDC - $BFE5)
                                ; ===================================

ZEROPTCH        STA TEMPBYT
                STA BYTPRSD
                STA BYTPRSD+1
                RTS


                                ; =================================
                                ; PATCH TO SET CONDITION 0 AND
                                ; CLEAR THE RUN INTERRUPT FLAG.
                                ; ($BFE6 - $BFEC)
                                ; =================================

RESTATIN        JSR RESTAT0     ; ZERO OUT CONDNFLG & OPUTCOND.
                STY RUNTRUPT    ; CLR THE RUN INTERRUPT FLAG.
                RTS


                                ; =================================
                                ; DISK-FULL ERROR PATCH.
                                ; ($BFED - $BFFF)
                                ; =================================

FULLPTCH        JSR CPYFMWA     ; COPY FM WRK AREA--->FM WRK BUF.
                LDX STKSAV      ; RESTORE STACK POINTER.
                TXS
                JSR CLOSEALL    ; CLOSE ALL FILES.
                TSX
                STX STKSAV      ; SAVE STACK POINTER.
                LDA #9          ; EXIT WITH DISK-FULL ERROR CODE.
                JMP BADFMXIT

                ENDIF

DOSLIM
                                ; ********************************
                                ; END OF DOS
                                ; ********************************
