Load and Store

Load Accumulator with Memory: LDA

M -> A

Flags: N, Z
Addressing Mode 	Opcode
LDA a 	AD
LDA a,x 	BD
LDA a,y 	B9
LDA # 	A9
LDA zp 	A5
LDA (zp,x) 	A1
LDA zp,x 	B5
LDA (zp),y 	B1

Load Index X with Memory: LDX

M -> X

Flags: N, Z
Addressing Mode 	Opcode
LDX a 	AE
LDX a,y 	BE
LDX # 	A2
LDX zp 	A6
LDX zp,y 	B6

Load Index Y with Memory: LDY

M -> Y

Flags: N, Z
Addressing Mode 	Opcode
LDY a 	AC
LDY a,x 	BC
LDY # 	A0
LDY zp 	A4
LDY zp,x 	B4

Store Accumulator in Memory: STA

A -> M

Flags: none
Addressing Mode 	Opcode
STA a 	8D
STA a,x 	9D
STA a,y 	99
STA zp 	85
STA (zp,x) 	81
STA zp,x 	95
STA (zp),y 	91

Store Index X in Memory: STX 

X -> M

Flags: none
Addressing Mode 	Opcode
STX a 	8E
STX zp 	86
STX zp,y 	96

Store Index Y in Memory: STY 

Y -> M

Flags: none
Addressing Mode 	Opcode
STY a 	8C
STY zp 	84
STY zp,x 	94

[edit] Arithmetic

Add Memory to Accumulator with Carry: ADC 

A + M + C -> A

Flags: N, V, Z, C
Addressing Mode 	Opcode
ADC a 	6D
ADC a,x 	7D
ADC a,y 	79
ADC # 	69
ADC zp 	65
ADC (zp,x) 	61
ADC zp,x 	75
ADC (zp),y 	71

Subtract Memory from Accumulator with Borrow: SBC 

A - M - ~C -> A

Flags: N, V, Z, C
Addressing Mode 	Opcode
SBC a 	ED
SBC a,x 	FD
SBC a,y 	F9
SBC # 	E9
SBC zp 	E5
SBC (zp,x) 	E1
SBC zp,x 	F5
SBC (zp),y 	F1

[edit] Increment and Decrement

Increment Memory by One: INC 

M + 1 -> M

Flags: N, Z
Addressing Mode 	Opcode
INC a 	EE
INC a,x 	FE
INC zp 	E6
INC zp,x 	F6

Increment Index X by One: INX 

X + 1 -> X

Flags: N, Z
Addressing Mode 	Opcode
INX i 	E8

Increment Index Y by One: INY

Y + 1 -> Y

Flags: N, Z
Addressing Mode 	Opcode
INY i 	C8

Decrement Memory by One: DEC 

M - 1 -> M

Flags: N, Z
Addressing Mode 	Opcode
DEC a 	CE
DEC a,x 	DE
DEC zp 	C6
DEC zp,x 	D6

Decrement Index X by One: DEX 

X - 1 -> X

Flags: N, Z
Addressing Mode 	Opcode
DEX i 	CA

Decrement Index Y by One: DEY 

Y - 1 -> Y

Flags: N, Z
Addressing Mode 	Opcode
DEY i 	88

[edit] Shift and Rotate

Arithmetic Shift Left One Bit: ASL 

C <- 7 6 5 4 3 2 1 0 <- 0

Flags: N, Z, C
Addressing Mode 	Opcode
ASL a 	0E
ASL a,x 	1E
ASL A 	0A
ASL zp 	06
ASL zp,x 	16

Logical Shift Right One Bit: LSR 

0 -> 7 6 5 4 3 2 1 0 -> C

Flags: N, Z, C
Addressing Mode 	Opcode
LSR a 	4E
LSR a,x 	5E
LSR A 	4A
LSR zp 	46
LSR zp,x 	56

Rotate Left One Bit: ROL 

C <- 7 6 5 4 3 2 1 0 <- C

Flags: N, Z, C
Addressing Mode 	Opcode
ROL a 	2E
ROL a,x 	3E
ROL A 	2A
ROL zp 	26
ROL zp,x 	36

Rotate Right One Bit: ROR 

C -> 7 6 5 4 3 2 1 0 -> C

Flags: N, Z, C
Addressing Mode 	Opcode
ROR a 	6E
ROR a,x 	7E
ROR A 	6A
ROR zp 	66
ROR zp,x 	76

[edit] Logic

AND Memory with Accumulator: AND 

A & M -> A

Flags: N, Z
Addressing Mode 	Opcode
AND a 	2D
AND a,x 	3D
AND a,y 	39
AND # 	29
AND zp 	25
AND (zp,x) 	21
AND zp,x 	35
AND (zp),y 	31

OR Memory with Accumulator: ORA 

A | M -> A

Flags: N, Z
Addressing Mode 	Opcode
ORA a 	0D
ORA a,x 	1D
ORA a,y 	19
ORA # 	09
ORA zp 	05
ORA (zp,x) 	01
ORA zp,x 	15
ORA (zp),y 	11

Exclusive-OR Memory with Accumulator: EOR 

A ^ M -> A

Flags: N, Z
Addressing Mode 	Opcode
EOR a 	4D
EOR a,x 	5D
EOR a,y 	59
EOR # 	49
EOR zp 	45
EOR (zp,x) 	41
EOR zp,x 	55
EOR (zp),y 	51

[edit] Compare and Test Bit

For all Compare instructions:
Condition 	N 	Z 	C
Register < Memory 	1 	0 	0
Register = Memory 	0 	1 	1
Register > Memory 	0 	0 	1

Compare Memory and Accumulator: CMP 

A - M

Flags: N, Z, C
Addressing Mode 	Opcode
CMP a 	CD
CMP a,x 	DD
CMP a,y 	D9
CMP # 	C9
CMP zp 	C5
CMP (zp,x) 	C1
CMP zp,x 	D5
CMP (zp),y 	D1

Compare Memory and Index X: CPX 

X - M

Flags: N, Z, C
Addressing Mode 	Opcode
CPX a 	EC
CPX # 	E0
CPX zp 	E4

Compare Memory with Index Y: CPY 

Y - M

Flags: N, Z, C
Addressing Mode 	Opcode
CPY a 	CC
CPY # 	C0
CPY zp 	C4

Test Bits in Memory with Accumulator: BIT 

A & M

Flags: N = M7, V = M6, Z
Addressing Mode 	Opcode
BIT a 	2C
BIT # 	89
BIT zp 	24

[edit] Branch

Branch on Carry Clear: BCC 

Branch if C = 0

Flags: none
Addressing Mode 	Opcode
BCC r 	90


Branch on Carry Set: BCS 

Branch if C = 1

Flags: none
Addressing Mode 	Opcode
BCS r 	B0


Branch on Result Zero: BEQ 

Branch if Z = 1

Flags: none
Addressing Mode 	Opcode
BEQ r 	F0


Branch on Result Minus: BMI 

Branch if N = 1

Flags: none
Addressing Mode 	Opcode
BMI r 	30


Branch on Result not Zero: BNE 

Branch if Z = 0

Flags: none
Addressing Mode 	Opcode
BNE r 	D0

Branch on Result Plus: BPL 

Branch if N = 0

Flags: none
Addressing Mode 	Opcode
BPL r 	10

Branch on Overflow Clear: BVC 

Branch if V = 0

Flags: none
Addressing Mode 	Opcode
BVC r 	50

Branch on Overflow Set: BVS 

Branch if V = 1

Flags: none
Addressing Mode 	Opcode
BVS r 	70

[edit] Transfer

Transfer Accumulator to Index X: TAX 

A -> X

Flags: N, Z
Addressing Mode 	Opcode
TAX i 	AA

Transfer Index X to Accumulator: TXA 

X -> A

Flags: N, Z
Addressing Mode 	Opcode
TXA i 	8A

Transfer Accumulator to Index Y: TAY 

A -> Y

Flags: N, Z
Addressing Mode 	Opcode
TAY i 	A8

Transfer Index Y to Accumulator: TYA 

Y -> A

Flags: N, Z
Addressing Mode 	Opcode
TYA i 	98

Transfer Stack Pointer to Index X: TSX 

S -> X

Flags: N, Z
Addressing Mode 	Opcode
TSX i 	BA

Transfer Index X to Stack Pointer: TXS 

X -> S

Flags: N, Z
Addressing Mode 	Opcode
TXS i 	9A

[edit] Stack

Push Accumulator on Stack: PHA 

A -> S

Flags: none
Addressing Mode 	Opcode
PHA i 	48

Pull Accumulator from Stack: PLA 

S -> A

Flags: N, Z
Addressing Mode 	Opcode
PLA i 	68

Push Processor Status on Stack: PHP 

P -> S

Flags: none
Addressing Mode 	Opcode
PHP i 	08

Pull Processor Status from Stack: PLP 

S -> P

Flags: all
Addressing Mode 	Opcode
PLP i 	28

[edit] Subroutines and Jump

Jump to New Location: JMP 

Jump to new location

Flags: none
Addressing Mode 	Opcode
JMP a 	4C
JMP (a,x) 	7C
JMP (a) 	6C

Jump to New Location Saving Return Address: JSR 

Jump to Subroutine

Flags: none
Addressing Mode 	Opcode
JSR a 	20

Return from Subroutine: RTS 

Return from Subroutine

Flags: none
Addressing Mode 	Opcode
RTS i 	60
 
Return from Interrupt: RTI 

Return from Interrupt

Flags: all
Addressing Mode 	Opcode
RTI i 	40

[edit] Set and Clear

Set Carry Flag: SEC 

1 -> C

Flags: C = 1
Addressing Mode 	Opcode
SEC i 	38

Set Decimal Mode: SED 

1 -> D

Flags: D = 1
Addressing Mode 	Opcode
SED i 	F8

Set Interrupt Disable Status: SEI 

1 -> I

Flags: I = 1
Addressing Mode 	Opcode
SEI i 	78

Clear Carry Flag: CLC 

0 -> C

Flags: C = 0
Addressing Mode 	Opcode
CLC i 	18

Clear Decimal Mode: CLD 

0 -> D

Flags: D = 0
Addressing Mode 	Opcode
CLD i 	D8

Clear Interrupt Disable Status: CLI 

0 -> I

Flags: I = 0
Addressing Mode 	Opcode
CLI i 	58

Clear Overflow Flag: CLV 

0 -> V

Flags: V = 0
Addressing Mode 	Opcode
CLV i 	B8

[edit] Miscellaneous

No Operation: NOP 

No Operation

Flags: none
Addressing Mode 	Opcode
NOP i 	EA

Break: BRK 

Force an Interrupt

Flags: B = 1, I = 1
Addressing Mode 	Opcode
BRK i 	00