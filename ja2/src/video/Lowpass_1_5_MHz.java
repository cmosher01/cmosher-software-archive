package video;

/*
 * Created on Jan 21, 2008
 */
public final class Lowpass_1_5_MHz
{
/*
 Filter Design Results
Generated by:   http://www-users.cs.york.ac.uk/~fisher/mkfilter

Summary
You specified the following parameters:

      filtertype 	= 	Butterworth
      passtype 	= 	Lowpass
      ripple 	= 	
      order 	= 	3
      samplerate 	= 	14318181.818181818181818181818182
      corner1 	= 	1431818.181818181818181818181818
      corner2 	= 	
      adzero 	= 	3579545.4545454545454545454545455
      logmin 	= 	

Results

Command line: /www/usr/fisher/helpers/mkfilter -Bu -Lp -o 3 -a 1.0000000000e-01 0.0000000000e+00 -Z 2.5000000000e-01
raw alpha1    =   0.1000000000
raw alpha2    =   0.1000000000
warped alpha1 =   0.1034251515
warped alpha2 =   0.1034251515
gain at dc    :   mag = 1.105037517e+02   phase =   0.0000000000 pi
gain at centre:   mag = 6.321493124e+01   phase =  -0.9500000000 pi
gain at hf    :   mag = 0.000000000e+00

S-plane zeros:

S-plane poles:
	 -0.3249196962 + j   0.5627774223
	 -0.6498393925 + j   0.0000000000
	 -0.3249196962 + j  -0.5627774223

Z-plane zeros:
	 -1.0000000000 + j   0.0000000000	3 times
	  0.0000000000 + j   1.0000000000
	  0.0000000000 + j  -1.0000000000

Z-plane poles:
	  0.6252582154 + j   0.3934151491
	  0.5095254495 + j   0.0000000000
	  0.6252582154 + j  -0.3934151491
	  0.0000000000 + j   0.0000000000	2 times

Recurrence relation:
y[n] = (  1 * x[n- 5])
     + (  3 * x[n- 4])
     + (  4 * x[n- 3])
     + (  4 * x[n- 2])
     + (  3 * x[n- 1])
     + (  1 * x[n- 0])

     + ( -0.0000000000 * y[n- 5])
     + ( -0.0000000000 * y[n- 4])
     + (  0.2780599176 * y[n- 3])
     + ( -1.1828932620 * y[n- 2])
     + (  1.7600418803 * y[n- 1])


Ansi C Code

/* Digital filter designed by mkfilter/mkshape/gencode   A.J. Fisher
   Command line: /www/usr/fisher/helpers/mkfilter -Bu -Lp -o 3 -a 1.0000000000e-01 0.0000000000e+00 -Z 2.5000000000e-01 -l

#define NZEROS 5
#define NPOLES 5
#define GAIN   1.105037518e+02

static float xv[NZEROS+1], yv[NPOLES+1];

static void filterloop()
  { for (;;)
      { xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4]; xv[4] = xv[5]; 
        xv[5] = next input value / GAIN;
        yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4]; yv[4] = yv[5]; 
        yv[5] =   (xv[0] + xv[5]) + 3 * (xv[1] + xv[4]) + 4 * (xv[2] + xv[3])
                     + ( -0.0000000000 * yv[0]) + ( -0.0000000000 * yv[1])
                     + (  0.2780599176 * yv[2]) + ( -1.1828932620 * yv[3])
                     + (  1.7600418803 * yv[4]);
        next output value = yv[5];
      }
  }
*/
	private static final int NZEROS = 5;
	private static final int NPOLES = 5;
	private static final int GAIN = 98;
	private final int[] xv = new int[NZEROS + 1];
	private final int[] yv = new int[NPOLES + 1];

	public int transition(final int next_input_value)
	{
		xv[0] = xv[1];
		xv[1] = xv[2];
		xv[2] = xv[3];
		xv[3] = xv[4];
		xv[4] = xv[5];
		xv[5] = next_input_value / GAIN;

		yv[0] = yv[1];
		yv[1] = yv[2];
		yv[2] = yv[3];
		yv[3] = yv[4];
		yv[4] = yv[5];
		mult();
		return yv[5];
	}

	private void mult()
	{
		yv[5] = (xv[0] + xv[5]) + 3 * (xv[1]+xv[4])  +((xv[2]+xv[3])<<2)    + (yv[2]>>2) - yv[3]*38/32  +yv[4]*7/4;
	}
}
