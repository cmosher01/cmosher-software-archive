REQUESTS FOR COUNTS
-------------------






EpanCountRequest
----------------
EpanCountRequest(epanCountCriteria)
    creates a new count (in memory only)
    use UUIDs for pks?
    limit to 1000 geo codes
EpanCountRequest(pk)
    reads in an existing count from db (doesn't lock row)
    includes all child (count) records
clone()
    ??? need some way to make a new request that's based
    on an existing request; clone? copy?
    should the new one autogenerate a new pk?
clear()
    removes existing counts (so becomes un-frozen)
    ??? need to lock first?
epanCountCriteria = getCriteria()
    simple accessor??? is result read-only? if not, then need
    to lock first?
pk = getPK()
    simple accessor (UUID)
n = getQueryCount()
n = getQueryCountSoFar()
<EpanCount> iterator()
EpanCount getCount(index)
isFrozen()
    frozen means not editable (that is, can't change criteria)
    it is frozen if at least one count finished successfully
    or if we are currently running a count. Basically, as soon
    as the user starts the request running, it is frozen from then on
    (unless they abort it before the first count finishes???)
couldLockOK = lockForEdit()
    tries to lock row in database
    returns true if the row is now locked and is OK to edit
    returns false if row is currently locked by someone else
        (should we provide a way to find out who has it locked?)
        (someone else could lock the row either by calling this
        method on the request, or by having any queries in the
        request currently pending or executing)
    or maybe we just do optimistic locking instead (based on
    modSerial number: get it upon read, then check it upon re-save)
    if so, what to do if someone else modifies the one we are editing?
    maybe automatically save it as a new request, and warn the user?
    (if the one we are editing changes, we will get notifed thru
    the normal EpanCountList mechanism... what happens? maybe the
    one I'm editing get "detached" from it's old list entry, essentially
    making it a "new" request)
saveToDatabase()
    saves existing and releases row-lock, or inserts new, in db
    includes saving all child (count) records
enqueueRun(EpanCountDoneListener)
    enqueues the queries for this count into the internal
    queue of statements that are handled by the db-access thread
    EpanCountDoneListener.completed is called when each query completes
    once at least one count finishes successfully, we need to "freeze"
    the request (even in the database) to prevent any future modifications
    do we need to save each count immediately when it comes back?
    what about completions with error?
    should this method wait to return until the count is done? I think so;
    and it should still notify listeners upon each count finishing
abort()
    aborts all currently pending or executing queries
    does nothing if no currently pending or executing queries



EpanCountDoneListener
---------------------
completed(EpanCount)



EpanCount
---------
EpanCountRequest = getRequest()
    simple accessor
getIndex()
    the request can be "broken out" by geo and/or gender
    do we need some way to indicate which combination of geo/gender
    this EpanCount represents??? maybe a simple ordinal?
isNew()
    has been created, but not enqueued to run
isEnqueued()
    has been enqueued to run, and hasn't started
    running yet (if it has been aborted, this method
    won't indicated that, it will still be enqueued;
    when the db-access thread runs it, it will complete
    with errors)
isRunning()
    has started running and hasn't finished
isDone()
    finished running (successfully or with error)
    equivalent to completedWithError()||completedSuccessfully()
err = completedWithError()
    finished running, with error, can call getThrowable() to get the error
ok = completedSuccessfully()
    finished running, no error, can call getCount() to get the count
n = getCount()
    throws runtime exception if query completed with error
Throwable = getThrowable()
    throws runtime exception if query completed successfully
EpanCountDebugInfo = getDebugInfo()




EpanCountDebugInfo
------------------
getStartTime()
getStopTime()
getPK()
getCountSQL()
getSummarySQL()
otherDebugAccessors()???






EpanCountCriteria
-----------------
??? simple XML structure mirroring check-boxes
and other controls in the GUI ???
then what about xdem criteria? Use a set of XDemCriteria (and
child) tables in the EpanCount schema. XdemCriteria table
will have countRequestID instead of extSpecID foreign key.
Use JAXB to generate java classes based on schema definition
of criteria:
Main schema could include individual schemas for income enum,
marrital status enum, etc. These could be generated programmatically
and could include the IDs. (Note that related to this process,
we could have a process that generates the Thinlet XML GUI
screen definition based on data selected from these tables.)


















attempt 2
---------
use optmistic locking (no locking until the
user tries to save changes)

note: limit to 1000 geo codes



EpanRequest
----------------
EpanRequest(epanCountCriteria)
    creates a new count (in memory only)
    generate a new pk (UUID)
EpanRequest(pk)
    reads in an existing count from db
    includes all child (count) records
clone()
    create new EpanCountRequest
    clear()
    generate a new pk
clear()
    removes existing counts (so becomes un-frozen)
    modSerial = 0
epanCountCriteria = getCriteria()
    simple accessor
pk = getPK()
    simple accessor (UUID)
n = getQueryCount()
    simple accessor
n = getQueryCountSoFar()
    simple accessor
<EpanCount> iterator()
    iterate that iterates over EpanCount child records
EpanCount getCount(index)
    allows access to an EpanCount child records
isFrozen()
    frozen means not editable (that is, can't change criteria)
    it is frozen if at least one count finished successfully
    or if we are currently running a count. Basically, as soon
    as the user starts the request running, it is frozen from then on
    (unless they abort it before the first count finishes???)
saveToDatabase()
    if (modSerial==0)
        this is a new record, so insert it
    else
        UPDATE CountRequest SET ... WHERE countRequestID = mPK AND modSerial = mModSerial
        if zero row were updated
            this means that someone else updated the record in the database
            concurrently while we were changing it.
            clear()
            generate new pk
            warn user
            saveToDatabase recursive call
        else
            saves existing and releases row-lock, or inserts new, in db
            save all EpanCount child records
        end if
    end if
run(EpanCountDoneListener)
    Does each count query and waits for the results.
    Do we need to save each count immediately when it comes back???
    What about completions with error???
    EpanCountDoneListener.completed is called when each query completes.
abort()
    aborts all currently pending or executing queries
    does nothing if no currently pending or executing queries

EpanCountDoneListener
---------------------
(implemented by caller)





EpanCountListener
-----------------
[
Note:
if our EpanCountList listener gets notification of a change
to a EpanRequest (or child, or course) that we are editing,
just call saveToDatabase, and it will warn the user and
convert it to a new record???
]
