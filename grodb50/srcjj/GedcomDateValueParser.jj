options
{
	IGNORE_CASE = true;
	STATIC = false;
}



PARSER_BEGIN(GedcomDateValueParser)

package nu.mine.mosher.gedcom.date.parser;

import nu.mine.mosher.grodb.YMD;
import nu.mine.mosher.grodb.DateRange;
import nu.mine.mosher.grodb.TimeZoneUnknown;

//import java.util.HashMap;
//import java.util.Map;

class GedcomDateValueParser
{
//	private static final Map mapMonthTokenToInt = new HashMap();
//	private static int nextMonth = 1;
//	public static void addNextMonth(final String month)
//	{
//		mapMonthTokenToInt.put(month,new Integer(nextMonth));
//		++nextMonth;
//	}
}

PARSER_END(GedcomDateValueParser)



SKIP :
{
	" " | "\t" | "\n" | "\r"
}

TOKEN :
{
	< FROM:        "FROM" > |
	< TO:          "TO"   > |
	< BEFORE:      "BEF"  > |
	< AFTER:       "AFT"  > |
	< BETWEEN:     "BET"  > |
	< AND:         "AND"  > |
	< ABOUT:       "ABT"  > |
	< CALCULATED:  "CAL"  > |
	< ESTIMATED:   "EST"  > |
	< INTERPRETED: "INT"  >
}

TOKEN :
{
	/*	< MONTH:
		"JAN" | "FEB" | "MAR" | "APR" | "MAY" | "JUN" |
		"JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC" 
		JAN | FEB > |*/
	< MONTH_LOWER_LIMIT: [] > |
	< JAN: "JAN" > |
	< FEB: "FEB" > |
	< MAR: "MAR" > |
	< APR: "APR" > |
	< MAY: "MAY" > |
	< JUN: "JUN" > |
	< JUL: "JUL" > |
	< AUG: "AUG" > |
	< SEP: "SEP" > |
	< OCT: "OCT" > |
	< NOV: "NOV" > |
	< DEC: "DEC" >
}

TOKEN :
{
	< GREGORIAN: "GREGORIAN" > |
	< JULIAN: "JULIAN" >
}

TOKEN :
{
	< LPAREN:  "(" > |
	< RPAREN:  ")" > |
	< NUMBER:  (["0"-"9"])+ > |
	< SLASH:   "/" > |
	< AT:      "@" > |
	< RAWTEXT: ~[")"] >
}

TOKEN :
{
	< BC: "BC" | "B.C." > |
	< CALENDAR_ESC: "#D" >
}

void DateValue() : {}
{
	(
		DatePeriod() |
		DateRange() |
		DateApproximated() |
		DateInterpreted() |
		DatePhrase() |
		Date()
	)

	<EOF>
}

void DateRange() : {}
{
	<BEFORE> Date() | <AFTER> Date() | <BETWEEN> Date() <AND> Date()
}

void DateApproximated() : {}
{
	<ABOUT> Date() | <CALCULATED> Date() | <ESTIMATED> Date()
}

void DateInterpreted() : {}
{
	<INTERPRETED> Date() DatePhrase()
}

void DatePhrase() : {}
{
	<LPAREN> <RAWTEXT> <RPAREN>
}

void DatePeriod() : {}
{
	<FROM> Date() [ <TO> Date() ] |
	<TO> Date()
}

void Date() : {}
{
	{
		boolean julian = false;
		YMD ymd;
	}
	[ julian = DateCalendarEscape() ] ymd = DateCalendar()
	{
	}
}

boolean DateCalendarEscape() : {}
{
	{
		Token cal;
	}
	<AT> <CALENDAR_ESC> ( cal = <GREGORIAN> | cal = <JULIAN> ) <AT>
	{
		return cal.kind == JULIAN;
	}
}

YMD DateCalendar() : {}
{
	{
		int year = 0;
		int month = 0;
		int day = 0;
	}
	[ LOOKAHEAD(2) [ day = Day() ] month = Month() ] year = Year()
	{
		return new YMD(year,month,day);
	}
}

int Day() : {}
{
	<NUMBER>
	{
		return Integer.parseInt(this.token.image);
	}
}

int Month() : {}
{
	(
		<JAN> | <FEB> | <MAR> | <APR> | <MAY> | <JUN> |
		<JUL> | <AUG> | <SEP> | <OCT> | <NOV> | <DEC>
	)
	{
		return this.token.kind - MONTH_LOWER_LIMIT;
	}
}

int Year() : {}
{
	{
		Token year;
		boolean gregorian = false;
		boolean bc = false;
	}
	year = <NUMBER>	[ gregorian = SlashYear() ]	[ LOOKAHEAD(2) bc = BC() ]
	{
		int y = Integer.parseInt(year.image);
		if (gregorian)
		{
			++y;
		}
		if (bc)
		{
			y = -y;
		}
		if (y == 0)
		{
			throw new ParseException("year cannot be zero.");
		}
		return y;
	}
}

boolean SlashYear() : {}
{
	<SLASH> <NUMBER>
	{
		return true;
	}
}

boolean BC() : {}
{
	[ <LPAREN> ] <BC> [ <RPAREN> ]
	{
		return true;
	}
}
